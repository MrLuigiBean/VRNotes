{"version":3,"file":"effectLayerSceneComponent.js","sourceRoot":"","sources":["../../../../dev/core/src/Layers/effectLayerSceneComponent.ts"],"names":[],"mappings":"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","sourcesContent":["import { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { ISceneSerializableComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n// Adds the parser to the scene parsers.\r\nAbstractScene.AddParser(SceneComponentConstants.NAME_EFFECTLAYER, (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => {\r\n    if (parsedData.effectLayers) {\r\n        if (!container.effectLayers) {\r\n            container.effectLayers = [] as EffectLayer[];\r\n        }\r\n\r\n        for (let index = 0; index < parsedData.effectLayers.length; index++) {\r\n            const effectLayer = EffectLayer.Parse(parsedData.effectLayers[index], scene, rootUrl);\r\n            container.effectLayers.push(effectLayer);\r\n        }\r\n    }\r\n});\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of effect layers (highlights/glow) added to the scene\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/highlightLayer\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/glowLayer\r\n         */\r\n        effectLayers: Array<EffectLayer>;\r\n\r\n        /**\r\n         * Removes the given effect layer from this scene.\r\n         * @param toRemove defines the effect layer to remove\r\n         * @returns the index of the removed effect layer\r\n         */\r\n        removeEffectLayer(toRemove: EffectLayer): number;\r\n\r\n        /**\r\n         * Adds the given effect layer to this scene\r\n         * @param newEffectLayer defines the effect layer to add\r\n         */\r\n        addEffectLayer(newEffectLayer: EffectLayer): void;\r\n    }\r\n}\r\n\r\nAbstractScene.prototype.removeEffectLayer = function (toRemove: EffectLayer): number {\r\n    const index = this.effectLayers.indexOf(toRemove);\r\n    if (index !== -1) {\r\n        this.effectLayers.splice(index, 1);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nAbstractScene.prototype.addEffectLayer = function (newEffectLayer: EffectLayer): void {\r\n    this.effectLayers.push(newEffectLayer);\r\n};\r\n\r\n/**\r\n * Defines the layer scene component responsible to manage any effect layers\r\n * in a given scene.\r\n */\r\nexport class EffectLayerSceneComponent implements ISceneSerializableComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_EFFECTLAYER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _engine: Engine;\r\n    private _renderEffects = false;\r\n    private _needStencil = false;\r\n    private _previousStencilState = false;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this.scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this.scene) {\r\n            return;\r\n        }\r\n        this._engine = this.scene.getEngine();\r\n        this.scene.effectLayers = [] as EffectLayer[];\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._isReadyForMeshStage.registerStep(SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh);\r\n\r\n        this.scene._cameraDrawRenderTargetStage.registerStep(SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture);\r\n\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil);\r\n\r\n        this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup);\r\n\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        const layers = this.scene.effectLayers;\r\n        for (const effectLayer of layers) {\r\n            effectLayer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        // Effect layers\r\n        serializationObject.effectLayers = [];\r\n\r\n        const layers = this.scene.effectLayers;\r\n        for (const effectLayer of layers) {\r\n            if (effectLayer.serialize) {\r\n                serializationObject.effectLayers.push(effectLayer.serialize());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: AbstractScene): void {\r\n        if (!container.effectLayers) {\r\n            return;\r\n        }\r\n        container.effectLayers.forEach((o) => {\r\n            this.scene.addEffectLayer(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: AbstractScene, dispose?: boolean): void {\r\n        if (!container.effectLayers) {\r\n            return;\r\n        }\r\n        container.effectLayers.forEach((o) => {\r\n            this.scene.removeEffectLayer(o);\r\n            if (dispose) {\r\n                o.dispose();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const layers = this.scene.effectLayers;\r\n        while (layers.length) {\r\n            layers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _isReadyForMesh(mesh: AbstractMesh, hardwareInstancedRendering: boolean): boolean {\r\n        const currentRenderPassId = this._engine.currentRenderPassId;\r\n        const layers = this.scene.effectLayers;\r\n        for (const layer of layers) {\r\n            if (!layer.hasMesh(mesh)) {\r\n                continue;\r\n            }\r\n\r\n            const renderTarget = <RenderTargetTexture>(<any>layer)._mainTexture;\r\n            this._engine.currentRenderPassId = renderTarget.renderPassId;\r\n\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (!layer.isReady(subMesh, hardwareInstancedRendering)) {\r\n                    this._engine.currentRenderPassId = currentRenderPassId;\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        this._engine.currentRenderPassId = currentRenderPassId;\r\n        return true;\r\n    }\r\n\r\n    private _renderMainTexture(camera: Camera): boolean {\r\n        this._renderEffects = false;\r\n        this._needStencil = false;\r\n\r\n        let needRebind = false;\r\n\r\n        const layers = this.scene.effectLayers;\r\n        if (layers && layers.length > 0) {\r\n            this._previousStencilState = this._engine.getStencilBuffer();\r\n            for (const effectLayer of layers) {\r\n                if (\r\n                    effectLayer.shouldRender() &&\r\n                    (!effectLayer.camera ||\r\n                        (effectLayer.camera.cameraRigMode === Camera.RIG_MODE_NONE && camera === effectLayer.camera) ||\r\n                        (effectLayer.camera.cameraRigMode !== Camera.RIG_MODE_NONE && effectLayer.camera._rigCameras.indexOf(camera) > -1))\r\n                ) {\r\n                    this._renderEffects = true;\r\n                    this._needStencil = this._needStencil || effectLayer.needStencil();\r\n\r\n                    const renderTarget = <RenderTargetTexture>(<any>effectLayer)._mainTexture;\r\n                    if (renderTarget._shouldRender()) {\r\n                        this.scene.incrementRenderId();\r\n                        renderTarget.render(false, false);\r\n                        needRebind = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.scene.incrementRenderId();\r\n        }\r\n\r\n        return needRebind;\r\n    }\r\n\r\n    private _setStencil() {\r\n        // Activate effect Layer stencil\r\n        if (this._needStencil) {\r\n            this._engine.setStencilBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _setStencilBack() {\r\n        // Restore effect Layer stencil\r\n        if (this._needStencil) {\r\n            this._engine.setStencilBuffer(this._previousStencilState);\r\n        }\r\n    }\r\n\r\n    private _draw(renderingGroupId: number): void {\r\n        if (this._renderEffects) {\r\n            this._engine.setDepthBuffer(false);\r\n\r\n            const layers = this.scene.effectLayers;\r\n            for (let i = 0; i < layers.length; i++) {\r\n                const effectLayer = layers[i];\r\n                if (effectLayer.renderingGroupId === renderingGroupId) {\r\n                    if (effectLayer.shouldRender()) {\r\n                        effectLayer.render();\r\n                    }\r\n                }\r\n            }\r\n            this._engine.setDepthBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _drawCamera(): void {\r\n        if (this._renderEffects) {\r\n            this._draw(-1);\r\n        }\r\n    }\r\n    private _drawRenderingGroup(index: number): void {\r\n        if (!this.scene._isInIntermediateRendering() && this._renderEffects) {\r\n            this._draw(index);\r\n        }\r\n    }\r\n}\r\n\r\nEffectLayer._SceneComponentInitialization = (scene: Scene) => {\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_EFFECTLAYER) as EffectLayerSceneComponent;\r\n    if (!component) {\r\n        component = new EffectLayerSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"]}