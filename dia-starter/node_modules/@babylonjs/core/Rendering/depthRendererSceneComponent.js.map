{"version":3,"file":"depthRendererSceneComponent.js","sourceRoot":"","sources":["../../../../dev/core/src/Rendering/depthRendererSceneComponent.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport type { SmartArrayNoDuplicate } from \"../Misc/smartArray\";\r\nimport { DepthRenderer } from \"./depthRenderer\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal (Backing field) */\r\n        _depthRenderer: { [id: string]: DepthRenderer };\r\n\r\n        /**\r\n         * Creates a depth renderer a given camera which contains a depth map which can be used for post processing.\r\n         * @param camera The camera to create the depth renderer on (default: scene's active camera)\r\n         * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\r\n         * @param force32bitsFloat Forces 32 bits float when supported (else 16 bits float is prioritized over 32 bits float if supported)\r\n         * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...)\r\n         * @param storeCameraSpaceZ Defines whether the depth stored is the Z coordinate in camera space. If true, storeNonLinearDepth has no effect. (Default: false)\r\n         * @returns the created depth renderer\r\n         */\r\n        enableDepthRenderer(\r\n            camera?: Nullable<Camera>,\r\n            storeNonLinearDepth?: boolean,\r\n            force32bitsFloat?: boolean,\r\n            samplingMode?: number,\r\n            storeCameraSpaceZ?: boolean\r\n        ): DepthRenderer;\r\n\r\n        /**\r\n         * Disables a depth renderer for a given camera\r\n         * @param camera The camera to disable the depth renderer on (default: scene's active camera)\r\n         */\r\n        disableDepthRenderer(camera?: Nullable<Camera>): void;\r\n    }\r\n}\r\n\r\nScene.prototype.enableDepthRenderer = function (\r\n    camera?: Nullable<Camera>,\r\n    storeNonLinearDepth = false,\r\n    force32bitsFloat: boolean = false,\r\n    samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n    storeCameraSpaceZ: boolean = false\r\n): DepthRenderer {\r\n    camera = camera || this.activeCamera;\r\n    if (!camera) {\r\n        throw \"No camera available to enable depth renderer\";\r\n    }\r\n    if (!this._depthRenderer) {\r\n        this._depthRenderer = {};\r\n    }\r\n    if (!this._depthRenderer[camera.id]) {\r\n        const supportFullfloat = !!this.getEngine().getCaps().textureFloatRender;\r\n        let textureType = 0;\r\n        if (this.getEngine().getCaps().textureHalfFloatRender && (!force32bitsFloat || !supportFullfloat)) {\r\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        } else if (supportFullfloat) {\r\n            textureType = Constants.TEXTURETYPE_FLOAT;\r\n        } else {\r\n            textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        }\r\n        this._depthRenderer[camera.id] = new DepthRenderer(this, textureType, camera, storeNonLinearDepth, samplingMode, storeCameraSpaceZ);\r\n    }\r\n\r\n    return this._depthRenderer[camera.id];\r\n};\r\n\r\nScene.prototype.disableDepthRenderer = function (camera?: Nullable<Camera>): void {\r\n    camera = camera || this.activeCamera;\r\n    if (!camera || !this._depthRenderer || !this._depthRenderer[camera.id]) {\r\n        return;\r\n    }\r\n\r\n    this._depthRenderer[camera.id].dispose();\r\n};\r\n\r\n/**\r\n * Defines the Depth Renderer scene component responsible to manage a depth buffer useful\r\n * in several rendering techniques.\r\n */\r\nexport class DepthRendererSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_DEPTHRENDERER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_DEPTHRENDERER, this, this._gatherRenderTargets);\r\n        this.scene._gatherActiveCameraRenderTargetsStage.registerStep(\r\n            SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER,\r\n            this,\r\n            this._gatherActiveCameraRenderTargets\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        for (const key in this.scene._depthRenderer) {\r\n            this.scene._depthRenderer[key].dispose();\r\n        }\r\n    }\r\n\r\n    private _gatherRenderTargets(renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>): void {\r\n        if (this.scene._depthRenderer) {\r\n            for (const key in this.scene._depthRenderer) {\r\n                const depthRenderer = this.scene._depthRenderer[key];\r\n                if (depthRenderer.enabled && !depthRenderer.useOnlyInActiveCamera) {\r\n                    renderTargets.push(depthRenderer.getDepthMap());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _gatherActiveCameraRenderTargets(renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>): void {\r\n        if (this.scene._depthRenderer) {\r\n            for (const key in this.scene._depthRenderer) {\r\n                const depthRenderer = this.scene._depthRenderer[key];\r\n                if (depthRenderer.enabled && depthRenderer.useOnlyInActiveCamera && this.scene.activeCamera!.id === key) {\r\n                    renderTargets.push(depthRenderer.getDepthMap());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nDepthRenderer._SceneComponentInitialization = (scene: Scene) => {\r\n    // Register the G Buffer component to the scene.\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_DEPTHRENDERER) as DepthRendererSceneComponent;\r\n    if (!component) {\r\n        component = new DepthRendererSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"]}