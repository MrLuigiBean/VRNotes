{"version":3,"file":"csg.js","sourceRoot":"","sources":["../../../../dev/core/src/Meshes/csg.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { VertexData } from \"./mesh.vertexData\";\r\n/**\r\n * Unique ID when we import meshes from Babylon to CSG\r\n */\r\nlet currentCSGMeshId = 0;\r\n\r\n/**\r\n * Represents a vertex of a polygon. Use your own vertex class instead of this\r\n * one to provide additional features like texture coordinates and vertex\r\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\r\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\r\n * defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience\r\n * functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`\r\n * is not used anywhere else.\r\n * Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes\r\n */\r\nclass Vertex {\r\n    /**\r\n     * Initializes the vertex\r\n     * @param pos The position of the vertex\r\n     * @param normal The normal of the vertex\r\n     * @param uv The texture coordinate of the vertex\r\n     * @param vertColor The RGBA color of the vertex\r\n     */\r\n    constructor(\r\n        /**\r\n         * The position of the vertex\r\n         */\r\n        public pos: Vector3,\r\n        /**\r\n         * The normal of the vertex\r\n         */\r\n        public normal: Vector3,\r\n        /**\r\n         * The texture coordinate of the vertex\r\n         */\r\n        public uv?: Vector2,\r\n        /**\r\n         * The texture coordinate of the vertex\r\n         */\r\n        public vertColor?: Color4\r\n    ) {}\r\n\r\n    /**\r\n     * Make a clone, or deep copy, of the vertex\r\n     * @returns A new Vertex\r\n     */\r\n    public clone(): Vertex {\r\n        return new Vertex(this.pos.clone(), this.normal.clone(), this.uv?.clone(), this.vertColor?.clone());\r\n    }\r\n\r\n    /**\r\n     * Invert all orientation-specific data (e.g. vertex normal). Called when the\r\n     * orientation of a polygon is flipped.\r\n     */\r\n    public flip(): void {\r\n        this.normal = this.normal.scale(-1);\r\n    }\r\n\r\n    /**\r\n     * Create a new vertex between this vertex and `other` by linearly\r\n     * interpolating all properties using a parameter of `t`. Subclasses should\r\n     * override this to interpolate additional properties.\r\n     * @param other the vertex to interpolate against\r\n     * @param t The factor used to linearly interpolate between the vertices\r\n     */\r\n    public interpolate(other: Vertex, t: number): Vertex {\r\n        return new Vertex(\r\n            Vector3.Lerp(this.pos, other.pos, t),\r\n            Vector3.Lerp(this.normal, other.normal, t),\r\n            this.uv && other.uv ? Vector2.Lerp(this.uv, other.uv, t) : undefined,\r\n            this.vertColor && other.vertColor ? Color4.Lerp(this.vertColor, other.vertColor, t) : undefined\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a plane in 3D space.\r\n */\r\nclass CSGPlane {\r\n    /**\r\n     * Initializes the plane\r\n     * @param normal The normal for the plane\r\n     * @param w\r\n     */\r\n    constructor(\r\n        public normal: Vector3,\r\n        public w: number\r\n    ) {}\r\n\r\n    /**\r\n     * `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\r\n     * point is on the plane\r\n     */\r\n    static EPSILON = 1e-5;\r\n\r\n    /**\r\n     * Construct a plane from three points\r\n     * @param a Point a\r\n     * @param b Point b\r\n     * @param c Point c\r\n     */\r\n    public static FromPoints(a: Vector3, b: Vector3, c: Vector3): Nullable<CSGPlane> {\r\n        const v0 = c.subtract(a);\r\n        const v1 = b.subtract(a);\r\n\r\n        if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {\r\n            return null;\r\n        }\r\n\r\n        const n = Vector3.Normalize(Vector3.Cross(v0, v1));\r\n        return new CSGPlane(n, Vector3.Dot(n, a));\r\n    }\r\n\r\n    /**\r\n     * Clone, or make a deep copy of the plane\r\n     * @returns a new Plane\r\n     */\r\n    public clone(): CSGPlane {\r\n        return new CSGPlane(this.normal.clone(), this.w);\r\n    }\r\n\r\n    /**\r\n     * Flip the face of the plane\r\n     */\r\n    public flip() {\r\n        this.normal.scaleInPlace(-1);\r\n        this.w = -this.w;\r\n    }\r\n\r\n    /**\r\n     * Split `polygon` by this plane if needed, then put the polygon or polygon\r\n     * fragments in the appropriate lists. Coplanar polygons go into either\r\n    `* coplanarFront` or `coplanarBack` depending on their orientation with\r\n     * respect to this plane. Polygons in front or in back of this plane go into\r\n     * either `front` or `back`\r\n     * @param polygon The polygon to be split\r\n     * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane\r\n     * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane\r\n     * @param front Will contain the polygons in front of the plane\r\n     * @param back Will contain the polygons begind the plane\r\n     */\r\n    public splitPolygon(polygon: CSGPolygon, coplanarFront: CSGPolygon[], coplanarBack: CSGPolygon[], front: CSGPolygon[], back: CSGPolygon[]): void {\r\n        const COPLANAR = 0;\r\n        const FRONT = 1;\r\n        const BACK = 2;\r\n        const SPANNING = 3;\r\n\r\n        // Classify each point as well as the entire polygon into one of the above\r\n        // four classes.\r\n        let polygonType = 0;\r\n        const types = [];\r\n        let i: number;\r\n        let t: number;\r\n        for (i = 0; i < polygon.vertices.length; i++) {\r\n            t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;\r\n            const type = t < -CSGPlane.EPSILON ? BACK : t > CSGPlane.EPSILON ? FRONT : COPLANAR;\r\n            polygonType |= type;\r\n            types.push(type);\r\n        }\r\n\r\n        // Put the polygon in the correct list, splitting it when necessary\r\n        switch (polygonType) {\r\n            case COPLANAR:\r\n                (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\r\n                break;\r\n            case FRONT:\r\n                front.push(polygon);\r\n                break;\r\n            case BACK:\r\n                back.push(polygon);\r\n                break;\r\n            case SPANNING: {\r\n                const f = [],\r\n                    b = [];\r\n                for (i = 0; i < polygon.vertices.length; i++) {\r\n                    const j = (i + 1) % polygon.vertices.length;\r\n                    const ti = types[i],\r\n                        tj = types[j];\r\n                    const vi = polygon.vertices[i],\r\n                        vj = polygon.vertices[j];\r\n                    if (ti !== BACK) {\r\n                        f.push(vi);\r\n                    }\r\n                    if (ti !== FRONT) {\r\n                        b.push(ti !== BACK ? vi.clone() : vi);\r\n                    }\r\n                    if ((ti | tj) === SPANNING) {\r\n                        t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));\r\n                        const v = vi.interpolate(vj, t);\r\n                        f.push(v);\r\n                        b.push(v.clone());\r\n                    }\r\n                }\r\n                let poly: CSGPolygon;\r\n                if (f.length >= 3) {\r\n                    poly = new CSGPolygon(f, polygon.shared);\r\n                    if (poly.plane) {\r\n                        front.push(poly);\r\n                    }\r\n                }\r\n\r\n                if (b.length >= 3) {\r\n                    poly = new CSGPolygon(b, polygon.shared);\r\n\r\n                    if (poly.plane) {\r\n                        back.push(poly);\r\n                    }\r\n                }\r\n\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a convex polygon. The vertices used to initialize a polygon must\r\n * be coplanar and form a convex loop.\r\n *\r\n * Each convex polygon has a `shared` property, which is shared between all\r\n * polygons that are clones of each other or were split from the same polygon.\r\n * This can be used to define per-polygon properties (such as surface color)\r\n */\r\nclass CSGPolygon {\r\n    /**\r\n     * Vertices of the polygon\r\n     */\r\n    public vertices: Vertex[];\r\n    /**\r\n     * Properties that are shared across all polygons\r\n     */\r\n    public shared: any;\r\n    /**\r\n     * A plane formed from the vertices of the polygon\r\n     */\r\n    public plane: CSGPlane;\r\n\r\n    /**\r\n     * Initializes the polygon\r\n     * @param vertices The vertices of the polygon\r\n     * @param shared The properties shared across all polygons\r\n     */\r\n    constructor(vertices: Vertex[], shared: any) {\r\n        this.vertices = vertices;\r\n        this.shared = shared;\r\n        this.plane = <CSGPlane>CSGPlane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, or the polygon\r\n     */\r\n    public clone(): CSGPolygon {\r\n        const vertices = this.vertices.map((v) => v.clone());\r\n        return new CSGPolygon(vertices, this.shared);\r\n    }\r\n\r\n    /**\r\n     * Flips the faces of the polygon\r\n     */\r\n    public flip() {\r\n        this.vertices.reverse().map((v) => {\r\n            v.flip();\r\n        });\r\n        this.plane.flip();\r\n    }\r\n}\r\n\r\n/**\r\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\r\n * by picking a polygon to split along. That polygon (and all other coplanar\r\n * polygons) are added directly to that node and the other polygons are added to\r\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\r\n * no distinction between internal and leaf nodes\r\n */\r\nclass Node {\r\n    private _plane: Nullable<CSGPlane> = null;\r\n    private _front: Nullable<Node> = null;\r\n    private _back: Nullable<Node> = null;\r\n    private _polygons = new Array<CSGPolygon>();\r\n\r\n    /**\r\n     * Initializes the node\r\n     * @param polygons A collection of polygons held in the node\r\n     */\r\n    constructor(polygons?: Array<CSGPolygon>) {\r\n        if (polygons) {\r\n            this.build(polygons);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, of the node\r\n     * @returns The cloned node\r\n     */\r\n    public clone(): Node {\r\n        const node = new Node();\r\n        node._plane = this._plane && this._plane.clone();\r\n        node._front = this._front && this._front.clone();\r\n        node._back = this._back && this._back.clone();\r\n        node._polygons = this._polygons.map((p) => p.clone());\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * Convert solid space to empty space and empty space to solid space\r\n     */\r\n    public invert(): void {\r\n        for (let i = 0; i < this._polygons.length; i++) {\r\n            this._polygons[i].flip();\r\n        }\r\n        if (this._plane) {\r\n            this._plane.flip();\r\n        }\r\n        if (this._front) {\r\n            this._front.invert();\r\n        }\r\n        if (this._back) {\r\n            this._back.invert();\r\n        }\r\n        const temp = this._front;\r\n        this._front = this._back;\r\n        this._back = temp;\r\n    }\r\n\r\n    /**\r\n     * Recursively remove all polygons in `polygons` that are inside this BSP\r\n     * tree.\r\n     * @param polygons Polygons to remove from the BSP\r\n     * @returns Polygons clipped from the BSP\r\n     */\r\n    clipPolygons(polygons: CSGPolygon[]): CSGPolygon[] {\r\n        if (!this._plane) {\r\n            return polygons.slice();\r\n        }\r\n        let front: CSGPolygon[] = [],\r\n            back = [] as CSGPolygon[];\r\n        for (let i = 0; i < polygons.length; i++) {\r\n            this._plane.splitPolygon(polygons[i], front, back, front, back);\r\n        }\r\n        if (this._front) {\r\n            front = this._front.clipPolygons(front);\r\n        }\r\n        if (this._back) {\r\n            back = this._back.clipPolygons(back);\r\n        } else {\r\n            back = [];\r\n        }\r\n        return front.concat(back);\r\n    }\r\n\r\n    /**\r\n     * Remove all polygons in this BSP tree that are inside the other BSP tree\r\n     * `bsp`.\r\n     * @param bsp BSP containing polygons to remove from this BSP\r\n     */\r\n    clipTo(bsp: Node): void {\r\n        this._polygons = bsp.clipPolygons(this._polygons);\r\n        if (this._front) {\r\n            this._front.clipTo(bsp);\r\n        }\r\n        if (this._back) {\r\n            this._back.clipTo(bsp);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return a list of all polygons in this BSP tree\r\n     * @returns List of all polygons in this BSP tree\r\n     */\r\n    allPolygons(): CSGPolygon[] {\r\n        let polygons = this._polygons.slice();\r\n        if (this._front) {\r\n            polygons = polygons.concat(this._front.allPolygons());\r\n        }\r\n        if (this._back) {\r\n            polygons = polygons.concat(this._back.allPolygons());\r\n        }\r\n        return polygons;\r\n    }\r\n\r\n    /**\r\n     * Build a BSP tree out of `polygons`. When called on an existing tree, the\r\n     * new polygons are filtered down to the bottom of the tree and become new\r\n     * nodes there. Each set of polygons is partitioned using the first polygon\r\n     * (no heuristic is used to pick a good split)\r\n     * @param polygons Polygons used to construct the BSP tree\r\n     */\r\n    build(polygons: CSGPolygon[]): void {\r\n        if (!polygons.length) {\r\n            return;\r\n        }\r\n        if (!this._plane) {\r\n            this._plane = polygons[0].plane.clone();\r\n        }\r\n        const front: CSGPolygon[] = [],\r\n            back = [] as CSGPolygon[];\r\n        for (let i = 0; i < polygons.length; i++) {\r\n            this._plane.splitPolygon(polygons[i], this._polygons, this._polygons, front, back);\r\n        }\r\n        if (front.length) {\r\n            if (!this._front) {\r\n                this._front = new Node();\r\n            }\r\n            this._front.build(front);\r\n        }\r\n        if (back.length) {\r\n            if (!this._back) {\r\n                this._back = new Node();\r\n            }\r\n            this._back.build(back);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Class for building Constructive Solid Geometry\r\n */\r\nexport class CSG {\r\n    private _polygons = new Array<CSGPolygon>();\r\n    /**\r\n     * The world matrix\r\n     */\r\n    public matrix: Matrix;\r\n    /**\r\n     * Stores the position\r\n     */\r\n    public position: Vector3;\r\n    /**\r\n     * Stores the rotation\r\n     */\r\n    public rotation: Vector3;\r\n    /**\r\n     * Stores the rotation quaternion\r\n     */\r\n    public rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * Stores the scaling vector\r\n     */\r\n    public scaling: Vector3;\r\n\r\n    /**\r\n     * Convert a VertexData to CSG\r\n     * @param mesh defines the VertexData to convert to CSG\r\n     * @returns the new CSG\r\n     */\r\n    public static FromVertexData(data: VertexData): CSG {\r\n        let vertex: Vertex, polygon: CSGPolygon, vertices: Vertex[];\r\n        const polygons: CSGPolygon[] = [];\r\n\r\n        const indices = data.indices;\r\n        const positions = data.positions;\r\n        const normals = data.normals;\r\n        const uvs = data.uvs;\r\n        const vertColors = data.colors;\r\n\r\n        if (!indices || !positions) {\r\n            throw \"BABYLON.CSG: VertexData must at least contain positions and indices\";\r\n        }\r\n\r\n        for (let i = 0; i < indices.length; i += 3) {\r\n            vertices = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                const indexIndices = i + j;\r\n                const offset = indices[indexIndices];\r\n\r\n                const normal = normals ? Vector3.FromArray(normals, offset * 3) : Vector3.Zero();\r\n                const uv = uvs ? Vector2.FromArray(uvs, offset * 2) : undefined;\r\n                const vertColor = vertColors ? Color4.FromArray(vertColors, offset * 4) : undefined;\r\n\r\n                const position = Vector3.FromArray(positions, offset * 3);\r\n\r\n                vertex = new Vertex(position, normal, uv, vertColor);\r\n                vertices.push(vertex);\r\n            }\r\n\r\n            polygon = new CSGPolygon(vertices, { subMeshId: 0, meshId: currentCSGMeshId, materialIndex: 0 });\r\n\r\n            // To handle the case of degenerated triangle\r\n            // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\r\n            if (polygon.plane) {\r\n                polygons.push(polygon);\r\n            }\r\n        }\r\n\r\n        const csg = CSG._FromPolygons(polygons);\r\n        csg.matrix = Matrix.Identity();\r\n        csg.position = Vector3.Zero();\r\n        csg.rotation = Vector3.Zero();\r\n        csg.scaling = Vector3.One();\r\n        csg.rotationQuaternion = Quaternion.Identity();\r\n        currentCSGMeshId++;\r\n\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Convert the Mesh to CSG\r\n     * @param mesh The Mesh to convert to CSG\r\n     * @param absolute If true, the final (local) matrix transformation is set to the identity and not to that of `mesh`. It can help when dealing with right-handed meshes (default: false)\r\n     * @returns A new CSG from the Mesh\r\n     */\r\n    public static FromMesh(mesh: Mesh, absolute = false): CSG {\r\n        let vertex: Vertex,\r\n            normal: Vector3,\r\n            uv: Vector2 | undefined = undefined,\r\n            position: Vector3,\r\n            vertColor: Color4 | undefined = undefined,\r\n            polygon: CSGPolygon,\r\n            vertices: Vertex[];\r\n        const polygons: CSGPolygon[] = [];\r\n        let matrix: Matrix,\r\n            meshPosition: Vector3,\r\n            meshRotation: Vector3,\r\n            meshRotationQuaternion: Nullable<Quaternion> = null,\r\n            meshScaling: Vector3;\r\n\r\n        let invertWinding = false;\r\n        if (mesh instanceof Mesh) {\r\n            mesh.computeWorldMatrix(true);\r\n            matrix = mesh.getWorldMatrix();\r\n            meshPosition = mesh.position.clone();\r\n            meshRotation = mesh.rotation.clone();\r\n            if (mesh.rotationQuaternion) {\r\n                meshRotationQuaternion = mesh.rotationQuaternion.clone();\r\n            }\r\n            meshScaling = mesh.scaling.clone();\r\n            if (mesh.material && absolute) {\r\n                invertWinding = mesh.material.sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation;\r\n            }\r\n        } else {\r\n            throw \"BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh\";\r\n        }\r\n\r\n        const indices = <IndicesArray>mesh.getIndices(),\r\n            positions = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind),\r\n            normals = <FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind),\r\n            uvs = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind),\r\n            vertColors = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n\r\n        const subMeshes = mesh.subMeshes;\r\n\r\n        for (let sm = 0, sml = subMeshes.length; sm < sml; sm++) {\r\n            for (let i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {\r\n                vertices = [];\r\n                for (let j = 0; j < 3; j++) {\r\n                    const indexIndices = j === 0 ? i + j : invertWinding ? i + 3 - j : i + j;\r\n                    const sourceNormal = new Vector3(normals[indices[indexIndices] * 3], normals[indices[indexIndices] * 3 + 1], normals[indices[indexIndices] * 3 + 2]);\r\n                    if (uvs) {\r\n                        uv = new Vector2(uvs[indices[indexIndices] * 2], uvs[indices[indexIndices] * 2 + 1]);\r\n                    }\r\n                    if (vertColors) {\r\n                        vertColor = new Color4(\r\n                            vertColors[indices[indexIndices] * 4],\r\n                            vertColors[indices[indexIndices] * 4 + 1],\r\n                            vertColors[indices[indexIndices] * 4 + 2],\r\n                            vertColors[indices[indexIndices] * 4 + 3]\r\n                        );\r\n                    }\r\n                    const sourcePosition = new Vector3(positions[indices[indexIndices] * 3], positions[indices[indexIndices] * 3 + 1], positions[indices[indexIndices] * 3 + 2]);\r\n                    position = Vector3.TransformCoordinates(sourcePosition, matrix);\r\n                    normal = Vector3.TransformNormal(sourceNormal, matrix);\r\n\r\n                    vertex = new Vertex(position, normal, uv, vertColor);\r\n                    vertices.push(vertex);\r\n                }\r\n\r\n                polygon = new CSGPolygon(vertices, { subMeshId: sm, meshId: currentCSGMeshId, materialIndex: subMeshes[sm].materialIndex });\r\n\r\n                // To handle the case of degenerated triangle\r\n                // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\r\n                if (polygon.plane) {\r\n                    polygons.push(polygon);\r\n                }\r\n            }\r\n        }\r\n\r\n        const csg = CSG._FromPolygons(polygons);\r\n        csg.matrix = absolute ? Matrix.Identity() : matrix;\r\n        csg.position = absolute ? Vector3.Zero() : meshPosition;\r\n        csg.rotation = absolute ? Vector3.Zero() : meshRotation;\r\n        csg.scaling = absolute ? Vector3.One() : meshScaling;\r\n        csg.rotationQuaternion = absolute && meshRotationQuaternion ? Quaternion.Identity() : meshRotationQuaternion;\r\n        currentCSGMeshId++;\r\n\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Construct a CSG solid from a list of `CSG.Polygon` instances.\r\n     * @param polygons Polygons used to construct a CSG solid\r\n     */\r\n    private static _FromPolygons(polygons: CSGPolygon[]): CSG {\r\n        const csg = new CSG();\r\n        csg._polygons = polygons;\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, of the CSG\r\n     * @returns A new CSG\r\n     */\r\n    public clone(): CSG {\r\n        const csg = new CSG();\r\n        csg._polygons = this._polygons.map((p) => p.clone());\r\n        csg.copyTransformAttributes(this);\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Unions this CSG with another CSG\r\n     * @param csg The CSG to union against this CSG\r\n     * @returns The unioned CSG\r\n     */\r\n    public union(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Unions this CSG with another CSG in place\r\n     * @param csg The CSG to union against this CSG\r\n     */\r\n    public unionInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Subtracts this CSG with another CSG\r\n     * @param csg The CSG to subtract against this CSG\r\n     * @returns A new CSG\r\n     */\r\n    public subtract(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Subtracts this CSG with another CSG in place\r\n     * @param csg The CSG to subtract against this CSG\r\n     */\r\n    public subtractInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Intersect this CSG with another CSG\r\n     * @param csg The CSG to intersect against this CSG\r\n     * @returns A new CSG\r\n     */\r\n    public intersect(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Intersects this CSG with another CSG in place\r\n     * @param csg The CSG to intersect against this CSG\r\n     */\r\n    public intersectInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Return a new CSG solid with solid and empty space switched. This solid is\r\n     * not modified.\r\n     * @returns A new CSG solid with solid and empty space switched\r\n     */\r\n    public inverse(): CSG {\r\n        const csg = this.clone();\r\n        csg.inverseInPlace();\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Inverses the CSG in place\r\n     */\r\n    public inverseInPlace(): void {\r\n        this._polygons.map((p) => {\r\n            p.flip();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * This is used to keep meshes transformations so they can be restored\r\n     * when we build back a Babylon Mesh\r\n     * NB : All CSG operations are performed in world coordinates\r\n     * @param csg The CSG to copy the transform attributes from\r\n     * @returns This CSG\r\n     */\r\n    public copyTransformAttributes(csg: CSG): CSG {\r\n        this.matrix = csg.matrix;\r\n        this.position = csg.position;\r\n        this.rotation = csg.rotation;\r\n        this.scaling = csg.scaling;\r\n        this.rotationQuaternion = csg.rotationQuaternion;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Build vertex data from CSG\r\n     * Coordinates here are in world space\r\n     * @returns the final vertex data\r\n     */\r\n    public toVertexData(onBeforePolygonProcessing: Nullable<(polygon: CSGPolygon) => void> = null, onAfterPolygonProcessing: Nullable<() => void> = null): VertexData {\r\n        const matrix = this.matrix.clone();\r\n        matrix.invert();\r\n\r\n        const polygons = this._polygons;\r\n        const vertices = [];\r\n        const indices = [];\r\n        const normals = [];\r\n        let uvs: Nullable<number[]> = null;\r\n        let vertColors: Nullable<number[]> = null;\r\n        const vertex = Vector3.Zero();\r\n        const normal = Vector3.Zero();\r\n        const uv = Vector2.Zero();\r\n        const vertColor = new Color4(0, 0, 0, 0);\r\n        const polygonIndices = [0, 0, 0];\r\n        const vertice_dict = {};\r\n        let vertex_idx;\r\n\r\n        for (let i = 0, il = polygons.length; i < il; i++) {\r\n            const polygon = polygons[i];\r\n\r\n            if (onBeforePolygonProcessing) {\r\n                onBeforePolygonProcessing(polygon);\r\n            }\r\n\r\n            for (let j = 2, jl = polygon.vertices.length; j < jl; j++) {\r\n                polygonIndices[0] = 0;\r\n                polygonIndices[1] = j - 1;\r\n                polygonIndices[2] = j;\r\n\r\n                for (let k = 0; k < 3; k++) {\r\n                    vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);\r\n                    normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);\r\n                    if (polygon.vertices[polygonIndices[k]].uv) {\r\n                        if (!uvs) {\r\n                            uvs = [];\r\n                        }\r\n                        uv.copyFrom(polygon.vertices[polygonIndices[k]].uv!);\r\n                    }\r\n\r\n                    if (polygon.vertices[polygonIndices[k]].vertColor) {\r\n                        if (!vertColors) {\r\n                            vertColors = [];\r\n                        }\r\n                        vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor!);\r\n                    }\r\n                    const localVertex = Vector3.TransformCoordinates(vertex, matrix);\r\n                    const localNormal = Vector3.TransformNormal(normal, matrix);\r\n\r\n                    vertex_idx = (<any>vertice_dict)[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z];\r\n\r\n                    let areUvsDifferent = false;\r\n\r\n                    if (uvs && !(uvs[vertex_idx * 2] === uv.x || uvs[vertex_idx * 2 + 1] === uv.y)) {\r\n                        areUvsDifferent = true;\r\n                    }\r\n\r\n                    let areColorsDifferent = false;\r\n\r\n                    if (\r\n                        vertColors &&\r\n                        !(\r\n                            vertColors[vertex_idx * 4] === vertColor.r ||\r\n                            vertColors[vertex_idx * 4 + 1] === vertColor.g ||\r\n                            vertColors[vertex_idx * 4 + 2] === vertColor.b ||\r\n                            vertColors[vertex_idx * 4 + 3] === vertColor.a\r\n                        )\r\n                    ) {\r\n                        areColorsDifferent = true;\r\n                    }\r\n\r\n                    // Check if 2 points can be merged\r\n                    if (\r\n                        !(\r\n                            typeof vertex_idx !== \"undefined\" &&\r\n                            normals[vertex_idx * 3] === localNormal.x &&\r\n                            normals[vertex_idx * 3 + 1] === localNormal.y &&\r\n                            normals[vertex_idx * 3 + 2] === localNormal.z\r\n                        ) ||\r\n                        areUvsDifferent ||\r\n                        areColorsDifferent\r\n                    ) {\r\n                        vertices.push(localVertex.x, localVertex.y, localVertex.z);\r\n                        if (uvs) {\r\n                            uvs.push(uv.x, uv.y);\r\n                        }\r\n                        normals.push(normal.x, normal.y, normal.z);\r\n                        if (vertColors) {\r\n                            vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);\r\n                        }\r\n                        vertex_idx = (<any>vertice_dict)[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z] = vertices.length / 3 - 1;\r\n                    }\r\n\r\n                    indices.push(vertex_idx);\r\n\r\n                    if (onAfterPolygonProcessing) {\r\n                        onAfterPolygonProcessing();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const result = new VertexData();\r\n        result.positions = vertices;\r\n        result.normals = normals;\r\n        if (uvs) {\r\n            result.uvs = uvs;\r\n        }\r\n        if (vertColors) {\r\n            result.colors = vertColors;\r\n        }\r\n        result.indices = indices;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Build Raw mesh from CSG\r\n     * Coordinates here are in world space\r\n     * @param name The name of the mesh geometry\r\n     * @param scene The Scene\r\n     * @param keepSubMeshes Specifies if the submeshes should be kept\r\n     * @returns A new Mesh\r\n     */\r\n    public buildMeshGeometry(name: string, scene?: Scene, keepSubMeshes?: boolean): Mesh {\r\n        const mesh = new Mesh(name, scene);\r\n        const polygons = this._polygons;\r\n        let currentIndex = 0;\r\n        const subMeshDict = {};\r\n        let subMeshObj: {\r\n            materialIndex: number;\r\n            indexStart: number;\r\n            indexEnd: number;\r\n        };\r\n\r\n        if (keepSubMeshes) {\r\n            // Sort Polygons, since subMeshes are indices range\r\n            polygons.sort((a, b) => {\r\n                if (a.shared.meshId === b.shared.meshId) {\r\n                    return a.shared.subMeshId - b.shared.subMeshId;\r\n                } else {\r\n                    return a.shared.meshId - b.shared.meshId;\r\n                }\r\n            });\r\n        }\r\n\r\n        const vertexData = this.toVertexData(\r\n            (polygon) => {\r\n                // Building SubMeshes\r\n                if (!(<any>subMeshDict)[polygon.shared.meshId]) {\r\n                    (<any>subMeshDict)[polygon.shared.meshId] = {};\r\n                }\r\n                if (!(<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId]) {\r\n                    (<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId] = {\r\n                        indexStart: +Infinity,\r\n                        indexEnd: -Infinity,\r\n                        materialIndex: polygon.shared.materialIndex,\r\n                    };\r\n                }\r\n                subMeshObj = (<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId];\r\n            },\r\n            () => {\r\n                subMeshObj.indexStart = Math.min(currentIndex, subMeshObj.indexStart);\r\n                subMeshObj.indexEnd = Math.max(currentIndex, subMeshObj.indexEnd);\r\n                currentIndex++;\r\n            }\r\n        );\r\n\r\n        vertexData.applyToMesh(mesh);\r\n\r\n        if (keepSubMeshes) {\r\n            // We offset the materialIndex by the previous number of materials in the CSG mixed meshes\r\n            let materialIndexOffset = 0,\r\n                materialMaxIndex;\r\n\r\n            mesh.subMeshes = [] as SubMesh[];\r\n\r\n            for (const m in subMeshDict) {\r\n                materialMaxIndex = -1;\r\n                for (const sm in (<any>subMeshDict)[m]) {\r\n                    subMeshObj = (<any>subMeshDict)[m][sm];\r\n                    SubMesh.CreateFromIndices(\r\n                        subMeshObj.materialIndex + materialIndexOffset,\r\n                        subMeshObj.indexStart,\r\n                        subMeshObj.indexEnd - subMeshObj.indexStart + 1,\r\n                        <AbstractMesh>mesh\r\n                    );\r\n                    materialMaxIndex = Math.max(subMeshObj.materialIndex, materialMaxIndex);\r\n                }\r\n                materialIndexOffset += ++materialMaxIndex;\r\n            }\r\n        }\r\n\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Build Mesh from CSG taking material and transforms into account\r\n     * @param name The name of the Mesh\r\n     * @param material The material of the Mesh\r\n     * @param scene The Scene\r\n     * @param keepSubMeshes Specifies if submeshes should be kept\r\n     * @returns The new Mesh\r\n     */\r\n    public toMesh(name: string, material: Nullable<Material> = null, scene?: Scene, keepSubMeshes?: boolean): Mesh {\r\n        const mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);\r\n\r\n        mesh.material = material;\r\n\r\n        mesh.position.copyFrom(this.position);\r\n        mesh.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            mesh.rotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n        mesh.scaling.copyFrom(this.scaling);\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        return mesh;\r\n    }\r\n}\r\n"]}