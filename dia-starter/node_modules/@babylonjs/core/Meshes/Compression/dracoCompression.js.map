{"version":3,"file":"dracoCompression.js","sourceRoot":"","sources":["../../../../../dev/core/src/Meshes/Compression/dracoCompression.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { AutoReleaseWorkerPool } from \"../../Misc/workerPool\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IDisposable, Scene } from \"../../scene\";\r\nimport { Geometry } from \"../geometry\";\r\nimport { VertexBuffer } from \"../buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { DracoDecoderModule } from \"draco3dgltf\";\r\nimport type { DecoderModule, DecoderBuffer, Decoder, Mesh, PointCloud, Status } from \"draco3dgltf\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\ndeclare let DracoDecoderModule: DracoDecoderModule;\r\n\r\ninterface AttributeData {\r\n    kind: string;\r\n    data: ArrayBufferView;\r\n    size: number;\r\n    byteOffset: number;\r\n    byteStride: number;\r\n    normalized: boolean;\r\n}\r\n\r\ninterface MeshData {\r\n    indices?: Uint16Array | Uint32Array;\r\n    attributes: Array<AttributeData>;\r\n    totalVertices: number;\r\n}\r\n\r\ninterface InitDoneMessage {\r\n    id: \"initDone\";\r\n}\r\n\r\ninterface DecodeMeshDoneMessage {\r\n    id: \"decodeMeshDone\";\r\n    totalVertices: number;\r\n}\r\n\r\ninterface IndicesMessage {\r\n    id: \"indices\";\r\n    data: Uint16Array | Uint32Array;\r\n}\r\n\r\ninterface AttributeMessage extends AttributeData {\r\n    id: \"attribute\";\r\n}\r\n\r\ntype Message = InitDoneMessage | DecodeMeshDoneMessage | IndicesMessage | AttributeMessage;\r\n\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: Message, transfer?: any[]): void;\r\n\r\nfunction createDecoderAsync(wasmBinary?: ArrayBuffer): Promise<{ module: DecoderModule }> {\r\n    return new Promise((resolve) => {\r\n        DracoDecoderModule({ wasmBinary: wasmBinary }).then((module) => {\r\n            resolve({ module: module });\r\n        });\r\n    });\r\n}\r\n\r\nfunction decodeMesh(\r\n    decoderModule: DecoderModule,\r\n    data: Int8Array,\r\n    attributes: { [kind: string]: number } | undefined,\r\n    onIndicesData: (indices: Uint16Array | Uint32Array) => void,\r\n    onAttributeData: (kind: string, data: ArrayBufferView, size: number, offset: number, stride: number, normalized: boolean) => void\r\n): number {\r\n    let decoder: Nullable<Decoder> = null;\r\n    let buffer: Nullable<DecoderBuffer> = null;\r\n    let geometry: Nullable<Mesh | PointCloud> = null;\r\n\r\n    try {\r\n        decoder = new decoderModule.Decoder();\r\n\r\n        buffer = new decoderModule.DecoderBuffer();\r\n        buffer.Init(data, data.byteLength);\r\n\r\n        let status: Status;\r\n        const type = decoder.GetEncodedGeometryType(buffer);\r\n        switch (type) {\r\n            case decoderModule.TRIANGULAR_MESH: {\r\n                const mesh = new decoderModule.Mesh();\r\n                status = decoder.DecodeBufferToMesh(buffer, mesh);\r\n                if (!status.ok() || mesh.ptr === 0) {\r\n                    throw new Error(status.error_msg());\r\n                }\r\n\r\n                const numFaces = mesh.num_faces();\r\n                const numIndices = numFaces * 3;\r\n                const byteLength = numIndices * 4;\r\n\r\n                const ptr = decoderModule._malloc(byteLength);\r\n                try {\r\n                    decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\r\n                    const indices = new Uint32Array(numIndices);\r\n                    indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\r\n                    onIndicesData(indices);\r\n                } finally {\r\n                    decoderModule._free(ptr);\r\n                }\r\n\r\n                geometry = mesh;\r\n                break;\r\n            }\r\n            case decoderModule.POINT_CLOUD: {\r\n                const pointCloud = new decoderModule.PointCloud();\r\n                status = decoder.DecodeBufferToPointCloud(buffer, pointCloud);\r\n                if (!status.ok() || !pointCloud.ptr) {\r\n                    throw new Error(status.error_msg());\r\n                }\r\n\r\n                geometry = pointCloud;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid geometry type ${type}`);\r\n            }\r\n        }\r\n\r\n        const numPoints = geometry.num_points();\r\n\r\n        const processAttribute = (decoder: Decoder, geometry: Mesh | PointCloud, kind: string, attribute: any) => {\r\n            const dataType = attribute.data_type();\r\n            const numComponents = attribute.num_components();\r\n            const normalized = attribute.normalized();\r\n            const byteStride = attribute.byte_stride();\r\n            const byteOffset = attribute.byte_offset();\r\n\r\n            const dataTypeInfo = {\r\n                [decoderModule.DT_FLOAT32]: { typedArrayConstructor: Float32Array, heap: decoderModule.HEAPF32 },\r\n                [decoderModule.DT_INT8]: { typedArrayConstructor: Int8Array, heap: decoderModule.HEAP8 },\r\n                [decoderModule.DT_INT16]: { typedArrayConstructor: Int16Array, heap: decoderModule.HEAP16 },\r\n                [decoderModule.DT_INT32]: { typedArrayConstructor: Int32Array, heap: decoderModule.HEAP32 },\r\n                [decoderModule.DT_UINT8]: { typedArrayConstructor: Uint8Array, heap: decoderModule.HEAPU8 },\r\n                [decoderModule.DT_UINT16]: { typedArrayConstructor: Uint16Array, heap: decoderModule.HEAPU16 },\r\n                [decoderModule.DT_UINT32]: { typedArrayConstructor: Uint32Array, heap: decoderModule.HEAPU32 },\r\n            };\r\n\r\n            const info = dataTypeInfo[dataType];\r\n            if (!info) {\r\n                throw new Error(`Invalid data type ${dataType}`);\r\n            }\r\n\r\n            const numValues = numPoints * numComponents;\r\n            const byteLength = numValues * info.typedArrayConstructor.BYTES_PER_ELEMENT;\r\n\r\n            const ptr = decoderModule._malloc(byteLength);\r\n            try {\r\n                decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, dataType, byteLength, ptr);\r\n                const data = new info.typedArrayConstructor(info.heap.buffer, ptr, numValues);\r\n                onAttributeData(kind, data.slice(), numComponents, byteOffset, byteStride, normalized);\r\n            } finally {\r\n                decoderModule._free(ptr);\r\n            }\r\n        };\r\n\r\n        if (attributes) {\r\n            for (const kind in attributes) {\r\n                const id = attributes[kind];\r\n                const attribute = decoder.GetAttributeByUniqueId(geometry, id);\r\n                processAttribute(decoder, geometry, kind, attribute);\r\n            }\r\n        } else {\r\n            const dracoAttributeTypes: { [kind: string]: number } = {\r\n                position: decoderModule.POSITION,\r\n                normal: decoderModule.NORMAL,\r\n                color: decoderModule.COLOR,\r\n                uv: decoderModule.TEX_COORD,\r\n            };\r\n\r\n            for (const kind in dracoAttributeTypes) {\r\n                const id = decoder.GetAttributeId(geometry, dracoAttributeTypes[kind]);\r\n                if (id !== -1) {\r\n                    const attribute = decoder.GetAttribute(geometry, id);\r\n                    processAttribute(decoder, geometry, kind, attribute);\r\n                }\r\n            }\r\n        }\r\n\r\n        return numPoints;\r\n    } finally {\r\n        if (geometry) {\r\n            decoderModule.destroy(geometry);\r\n        }\r\n\r\n        if (buffer) {\r\n            decoderModule.destroy(buffer);\r\n        }\r\n\r\n        if (decoder) {\r\n            decoderModule.destroy(decoder);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n */\r\nfunction worker(): void {\r\n    let decoderPromise: PromiseLike<any> | undefined;\r\n\r\n    onmessage = (event) => {\r\n        const message = event.data;\r\n        switch (message.id) {\r\n            case \"init\": {\r\n                const decoder = message.decoder;\r\n                if (decoder.url) {\r\n                    importScripts(decoder.url);\r\n                    decoderPromise = DracoDecoderModule({ wasmBinary: decoder.wasmBinary });\r\n                }\r\n                postMessage({ id: \"initDone\" });\r\n                break;\r\n            }\r\n            case \"decodeMesh\": {\r\n                if (!decoderPromise) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n                decoderPromise.then((decoder) => {\r\n                    const numPoints = decodeMesh(\r\n                        decoder,\r\n                        message.dataView,\r\n                        message.attributes,\r\n                        (indices) => {\r\n                            postMessage({ id: \"indices\", data: indices }, [indices.buffer]);\r\n                        },\r\n                        (kind, data, size, offset, stride, normalized) => {\r\n                            postMessage({ id: \"attribute\", kind, data, size, byteOffset: offset, byteStride: stride, normalized }, [data.buffer]);\r\n                        }\r\n                    );\r\n                    postMessage({ id: \"decodeMeshDone\", totalVertices: numPoints });\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Configuration for Draco compression\r\n */\r\nexport interface IDracoCompressionConfiguration {\r\n    /**\r\n     * Configuration for the decoder.\r\n     */\r\n    decoder: {\r\n        /**\r\n         * The url to the WebAssembly module.\r\n         */\r\n        wasmUrl?: string;\r\n\r\n        /**\r\n         * The url to the WebAssembly binary.\r\n         */\r\n        wasmBinaryUrl?: string;\r\n\r\n        /**\r\n         * The url to the fallback JavaScript module.\r\n         */\r\n        fallbackUrl?: string;\r\n    };\r\n}\r\n\r\n/**\r\n * Draco compression (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco module.\r\n *\r\n * **Encoder**\r\n *\r\n * The encoder is not currently implemented.\r\n *\r\n * **Decoder**\r\n *\r\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoCompression.Configuration = {\r\n *         decoder: {\r\n *             wasmUrl: \"<url to the WebAssembly library>\",\r\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *         }\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\r\n *\r\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshToGeometryAsync:\r\n * ```javascript\r\n *     var geometry = await DracoCompression.Default.decodeMeshToGeometryAsync(data);\r\n * ```\r\n *\r\n * @see https://playground.babylonjs.com/#DMZIBD#0\r\n */\r\nexport class DracoCompression implements IDisposable {\r\n    private _workerPoolPromise?: Promise<AutoReleaseWorkerPool>;\r\n    private _decoderModulePromise?: Promise<{ module: DecoderModule }>;\r\n\r\n    /**\r\n     * The configuration. Defaults to the following urls:\r\n     * - wasmUrl: \"https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js\"\r\n     * - wasmBinaryUrl: \"https://cdn.babylonjs.com/draco_decoder_gltf.wasm\"\r\n     * - fallbackUrl: \"https://cdn.babylonjs.com/draco_decoder_gltf.js\"\r\n     */\r\n    public static Configuration: IDracoCompressionConfiguration = {\r\n        decoder: {\r\n            wasmUrl: `${Tools._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,\r\n            wasmBinaryUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.wasm`,\r\n            fallbackUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.js`,\r\n        },\r\n    };\r\n\r\n    /**\r\n     * Returns true if the decoder configuration is available.\r\n     */\r\n    public static get DecoderAvailable(): boolean {\r\n        const decoder = DracoCompression.Configuration.decoder;\r\n        return !!((decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\") || decoder.fallbackUrl);\r\n    }\r\n\r\n    /**\r\n     * Default number of workers to create when creating the draco compression object.\r\n     */\r\n    public static DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\r\n\r\n    private static GetDefaultNumWorkers(): number {\r\n        if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\r\n            return 1;\r\n        }\r\n\r\n        // Use 50% of the available logical processors but capped at 4.\r\n        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\r\n    }\r\n\r\n    private static _Default: Nullable<DracoCompression> = null;\r\n\r\n    /**\r\n     * Default instance for the draco compression object.\r\n     */\r\n    public static get Default(): DracoCompression {\r\n        if (!DracoCompression._Default) {\r\n            DracoCompression._Default = new DracoCompression();\r\n        }\r\n\r\n        return DracoCompression._Default;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    constructor(numWorkers = DracoCompression.DefaultNumWorkers) {\r\n        const decoder = DracoCompression.Configuration.decoder;\r\n\r\n        const decoderInfo: { url: string | undefined; wasmBinaryPromise: Promise<ArrayBuffer | undefined> } =\r\n            decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\"\r\n                ? {\r\n                      url: Tools.GetBabylonScriptURL(decoder.wasmUrl, true),\r\n                      wasmBinaryPromise: Tools.LoadFileAsync(Tools.GetBabylonScriptURL(decoder.wasmBinaryUrl, true)),\r\n                  }\r\n                : {\r\n                      url: Tools.GetBabylonScriptURL(decoder.fallbackUrl!),\r\n                      wasmBinaryPromise: Promise.resolve(undefined),\r\n                  };\r\n\r\n        if (numWorkers && typeof Worker === \"function\" && typeof URL === \"function\") {\r\n            this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {\r\n                const workerContent = `${decodeMesh}(${worker})()`;\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n\r\n                return new AutoReleaseWorkerPool(numWorkers, () => {\r\n                    return new Promise((resolve, reject) => {\r\n                        const worker = new Worker(workerBlobUrl);\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                        };\r\n\r\n                        const onMessage = (event: MessageEvent<Message>) => {\r\n                            if (event.data.id === \"initDone\") {\r\n                                worker.removeEventListener(\"error\", onError);\r\n                                worker.removeEventListener(\"message\", onMessage);\r\n                                resolve(worker);\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        worker.postMessage({\r\n                            id: \"init\",\r\n                            decoder: {\r\n                                url: decoderInfo.url,\r\n                                wasmBinary: decoderWasmBinary,\r\n                            },\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        } else {\r\n            this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {\r\n                if (!decoderInfo.url) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n\r\n                return Tools.LoadBabylonScriptAsync(decoderInfo.url).then(() => {\r\n                    return createDecoderAsync(decoderWasmBinary as ArrayBuffer);\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop all async operations and release resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._workerPoolPromise) {\r\n            this._workerPoolPromise.then((workerPool) => {\r\n                workerPool.dispose();\r\n            });\r\n        }\r\n\r\n        delete this._workerPoolPromise;\r\n        delete this._decoderModulePromise;\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\r\n     * @returns a promise that resolves when ready\r\n     */\r\n    public whenReadyAsync(): Promise<void> {\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then(() => {});\r\n        }\r\n\r\n        if (this._decoderModulePromise) {\r\n            return this._decoderModulePromise.then(() => {});\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _decodeMeshAsync(\r\n        data: ArrayBuffer | ArrayBufferView,\r\n        attributes?: { [kind: string]: number },\r\n        gltfNormalizedOverride?: { [kind: string]: boolean }\r\n    ): Promise<MeshData> {\r\n        const dataView = data instanceof ArrayBuffer ? new Int8Array(data) : new Int8Array(data.buffer, data.byteOffset, data.byteLength);\r\n\r\n        const applyGltfNormalizedOverride = (kind: string, normalized: boolean): boolean => {\r\n            if (gltfNormalizedOverride && gltfNormalizedOverride[kind] !== undefined) {\r\n                if (normalized !== gltfNormalizedOverride[kind]) {\r\n                    Logger.Warn(\r\n                        `Normalized flag from Draco data (${normalized}) does not match normalized flag from glTF accessor (${gltfNormalizedOverride[kind]}). Using flag from glTF accessor.`\r\n                    );\r\n                }\r\n\r\n                return gltfNormalizedOverride[kind];\r\n            } else {\r\n                return normalized;\r\n            }\r\n        };\r\n\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then((workerPool) => {\r\n                return new Promise<MeshData>((resolve, reject) => {\r\n                    workerPool.push((worker, onComplete) => {\r\n                        let resultIndices: Nullable<Uint16Array | Uint32Array> = null;\r\n                        const resultAttributes: Array<AttributeData> = [];\r\n\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                            onComplete();\r\n                        };\r\n\r\n                        const onMessage = (event: MessageEvent<Message>) => {\r\n                            const message = event.data;\r\n                            switch (message.id) {\r\n                                case \"decodeMeshDone\": {\r\n                                    worker.removeEventListener(\"error\", onError);\r\n                                    worker.removeEventListener(\"message\", onMessage);\r\n                                    resolve({ indices: resultIndices!, attributes: resultAttributes, totalVertices: message.totalVertices });\r\n                                    onComplete();\r\n                                    break;\r\n                                }\r\n                                case \"indices\": {\r\n                                    resultIndices = message.data;\r\n                                    break;\r\n                                }\r\n                                case \"attribute\": {\r\n                                    resultAttributes.push({\r\n                                        kind: message.kind,\r\n                                        data: message.data,\r\n                                        size: message.size,\r\n                                        byteOffset: message.byteOffset,\r\n                                        byteStride: message.byteStride,\r\n                                        normalized: applyGltfNormalizedOverride(message.kind, message.normalized),\r\n                                    });\r\n                                    break;\r\n                                }\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        const dataViewCopy = dataView.slice();\r\n                        worker.postMessage({ id: \"decodeMesh\", dataView: dataViewCopy, attributes: attributes }, [dataViewCopy.buffer]);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        if (this._decoderModulePromise) {\r\n            return this._decoderModulePromise.then((decoder) => {\r\n                let resultIndices: Nullable<Uint16Array | Uint32Array> = null;\r\n                const resultAttributes: Array<AttributeData> = [];\r\n\r\n                const numPoints = decodeMesh(\r\n                    decoder.module,\r\n                    dataView,\r\n                    attributes,\r\n                    (indices) => {\r\n                        resultIndices = indices;\r\n                    },\r\n                    (kind, data, size, byteOffset, byteStride, normalized) => {\r\n                        resultAttributes.push({\r\n                            kind,\r\n                            data,\r\n                            size,\r\n                            byteOffset,\r\n                            byteStride,\r\n                            normalized,\r\n                        });\r\n                    }\r\n                );\r\n\r\n                return { indices: resultIndices!, attributes: resultAttributes, totalVertices: numPoints };\r\n            });\r\n        }\r\n\r\n        throw new Error(\"Draco decoder module is not available\");\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to Babylon geometry.\r\n     * @param name The name to use when creating the geometry\r\n     * @param scene The scene to use when creating the geometry\r\n     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @returns A promise that resolves with the decoded geometry\r\n     */\r\n    public decodeMeshToGeometryAsync(name: string, scene: Scene, data: ArrayBuffer | ArrayBufferView, attributes?: { [kind: string]: number }): Promise<Geometry> {\r\n        return this._decodeMeshAsync(data, attributes).then((meshData) => {\r\n            const geometry = new Geometry(name, scene);\r\n\r\n            if (meshData.indices) {\r\n                geometry.setIndices(meshData.indices);\r\n            }\r\n\r\n            for (const attribute of meshData.attributes) {\r\n                geometry.setVerticesBuffer(\r\n                    new VertexBuffer(\r\n                        scene.getEngine(),\r\n                        attribute.data,\r\n                        attribute.kind,\r\n                        false,\r\n                        undefined,\r\n                        attribute.byteStride,\r\n                        undefined,\r\n                        attribute.byteOffset,\r\n                        attribute.size,\r\n                        undefined,\r\n                        attribute.normalized,\r\n                        true\r\n                    ),\r\n                    meshData.totalVertices\r\n                );\r\n            }\r\n\r\n            return geometry;\r\n        });\r\n    }\r\n\r\n    /** @internal */\r\n    public _decodeMeshToGeometryForGltfAsync(\r\n        name: string,\r\n        scene: Scene,\r\n        data: ArrayBuffer | ArrayBufferView,\r\n        attributes: { [kind: string]: number },\r\n        gltfNormalizedOverride: { [kind: string]: boolean }\r\n    ): Promise<Geometry> {\r\n        return this._decodeMeshAsync(data, attributes, gltfNormalizedOverride).then((meshData) => {\r\n            const geometry = new Geometry(name, scene);\r\n\r\n            if (meshData.indices) {\r\n                geometry.setIndices(meshData.indices);\r\n            }\r\n\r\n            for (const attribute of meshData.attributes) {\r\n                geometry.setVerticesBuffer(\r\n                    new VertexBuffer(\r\n                        scene.getEngine(),\r\n                        attribute.data,\r\n                        attribute.kind,\r\n                        false,\r\n                        undefined,\r\n                        attribute.byteStride,\r\n                        undefined,\r\n                        attribute.byteOffset,\r\n                        attribute.size,\r\n                        undefined,\r\n                        attribute.normalized,\r\n                        true\r\n                    ),\r\n                    meshData.totalVertices\r\n                );\r\n            }\r\n\r\n            return geometry;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to Babylon vertex data.\r\n     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @returns A promise that resolves with the decoded vertex data\r\n     * @deprecated Use {@link decodeMeshToGeometryAsync} for better performance in some cases\r\n     */\r\n    public decodeMeshAsync(data: ArrayBuffer | ArrayBufferView, attributes?: { [kind: string]: number }): Promise<VertexData> {\r\n        return this._decodeMeshAsync(data, attributes).then((meshData) => {\r\n            const vertexData = new VertexData();\r\n\r\n            if (meshData.indices) {\r\n                vertexData.indices = meshData.indices;\r\n            }\r\n\r\n            for (const attribute of meshData.attributes) {\r\n                const floatData = VertexBuffer.GetFloatData(\r\n                    attribute.data,\r\n                    attribute.size,\r\n                    VertexBuffer.GetDataType(attribute.data),\r\n                    attribute.byteOffset,\r\n                    attribute.byteStride,\r\n                    attribute.normalized,\r\n                    meshData.totalVertices\r\n                );\r\n\r\n                vertexData.set(floatData, attribute.kind);\r\n            }\r\n\r\n            return vertexData;\r\n        });\r\n    }\r\n}\r\n"]}