{"version":3,"file":"directionalLight.js","sourceRoot":"","sources":["../../../../dev/core/src/Lights/directionalLight.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize } from \"../Misc/decorators\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Light } from \"./light\";\r\nimport { ShadowLight } from \"./shadowLight\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nNode.AddNodeConstructor(\"Light_Type_1\", (name, scene) => {\r\n    return () => new DirectionalLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * A directional light is defined by a direction (what a surprise!).\r\n * The light is emitted from everywhere in the specified direction, and has an infinite range.\r\n * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.\r\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n */\r\nexport class DirectionalLight extends ShadowLight {\r\n    private _shadowFrustumSize = 0;\r\n    /**\r\n     * Fix frustum size for the shadow generation. This is disabled if the value is 0.\r\n     */\r\n    @serialize()\r\n    public get shadowFrustumSize(): number {\r\n        return this._shadowFrustumSize;\r\n    }\r\n    /**\r\n     * Specifies a fix frustum size for the shadow generation.\r\n     */\r\n    public set shadowFrustumSize(value: number) {\r\n        this._shadowFrustumSize = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    private _shadowOrthoScale = 0.1;\r\n    /**\r\n     * Gets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\r\n    @serialize()\r\n    public get shadowOrthoScale(): number {\r\n        return this._shadowOrthoScale;\r\n    }\r\n    /**\r\n     * Sets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\r\n    public set shadowOrthoScale(value: number) {\r\n        this._shadowOrthoScale = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * Automatically compute the projection matrix to best fit (including all the casters)\r\n     * on each frame.\r\n     */\r\n    @serialize()\r\n    public autoUpdateExtends = true;\r\n\r\n    /**\r\n     * Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)\r\n     * on each frame. autoUpdateExtends must be set to true for this to work\r\n     */\r\n    @serialize()\r\n    public autoCalcShadowZBounds = false;\r\n\r\n    // Cache\r\n    @serialize(\"orthoLeft\")\r\n    private _orthoLeft = Number.MAX_VALUE;\r\n    @serialize(\"orthoRight\")\r\n    private _orthoRight = Number.MIN_VALUE;\r\n    @serialize(\"orthoTop\")\r\n    private _orthoTop = Number.MIN_VALUE;\r\n    @serialize(\"orthoBottom\")\r\n    private _orthoBottom = Number.MAX_VALUE;\r\n\r\n    /**\r\n     * Gets or sets the orthoLeft property used to build the light frustum\r\n     */\r\n    public get orthoLeft(): number {\r\n        return this._orthoLeft;\r\n    }\r\n\r\n    public set orthoLeft(left: number) {\r\n        this._orthoLeft = left;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoRight property used to build the light frustum\r\n     */\r\n    public get orthoRight(): number {\r\n        return this._orthoRight;\r\n    }\r\n\r\n    public set orthoRight(right: number) {\r\n        this._orthoRight = right;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoTop property used to build the light frustum\r\n     */\r\n    public get orthoTop(): number {\r\n        return this._orthoTop;\r\n    }\r\n\r\n    public set orthoTop(top: number) {\r\n        this._orthoTop = top;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoBottom property used to build the light frustum\r\n     */\r\n    public get orthoBottom(): number {\r\n        return this._orthoBottom;\r\n    }\r\n\r\n    public set orthoBottom(bottom: number) {\r\n        this._orthoBottom = bottom;\r\n    }\r\n\r\n    /**\r\n     * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).\r\n     * The directional light is emitted from everywhere in the given direction.\r\n     * It can cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene?: Scene) {\r\n        super(name, scene);\r\n        this.position = direction.scale(-1.0);\r\n        this.direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"DirectionalLight\".\r\n     * @returns The class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"DirectionalLight\";\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 1.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_DIRECTIONALLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        if (this.shadowFrustumSize > 0) {\r\n            this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);\r\n        } else {\r\n            this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     */\r\n    protected _setDefaultFixedFrustumShadowProjectionMatrix(matrix: Matrix): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        Matrix.OrthoLHToRef(\r\n            this.shadowFrustumSize,\r\n            this.shadowFrustumSize,\r\n            this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ,\r\n            this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ,\r\n            matrix,\r\n            this.getScene().getEngine().isNDCHalfZRange\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    protected _setDefaultAutoExtendShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        // Check extends\r\n        if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\r\n            const tempVector3 = Vector3.Zero();\r\n\r\n            this._orthoLeft = Number.MAX_VALUE;\r\n            this._orthoRight = -Number.MAX_VALUE;\r\n            this._orthoTop = -Number.MAX_VALUE;\r\n            this._orthoBottom = Number.MAX_VALUE;\r\n\r\n            let shadowMinZ = Number.MAX_VALUE;\r\n            let shadowMaxZ = -Number.MAX_VALUE;\r\n\r\n            for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\r\n                const mesh = renderList[meshIndex];\r\n\r\n                if (!mesh) {\r\n                    continue;\r\n                }\r\n\r\n                const boundingInfo = mesh.getBoundingInfo();\r\n                const boundingBox = boundingInfo.boundingBox;\r\n\r\n                for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {\r\n                    Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);\r\n\r\n                    if (tempVector3.x < this._orthoLeft) {\r\n                        this._orthoLeft = tempVector3.x;\r\n                    }\r\n                    if (tempVector3.y < this._orthoBottom) {\r\n                        this._orthoBottom = tempVector3.y;\r\n                    }\r\n\r\n                    if (tempVector3.x > this._orthoRight) {\r\n                        this._orthoRight = tempVector3.x;\r\n                    }\r\n                    if (tempVector3.y > this._orthoTop) {\r\n                        this._orthoTop = tempVector3.y;\r\n                    }\r\n                    if (this.autoCalcShadowZBounds) {\r\n                        if (tempVector3.z < shadowMinZ) {\r\n                            shadowMinZ = tempVector3.z;\r\n                        }\r\n                        if (tempVector3.z > shadowMaxZ) {\r\n                            shadowMaxZ = tempVector3.z;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.autoCalcShadowZBounds) {\r\n                this._shadowMinZ = shadowMinZ;\r\n                this._shadowMaxZ = shadowMaxZ;\r\n            }\r\n        }\r\n\r\n        const xOffset = this._orthoRight - this._orthoLeft;\r\n        const yOffset = this._orthoTop - this._orthoBottom;\r\n\r\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\r\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\r\n\r\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\r\n\r\n        Matrix.OrthoOffCenterLHToRef(\r\n            this._orthoLeft - xOffset * this.shadowOrthoScale,\r\n            this._orthoRight + xOffset * this.shadowOrthoScale,\r\n            this._orthoBottom - yOffset * this.shadowOrthoScale,\r\n            this._orthoTop + yOffset * this.shadowOrthoScale,\r\n            useReverseDepthBuffer ? maxZ : minZ,\r\n            useReverseDepthBuffer ? minZ : maxZ,\r\n            matrix,\r\n            this.getScene().getEngine().isNDCHalfZRange\r\n        );\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The directional light\r\n     */\r\n    public transferToEffect(effect: Effect, lightIndex: string): DirectionalLight {\r\n        if (this.computeTransformedInformation()) {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);\r\n            return this;\r\n        }\r\n        this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light {\r\n        if (this.computeTransformedInformation()) {\r\n            effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);\r\n            return this;\r\n        }\r\n\r\n        effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     *\r\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n     * (when not using reverse depth buffer / NDC half Z range)\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getDepthMinZ(activeCamera: Camera): number {\r\n        const engine = this._scene.getEngine();\r\n        return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n    }\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     *\r\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n     * (when not using reverse depth buffer / NDC half Z range)\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getDepthMaxZ(activeCamera: Camera): number {\r\n        const engine = this._scene.getEngine();\r\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"DIRLIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n"]}