{"version":3,"file":"hdr.js","sourceRoot":"","sources":["../../../../../dev/core/src/Misc/HighDynamicRange/hdr.ts"],"names":[],"mappings":"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","sourcesContent":["import type { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { PanoramaToCubeMapTools } from \"./panoramaToCubemap\";\r\n\r\n/**\r\n * Header information of HDR texture files.\r\n */\r\nexport interface HDRInfo {\r\n    /**\r\n     * The height of the texture in pixels.\r\n     */\r\n    height: number;\r\n\r\n    /**\r\n     * The width of the texture in pixels.\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * The index of the beginning of the data in the binary file.\r\n     */\r\n    dataPosition: number;\r\n}\r\n\r\n/**\r\n * This groups tools to convert HDR texture to native colors array.\r\n */\r\nexport class HDRTools {\r\n    private static _Ldexp(mantissa: number, exponent: number): number {\r\n        if (exponent > 1023) {\r\n            return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);\r\n        }\r\n\r\n        if (exponent < -1074) {\r\n            return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);\r\n        }\r\n\r\n        return mantissa * Math.pow(2, exponent);\r\n    }\r\n\r\n    private static _Rgbe2float(float32array: Float32Array, red: number, green: number, blue: number, exponent: number, index: number) {\r\n        if (exponent > 0) {\r\n            /*nonzero pixel*/\r\n            exponent = this._Ldexp(1.0, exponent - (128 + 8));\r\n\r\n            float32array[index + 0] = red * exponent;\r\n            float32array[index + 1] = green * exponent;\r\n            float32array[index + 2] = blue * exponent;\r\n        } else {\r\n            float32array[index + 0] = 0;\r\n            float32array[index + 1] = 0;\r\n            float32array[index + 2] = 0;\r\n        }\r\n    }\r\n\r\n    private static _ReadStringLine(uint8array: Uint8Array, startIndex: number): string {\r\n        let line = \"\";\r\n        let character = \"\";\r\n\r\n        for (let i = startIndex; i < uint8array.length - startIndex; i++) {\r\n            character = String.fromCharCode(uint8array[i]);\r\n\r\n            if (character == \"\\n\") {\r\n                break;\r\n            }\r\n\r\n            line += character;\r\n        }\r\n\r\n        return line;\r\n    }\r\n\r\n    /**\r\n     * Reads header information from an RGBE texture stored in a native array.\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param uint8array The binary file stored in  native array.\r\n     * @returns The header information.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static RGBE_ReadHeader(uint8array: Uint8Array): HDRInfo {\r\n        let height: number = 0;\r\n        let width: number = 0;\r\n\r\n        let line = this._ReadStringLine(uint8array, 0);\r\n        if (line[0] != \"#\" || line[1] != \"?\") {\r\n            throw \"Bad HDR Format.\";\r\n        }\r\n\r\n        let endOfHeader = false;\r\n        let findFormat = false;\r\n        let lineIndex: number = 0;\r\n\r\n        do {\r\n            lineIndex += line.length + 1;\r\n            line = this._ReadStringLine(uint8array, lineIndex);\r\n\r\n            if (line == \"FORMAT=32-bit_rle_rgbe\") {\r\n                findFormat = true;\r\n            } else if (line.length == 0) {\r\n                endOfHeader = true;\r\n            }\r\n        } while (!endOfHeader);\r\n\r\n        if (!findFormat) {\r\n            throw \"HDR Bad header format, unsupported FORMAT\";\r\n        }\r\n\r\n        lineIndex += line.length + 1;\r\n        line = this._ReadStringLine(uint8array, lineIndex);\r\n\r\n        const sizeRegexp = /^-Y (.*) \\+X (.*)$/g;\r\n        const match = sizeRegexp.exec(line);\r\n\r\n        // TODO. Support +Y and -X if needed.\r\n        if (!match || match.length < 3) {\r\n            throw \"HDR Bad header format, no size\";\r\n        }\r\n        width = parseInt(match[2]);\r\n        height = parseInt(match[1]);\r\n\r\n        if (width < 8 || width > 0x7fff) {\r\n            throw \"HDR Bad header format, unsupported size\";\r\n        }\r\n\r\n        lineIndex += line.length + 1;\r\n\r\n        return {\r\n            height: height,\r\n            width: width,\r\n            dataPosition: lineIndex,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.\r\n     * This RGBE texture needs to store the information as a panorama.\r\n     *\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param buffer The binary file stored in an array buffer.\r\n     * @param size The expected size of the extracted cubemap.\r\n     * @returns The Cube Map information.\r\n     */\r\n    public static GetCubeMapTextureData(buffer: ArrayBuffer, size: number, supersample = false): CubeMapInfo {\r\n        const uint8array = new Uint8Array(buffer);\r\n        const hdrInfo = this.RGBE_ReadHeader(uint8array);\r\n        const data = this.RGBE_ReadPixels(uint8array, hdrInfo);\r\n\r\n        const cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size, supersample);\r\n\r\n        return cubeMapData;\r\n    }\r\n\r\n    /**\r\n     * Returns the pixels data extracted from an RGBE texture.\r\n     * This pixels will be stored left to right up to down in the R G B order in one array.\r\n     *\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param uint8array The binary file stored in an array buffer.\r\n     * @param hdrInfo The header information of the file.\r\n     * @returns The pixels data in RGB right to left up to down order.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static RGBE_ReadPixels(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        return this._RGBEReadPixelsRLE(uint8array, hdrInfo);\r\n    }\r\n\r\n    private static _RGBEReadPixelsRLE(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        let num_scanlines = hdrInfo.height;\r\n        const scanline_width = hdrInfo.width;\r\n\r\n        let a: number, b: number, c: number, d: number, count: number;\r\n        let dataIndex = hdrInfo.dataPosition;\r\n        let index = 0,\r\n            endIndex = 0,\r\n            i = 0;\r\n\r\n        const scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E\r\n        const scanLineArray = new Uint8Array(scanLineArrayBuffer);\r\n\r\n        // 3 channels of 4 bytes per pixel in float.\r\n        const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\r\n        const resultArray = new Float32Array(resultBuffer);\r\n\r\n        // read in each successive scanline\r\n        while (num_scanlines > 0) {\r\n            a = uint8array[dataIndex++];\r\n            b = uint8array[dataIndex++];\r\n            c = uint8array[dataIndex++];\r\n            d = uint8array[dataIndex++];\r\n\r\n            if (a != 2 || b != 2 || c & 0x80 || hdrInfo.width < 8 || hdrInfo.width > 32767) {\r\n                return this._RGBEReadPixelsNOTRLE(uint8array, hdrInfo);\r\n            }\r\n\r\n            if (((c << 8) | d) != scanline_width) {\r\n                throw \"HDR Bad header format, wrong scan line width\";\r\n            }\r\n\r\n            index = 0;\r\n\r\n            // read each of the four channels for the scanline into the buffer\r\n            for (i = 0; i < 4; i++) {\r\n                endIndex = (i + 1) * scanline_width;\r\n\r\n                while (index < endIndex) {\r\n                    a = uint8array[dataIndex++];\r\n                    b = uint8array[dataIndex++];\r\n\r\n                    if (a > 128) {\r\n                        // a run of the same value\r\n                        count = a - 128;\r\n                        if (count == 0 || count > endIndex - index) {\r\n                            throw \"HDR Bad Format, bad scanline data (run)\";\r\n                        }\r\n\r\n                        while (count-- > 0) {\r\n                            scanLineArray[index++] = b;\r\n                        }\r\n                    } else {\r\n                        // a non-run\r\n                        count = a;\r\n                        if (count == 0 || count > endIndex - index) {\r\n                            throw \"HDR Bad Format, bad scanline data (non-run)\";\r\n                        }\r\n\r\n                        scanLineArray[index++] = b;\r\n                        if (--count > 0) {\r\n                            for (let j = 0; j < count; j++) {\r\n                                scanLineArray[index++] = uint8array[dataIndex++];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // now convert data from buffer into floats\r\n            for (i = 0; i < scanline_width; i++) {\r\n                a = scanLineArray[i];\r\n                b = scanLineArray[i + scanline_width];\r\n                c = scanLineArray[i + 2 * scanline_width];\r\n                d = scanLineArray[i + 3 * scanline_width];\r\n\r\n                this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\r\n            }\r\n\r\n            num_scanlines--;\r\n        }\r\n\r\n        return resultArray;\r\n    }\r\n\r\n    private static _RGBEReadPixelsNOTRLE(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        // this file is not run length encoded\r\n        // read values sequentially\r\n\r\n        let num_scanlines = hdrInfo.height;\r\n        const scanline_width = hdrInfo.width;\r\n\r\n        let a: number, b: number, c: number, d: number, i: number;\r\n        let dataIndex = hdrInfo.dataPosition;\r\n\r\n        // 3 channels of 4 bytes per pixel in float.\r\n        const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\r\n        const resultArray = new Float32Array(resultBuffer);\r\n\r\n        // read in each successive scanline\r\n        while (num_scanlines > 0) {\r\n            for (i = 0; i < hdrInfo.width; i++) {\r\n                a = uint8array[dataIndex++];\r\n                b = uint8array[dataIndex++];\r\n                c = uint8array[dataIndex++];\r\n                d = uint8array[dataIndex++];\r\n\r\n                this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\r\n            }\r\n\r\n            num_scanlines--;\r\n        }\r\n\r\n        return resultArray;\r\n    }\r\n}\r\n"]}