{"version":3,"file":"andOrNotEvaluator.js","sourceRoot":"","sources":["../../../../dev/core/src/Misc/andOrNotEvaluator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Class used to evaluate queries containing `and` and `or` operators\r\n */\r\nexport class AndOrNotEvaluator {\r\n    /**\r\n     * Evaluate a query\r\n     * @param query defines the query to evaluate\r\n     * @param evaluateCallback defines the callback used to filter result\r\n     * @returns true if the query matches\r\n     */\r\n    public static Eval(query: string, evaluateCallback: (val: any) => boolean): boolean {\r\n        if (!query.match(/\\([^()]*\\)/g)) {\r\n            query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\r\n        } else {\r\n            query = query.replace(/\\([^()]*\\)/g, (r) => {\r\n                // remove parenthesis\r\n                r = r.slice(1, r.length - 1);\r\n                return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\r\n            });\r\n        }\r\n\r\n        if (query === \"true\") {\r\n            return true;\r\n        }\r\n\r\n        if (query === \"false\") {\r\n            return false;\r\n        }\r\n\r\n        return AndOrNotEvaluator.Eval(query, evaluateCallback);\r\n    }\r\n\r\n    private static _HandleParenthesisContent(parenthesisContent: string, evaluateCallback: (val: string) => boolean): string {\r\n        evaluateCallback =\r\n            evaluateCallback ||\r\n            ((r) => {\r\n                return r === \"true\" ? true : false;\r\n            });\r\n\r\n        let result;\r\n        const or = parenthesisContent.split(\"||\");\r\n\r\n        for (const i in or) {\r\n            if (Object.prototype.hasOwnProperty.call(or, i)) {\r\n                let ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\r\n                const and = ori.split(\"&&\");\r\n\r\n                if (and.length > 1) {\r\n                    for (let j = 0; j < and.length; ++j) {\r\n                        const andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\r\n                        if (andj !== \"true\" && andj !== \"false\") {\r\n                            if (andj[0] === \"!\") {\r\n                                result = !evaluateCallback(andj.substring(1));\r\n                            } else {\r\n                                result = evaluateCallback(andj);\r\n                            }\r\n                        } else {\r\n                            result = andj === \"true\" ? true : false;\r\n                        }\r\n                        if (!result) {\r\n                            // no need to continue since 'false && ... && ...' will always return false\r\n                            ori = \"false\";\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (result || ori === \"true\") {\r\n                    // no need to continue since 'true || ... || ...' will always return true\r\n                    result = true;\r\n                    break;\r\n                }\r\n\r\n                // result equals false (or undefined)\r\n\r\n                if (ori !== \"true\" && ori !== \"false\") {\r\n                    if (ori[0] === \"!\") {\r\n                        result = !evaluateCallback(ori.substring(1));\r\n                    } else {\r\n                        result = evaluateCallback(ori);\r\n                    }\r\n                } else {\r\n                    result = ori === \"true\" ? true : false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // the whole parenthesis scope is replaced by 'true' or 'false'\r\n        return result ? \"true\" : \"false\";\r\n    }\r\n\r\n    private static _SimplifyNegation(booleanString: string): string {\r\n        booleanString = booleanString.replace(/^[\\s!]+/, (r) => {\r\n            // remove whitespaces\r\n            r = r.replace(/[\\s]/g, () => \"\");\r\n            return r.length % 2 ? \"!\" : \"\";\r\n        });\r\n\r\n        booleanString = booleanString.trim();\r\n\r\n        if (booleanString === \"!true\") {\r\n            booleanString = \"false\";\r\n        } else if (booleanString === \"!false\") {\r\n            booleanString = \"true\";\r\n        }\r\n\r\n        return booleanString;\r\n    }\r\n}\r\n"]}