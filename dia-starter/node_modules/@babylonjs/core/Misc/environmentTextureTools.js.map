{"version":3,"file":"environmentTextureTools.js","sourceRoot":"","sources":["../../../../dev/core/src/Misc/environmentTextureTools.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Scene } from \"../scene\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { RGBDTextureTools } from \"./rgbdTextureTools\";\r\nimport type { RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\n\r\nimport \"../Engines/Extensions/engine.renderTargetCube\";\r\nimport \"../Engines/Extensions/engine.readTexture\";\r\nimport \"../Materials/Textures/baseTexture.polynomial\";\r\n\r\nimport \"../Shaders/rgbdEncode.fragment\";\r\nimport \"../Shaders/rgbdDecode.fragment\";\r\nimport { DumpTools } from \"../Misc/dumpTools\";\r\n\r\nconst DefaultEnvironmentTextureImageType = \"image/png\";\r\nconst CurrentVersion = 2;\r\n\r\n/**\r\n * Raw texture data and descriptor sufficient for WebGL texture upload\r\n */\r\nexport type EnvironmentTextureInfo = EnvironmentTextureInfoV1 | EnvironmentTextureInfoV2;\r\n\r\n/**\r\n * v1 of EnvironmentTextureInfo\r\n */\r\ninterface EnvironmentTextureInfoV1 {\r\n    /**\r\n     * Version of the environment map\r\n     */\r\n    version: 1;\r\n\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Irradiance information stored in the file.\r\n     */\r\n    irradiance: any;\r\n\r\n    /**\r\n     * Specular information stored in the file.\r\n     */\r\n    specular: any;\r\n}\r\n\r\n/**\r\n * v2 of EnvironmentTextureInfo\r\n */\r\ninterface EnvironmentTextureInfoV2 {\r\n    /**\r\n     * Version of the environment map\r\n     */\r\n    version: 2;\r\n\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Irradiance information stored in the file.\r\n     */\r\n    irradiance: any;\r\n\r\n    /**\r\n     * Specular information stored in the file.\r\n     */\r\n    specular: any;\r\n\r\n    /**\r\n     * The mime type used to encode the image data.\r\n     */\r\n    imageType: string;\r\n}\r\n\r\n/**\r\n * Defines One Image in the file. It requires only the position in the file\r\n * as well as the length.\r\n */\r\ninterface BufferImageData {\r\n    /**\r\n     * Length of the image data.\r\n     */\r\n    length: number;\r\n    /**\r\n     * Position of the data from the null terminator delimiting the end of the JSON.\r\n     */\r\n    position: number;\r\n}\r\n\r\n/**\r\n * Defines the specular data enclosed in the file.\r\n * This corresponds to the version 1 of the data.\r\n */\r\nexport interface EnvironmentTextureSpecularInfoV1 {\r\n    /**\r\n     * Defines where the specular Payload is located. It is a runtime value only not stored in the file.\r\n     */\r\n    specularDataPosition?: number;\r\n    /**\r\n     * This contains all the images data needed to reconstruct the cubemap.\r\n     */\r\n    mipmaps: Array<BufferImageData>;\r\n    /**\r\n     * Defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness.\r\n     */\r\n    lodGenerationScale: number;\r\n}\r\n\r\n/**\r\n * Defines the required storage to save the environment irradiance information.\r\n */\r\ninterface EnvironmentTextureIrradianceInfoV1 {\r\n    x: Array<number>;\r\n    y: Array<number>;\r\n    z: Array<number>;\r\n\r\n    xx: Array<number>;\r\n    yy: Array<number>;\r\n    zz: Array<number>;\r\n\r\n    yz: Array<number>;\r\n    zx: Array<number>;\r\n    xy: Array<number>;\r\n}\r\n\r\n/**\r\n * Options for creating environment textures\r\n */\r\nexport interface CreateEnvTextureOptions {\r\n    /**\r\n     * The mime type of encoded images.\r\n     */\r\n    imageType?: string;\r\n\r\n    /**\r\n     * the image quality of encoded WebP images.\r\n     */\r\n    imageQuality?: number;\r\n}\r\n\r\n/**\r\n * Magic number identifying the env file.\r\n */\r\nconst MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\r\n\r\n/**\r\n * Gets the environment info from an env file.\r\n * @param data The array buffer containing the .env bytes.\r\n * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\r\n */\r\nexport function GetEnvInfo(data: ArrayBufferView): Nullable<EnvironmentTextureInfoV2> {\r\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n    let pos = 0;\r\n\r\n    for (let i = 0; i < MagicBytes.length; i++) {\r\n        if (dataView.getUint8(pos++) !== MagicBytes[i]) {\r\n            Logger.Error(\"Not a babylon environment map\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Read json manifest - collect characters up to null terminator\r\n    let manifestString = \"\";\r\n    let charCode = 0x00;\r\n    while ((charCode = dataView.getUint8(pos++))) {\r\n        manifestString += String.fromCharCode(charCode);\r\n    }\r\n\r\n    let manifest: EnvironmentTextureInfo = JSON.parse(manifestString);\r\n    manifest = normalizeEnvInfo(manifest);\r\n    if (manifest.specular) {\r\n        // Extend the header with the position of the payload.\r\n        manifest.specular.specularDataPosition = pos;\r\n        // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\r\n        manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\r\n    }\r\n\r\n    return manifest;\r\n}\r\n\r\n/**\r\n * Normalizes any supported version of the environment file info to the latest version\r\n * @param info environment file info on any supported version\r\n * @returns environment file info in the latest supported version\r\n * @private\r\n */\r\nexport function normalizeEnvInfo(info: EnvironmentTextureInfo): EnvironmentTextureInfoV2 {\r\n    if (info.version > CurrentVersion) {\r\n        throw new Error(`Unsupported babylon environment map version \"${info.version}\". Latest supported version is \"${CurrentVersion}\".`);\r\n    }\r\n\r\n    if (info.version === 2) {\r\n        return info;\r\n    }\r\n\r\n    // Migrate a v1 info to v2\r\n    info = { ...info, version: 2, imageType: DefaultEnvironmentTextureImageType };\r\n\r\n    return info;\r\n}\r\n\r\n/**\r\n * Creates an environment texture from a loaded cube texture.\r\n * @param texture defines the cube texture to convert in env file\r\n * @param options options for the conversion process\r\n * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\r\n * @param options.imageQuality the image quality of encoded WebP images.\r\n * @returns a promise containing the environment data if successful.\r\n */\r\nexport async function CreateEnvTextureAsync(texture: BaseTexture, options: CreateEnvTextureOptions = {}): Promise<ArrayBuffer> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return Promise.reject(\"The cube texture is invalid.\");\r\n    }\r\n\r\n    const imageType = options.imageType ?? DefaultEnvironmentTextureImageType;\r\n\r\n    const engine = internalTexture.getEngine() as Engine;\r\n\r\n    if (\r\n        texture.textureType !== Constants.TEXTURETYPE_HALF_FLOAT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_FLOAT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_BYTE &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_INT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_INTEGER &&\r\n        texture.textureType !== -1\r\n    ) {\r\n        return Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\r\n    }\r\n\r\n    let textureType = Constants.TEXTURETYPE_FLOAT;\r\n    if (!engine.getCaps().textureFloatRender) {\r\n        textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        if (!engine.getCaps().textureHalfFloatRender) {\r\n            return Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\r\n        }\r\n    }\r\n\r\n    // sphericalPolynomial is lazy loaded so simply accessing it should trigger the computation.\r\n    texture.sphericalPolynomial;\r\n\r\n    // Lets keep track of the polynomial promise so we can wait for it to be ready before generating the pixels.\r\n    const sphericalPolynomialPromise = texture.getInternalTexture()?._sphericalPolynomialPromise;\r\n\r\n    const cubeWidth = internalTexture.width;\r\n    const hostingScene = new Scene(engine);\r\n    const specularTextures: { [key: number]: ArrayBuffer } = {};\r\n\r\n    // As we are going to readPixels the faces of the cube, make sure the drawing/update commands for the cube texture are fully sent to the GPU in case it is drawn for the first time in this very frame!\r\n    engine.flushFramebuffer();\r\n\r\n    // Read and collect all mipmaps data from the cube.\r\n    const mipmapsCount = Scalar.ILog2(internalTexture.width);\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        const faceWidth = Math.pow(2, mipmapsCount - i);\r\n\r\n        // All faces of the cube.\r\n        for (let face = 0; face < 6; face++) {\r\n            let faceData = await texture.readPixels(face, i, undefined, false);\r\n            if (faceData && faceData.byteLength === (faceData as Uint8Array).length) {\r\n                const faceDataFloat = new Float32Array(faceData!.byteLength * 4);\r\n                for (let i = 0; i < faceData.byteLength; i++) {\r\n                    faceDataFloat[i] = (faceData as Uint8Array)[i] / 255;\r\n                    // Gamma to linear\r\n                    faceDataFloat[i] = Math.pow(faceDataFloat[i], 2.2);\r\n                }\r\n                faceData = faceDataFloat;\r\n            } else if (faceData && texture.gammaSpace) {\r\n                const floatData = faceData as Float32Array;\r\n                for (let i = 0; i < floatData.length; i++) {\r\n                    // Gamma to linear\r\n                    floatData[i] = Math.pow(floatData[i], 2.2);\r\n                }\r\n            }\r\n\r\n            const tempTexture = engine.createRawTexture(\r\n                faceData,\r\n                faceWidth,\r\n                faceWidth,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                false,\r\n                true,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                null,\r\n                textureType\r\n            );\r\n\r\n            await RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);\r\n\r\n            const rgbdEncodedData = await engine._readTexturePixels(tempTexture, faceWidth, faceWidth);\r\n\r\n            const imageEncodedData = await DumpTools.DumpDataAsync(faceWidth, faceWidth, rgbdEncodedData, imageType, undefined, false, true, options.imageQuality);\r\n\r\n            specularTextures[i * 6 + face] = imageEncodedData as ArrayBuffer;\r\n\r\n            tempTexture.dispose();\r\n        }\r\n    }\r\n\r\n    // We can delete the hosting scene keeping track of all the creation objects\r\n    hostingScene.dispose();\r\n\r\n    // Ensure completion of the polynomial creation promise.\r\n    if (sphericalPolynomialPromise) {\r\n        await sphericalPolynomialPromise;\r\n    }\r\n\r\n    // Creates the json header for the env texture\r\n    const info: EnvironmentTextureInfo = {\r\n        version: CurrentVersion,\r\n        width: cubeWidth,\r\n        imageType,\r\n        irradiance: _CreateEnvTextureIrradiance(texture),\r\n        specular: {\r\n            mipmaps: [],\r\n            lodGenerationScale: texture.lodGenerationScale,\r\n        },\r\n    };\r\n\r\n    // Sets the specular image data information\r\n    let position = 0;\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const byteLength = specularTextures[i * 6 + face].byteLength;\r\n            info.specular.mipmaps.push({\r\n                length: byteLength,\r\n                position: position,\r\n            });\r\n            position += byteLength;\r\n        }\r\n    }\r\n\r\n    // Encode the JSON as an array buffer\r\n    const infoString = JSON.stringify(info);\r\n    const infoBuffer = new ArrayBuffer(infoString.length + 1);\r\n    const infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.\r\n    for (let i = 0, strLen = infoString.length; i < strLen; i++) {\r\n        infoView[i] = infoString.charCodeAt(i);\r\n    }\r\n    // Ends up with a null terminator for easier parsing\r\n    infoView[infoString.length] = 0x00;\r\n\r\n    // Computes the final required size and creates the storage\r\n    const totalSize = MagicBytes.length + position + infoBuffer.byteLength;\r\n    const finalBuffer = new ArrayBuffer(totalSize);\r\n    const finalBufferView = new Uint8Array(finalBuffer);\r\n    const dataView = new DataView(finalBuffer);\r\n\r\n    // Copy the magic bytes identifying the file in\r\n    let pos = 0;\r\n    for (let i = 0; i < MagicBytes.length; i++) {\r\n        dataView.setUint8(pos++, MagicBytes[i]);\r\n    }\r\n\r\n    // Add the json info\r\n    finalBufferView.set(new Uint8Array(infoBuffer), pos);\r\n    pos += infoBuffer.byteLength;\r\n\r\n    // Finally inserts the texture data\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const dataBuffer = specularTextures[i * 6 + face];\r\n            finalBufferView.set(new Uint8Array(dataBuffer), pos);\r\n            pos += dataBuffer.byteLength;\r\n        }\r\n    }\r\n\r\n    // Voila\r\n    return finalBuffer;\r\n}\r\n\r\n/**\r\n * Creates a JSON representation of the spherical data.\r\n * @param texture defines the texture containing the polynomials\r\n * @returns the JSON representation of the spherical info\r\n */\r\nfunction _CreateEnvTextureIrradiance(texture: BaseTexture): Nullable<EnvironmentTextureIrradianceInfoV1> {\r\n    const polynmials = texture.sphericalPolynomial;\r\n    if (polynmials == null) {\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\r\n        y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\r\n        z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\r\n\r\n        xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\r\n        yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\r\n        zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\r\n\r\n        yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\r\n        zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\r\n        xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z],\r\n    } as any;\r\n}\r\n\r\n/**\r\n * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n * @param data the image data\r\n * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n * @returns the views described by info providing access to the underlying buffer\r\n */\r\nexport function CreateImageDataArrayBufferViews(data: ArrayBufferView, info: EnvironmentTextureInfo): Array<Array<ArrayBufferView>> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n\r\n    // Double checks the enclosed info\r\n    let mipmapsCount = Scalar.Log2(info.width);\r\n    mipmapsCount = Math.round(mipmapsCount) + 1;\r\n    if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\r\n        throw new Error(`Unsupported specular mipmaps number \"${specularInfo.mipmaps.length}\"`);\r\n    }\r\n\r\n    const imageData = new Array<Array<ArrayBufferView>>(mipmapsCount);\r\n    for (let i = 0; i < mipmapsCount; i++) {\r\n        imageData[i] = new Array<ArrayBufferView>(6);\r\n        for (let face = 0; face < 6; face++) {\r\n            const imageInfo = specularInfo.mipmaps[i * 6 + face];\r\n            imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition! + imageInfo.position, imageInfo.length);\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * Uploads the texture info contained in the env file to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param data defines the data to load\r\n * @param info defines the texture info retrieved through the GetEnvInfo method\r\n * @returns a promise\r\n */\r\nexport function UploadEnvLevelsAsync(texture: InternalTexture, data: ArrayBufferView, info: EnvironmentTextureInfo): Promise<void> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n    if (!specularInfo) {\r\n        // Nothing else parsed so far\r\n        return Promise.resolve();\r\n    }\r\n\r\n    texture._lodGenerationScale = specularInfo.lodGenerationScale;\r\n\r\n    const imageData = CreateImageDataArrayBufferViews(data, info);\r\n\r\n    return UploadLevelsAsync(texture, imageData, info.imageType);\r\n}\r\n\r\nfunction _OnImageReadyAsync(\r\n    image: HTMLImageElement | ImageBitmap,\r\n    engine: Engine,\r\n    expandTexture: boolean,\r\n    rgbdPostProcess: Nullable<PostProcess>,\r\n    url: string,\r\n    face: number,\r\n    i: number,\r\n    generateNonLODTextures: boolean,\r\n    lodTextures: Nullable<{ [lod: number]: BaseTexture }>,\r\n    cubeRtt: Nullable<RenderTargetWrapper>,\r\n    texture: InternalTexture\r\n): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n        if (expandTexture) {\r\n            const tempTexture = engine.createTexture(\r\n                null,\r\n                true,\r\n                true,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                null,\r\n                (message) => {\r\n                    reject(message);\r\n                },\r\n                image\r\n            );\r\n\r\n            rgbdPostProcess!.getEffect().executeWhenCompiled(() => {\r\n                // Uncompress the data to a RTT\r\n                rgbdPostProcess!.externalTextureSamplerBinding = true;\r\n                rgbdPostProcess!.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", tempTexture);\r\n                    effect.setFloat2(\"scale\", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);\r\n                };\r\n\r\n                if (!engine.scenes.length) {\r\n                    return;\r\n                }\r\n\r\n                engine.scenes[0].postProcessManager.directRender([rgbdPostProcess!], cubeRtt, true, face, i);\r\n\r\n                // Cleanup\r\n                engine.restoreDefaultFramebuffer();\r\n                tempTexture.dispose();\r\n                URL.revokeObjectURL(url);\r\n                resolve();\r\n            });\r\n        } else {\r\n            engine._uploadImageToTexture(texture, image, face, i);\r\n\r\n            // Upload the face to the non lod texture support\r\n            if (generateNonLODTextures) {\r\n                const lodTexture = lodTextures![i];\r\n                if (lodTexture) {\r\n                    engine._uploadImageToTexture(lodTexture._texture!, image, face, 0);\r\n                }\r\n            }\r\n            resolve();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Uploads the levels of image data to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param imageData defines the array buffer views of image data [mipmap][face]\r\n * @param imageType the mime type of the image data\r\n * @returns a promise\r\n */\r\nexport function UploadLevelsAsync(texture: InternalTexture, imageData: ArrayBufferView[][], imageType: string = DefaultEnvironmentTextureImageType): Promise<void> {\r\n    if (!Tools.IsExponentOfTwo(texture.width)) {\r\n        throw new Error(\"Texture size must be a power of two\");\r\n    }\r\n\r\n    const mipmapsCount = Scalar.ILog2(texture.width) + 1;\r\n\r\n    // Gets everything ready.\r\n    const engine = texture.getEngine() as Engine;\r\n    let expandTexture = false;\r\n    let generateNonLODTextures = false;\r\n    let rgbdPostProcess: Nullable<PostProcess> = null;\r\n    let cubeRtt: Nullable<RenderTargetWrapper> = null;\r\n    let lodTextures: Nullable<{ [lod: number]: BaseTexture }> = null;\r\n    const caps = engine.getCaps();\r\n\r\n    texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n    texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    texture.generateMipMaps = true;\r\n    texture._cachedAnisotropicFilteringLevel = null;\r\n    engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, texture);\r\n\r\n    // Add extra process if texture lod is not supported\r\n    if (!caps.textureLOD) {\r\n        expandTexture = false;\r\n        generateNonLODTextures = true;\r\n        lodTextures = {};\r\n    }\r\n    // in webgl 1 there are no ways to either render or copy lod level information for float textures.\r\n    else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {\r\n        expandTexture = false;\r\n    }\r\n    // If half float available we can uncompress the texture\r\n    else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n        expandTexture = true;\r\n        texture.type = Constants.TEXTURETYPE_HALF_FLOAT;\r\n    }\r\n    // If full float available we can uncompress the texture\r\n    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n        expandTexture = true;\r\n        texture.type = Constants.TEXTURETYPE_FLOAT;\r\n    }\r\n\r\n    // Expand the texture if possible\r\n    if (expandTexture) {\r\n        // Simply run through the decode PP\r\n        rgbdPostProcess = new PostProcess(\r\n            \"rgbdDecode\",\r\n            \"rgbdDecode\",\r\n            null,\r\n            null,\r\n            1,\r\n            null,\r\n            Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            false,\r\n            undefined,\r\n            texture.type,\r\n            undefined,\r\n            null,\r\n            false\r\n        );\r\n\r\n        texture._isRGBD = false;\r\n        texture.invertY = false;\r\n        cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\r\n            generateDepthBuffer: false,\r\n            generateMipMaps: true,\r\n            generateStencilBuffer: false,\r\n            samplingMode: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n            type: texture.type,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n        });\r\n    } else {\r\n        texture._isRGBD = true;\r\n        texture.invertY = true;\r\n\r\n        // In case of missing support, applies the same patch than DDS files.\r\n        if (generateNonLODTextures) {\r\n            const mipSlices = 3;\r\n            const scale = texture._lodGenerationScale;\r\n            const offset = texture._lodGenerationOffset;\r\n\r\n            for (let i = 0; i < mipSlices; i++) {\r\n                //compute LOD from even spacing in smoothness (matching shader calculation)\r\n                const smoothness = i / (mipSlices - 1);\r\n                const roughness = 1 - smoothness;\r\n\r\n                const minLODIndex = offset; // roughness = 0\r\n                const maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\r\n\r\n                const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\r\n                const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\r\n\r\n                const glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);\r\n                glTextureFromLod.isCube = true;\r\n                glTextureFromLod.invertY = true;\r\n                glTextureFromLod.generateMipMaps = false;\r\n                engine.updateTextureSamplingMode(Constants.TEXTURE_LINEAR_LINEAR, glTextureFromLod);\r\n\r\n                // Wrap in a base texture for easy binding.\r\n                const lodTexture = new BaseTexture(null);\r\n                lodTexture._isCube = true;\r\n                lodTexture._texture = glTextureFromLod;\r\n                lodTextures![mipmapIndex] = lodTexture;\r\n\r\n                switch (i) {\r\n                    case 0:\r\n                        texture._lodTextureLow = lodTexture;\r\n                        break;\r\n                    case 1:\r\n                        texture._lodTextureMid = lodTexture;\r\n                        break;\r\n                    case 2:\r\n                        texture._lodTextureHigh = lodTexture;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const promises: Promise<void>[] = [];\r\n    // All mipmaps up to provided number of images\r\n    for (let i = 0; i < imageData.length; i++) {\r\n        // All faces\r\n        for (let face = 0; face < 6; face++) {\r\n            // Constructs an image element from image data\r\n            const bytes = imageData[i][face];\r\n            const blob = new Blob([bytes], { type: imageType });\r\n            const url = URL.createObjectURL(blob);\r\n            let promise: Promise<void>;\r\n\r\n            if (engine._features.forceBitmapOverHTMLImageElement) {\r\n                promise = engine.createImageBitmap(blob, { premultiplyAlpha: \"none\" }).then((img) => {\r\n                    return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\r\n                });\r\n            } else {\r\n                const image = new Image();\r\n                image.src = url;\r\n\r\n                // Enqueue promise to upload to the texture.\r\n                promise = new Promise<void>((resolve, reject) => {\r\n                    image.onload = () => {\r\n                        _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture)\r\n                            .then(() => resolve())\r\n                            .catch((reason) => {\r\n                                reject(reason);\r\n                            });\r\n                    };\r\n                    image.onerror = (error) => {\r\n                        reject(error);\r\n                    };\r\n                });\r\n            }\r\n            promises.push(promise);\r\n        }\r\n    }\r\n\r\n    // Fill remaining mipmaps with black textures.\r\n    if (imageData.length < mipmapsCount) {\r\n        let data: ArrayBufferView;\r\n        const size = Math.pow(2, mipmapsCount - 1 - imageData.length);\r\n        const dataLength = size * size * 4;\r\n        switch (texture.type) {\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT: {\r\n                data = new Uint8Array(dataLength);\r\n                break;\r\n            }\r\n            case Constants.TEXTURETYPE_HALF_FLOAT: {\r\n                data = new Uint16Array(dataLength);\r\n                break;\r\n            }\r\n            case Constants.TEXTURETYPE_FLOAT: {\r\n                data = new Float32Array(dataLength);\r\n                break;\r\n            }\r\n        }\r\n        for (let i = imageData.length; i < mipmapsCount; i++) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine._uploadArrayBufferViewToTexture(texture, data!, face, i);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Once all done, finishes the cleanup and return\r\n    return Promise.all(promises).then(() => {\r\n        // Release temp RTT.\r\n        if (cubeRtt) {\r\n            engine._releaseTexture(texture);\r\n            cubeRtt._swapAndDie(texture);\r\n        }\r\n        // Release temp Post Process.\r\n        if (rgbdPostProcess) {\r\n            rgbdPostProcess.dispose();\r\n        }\r\n        // Flag internal texture as ready in case they are in use.\r\n        if (generateNonLODTextures) {\r\n            if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\r\n                texture._lodTextureHigh._texture.isReady = true;\r\n            }\r\n            if (texture._lodTextureMid && texture._lodTextureMid._texture) {\r\n                texture._lodTextureMid._texture.isReady = true;\r\n            }\r\n            if (texture._lodTextureLow && texture._lodTextureLow._texture) {\r\n                texture._lodTextureLow._texture.isReady = true;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Uploads spherical polynomials information to the texture.\r\n * @param texture defines the texture we are trying to upload the information to\r\n * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n */\r\nexport function UploadEnvSpherical(texture: InternalTexture, info: EnvironmentTextureInfo): void {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const irradianceInfo = info.irradiance as EnvironmentTextureIrradianceInfoV1;\r\n    if (!irradianceInfo) {\r\n        return;\r\n    }\r\n\r\n    const sp = new SphericalPolynomial();\r\n    Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\r\n    Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\r\n    Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\r\n    Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\r\n    Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\r\n    Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\r\n    Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\r\n    Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\r\n    Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\r\n    texture._sphericalPolynomial = sp;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _UpdateRGBDAsync(\r\n    internalTexture: InternalTexture,\r\n    data: ArrayBufferView[][],\r\n    sphericalPolynomial: Nullable<SphericalPolynomial>,\r\n    lodScale: number,\r\n    lodOffset: number\r\n): Promise<InternalTexture> {\r\n    const proxy = internalTexture\r\n        .getEngine()\r\n        .createRawCubeTexture(\r\n            null,\r\n            internalTexture.width,\r\n            internalTexture.format,\r\n            internalTexture.type,\r\n            internalTexture.generateMipMaps,\r\n            internalTexture.invertY,\r\n            internalTexture.samplingMode,\r\n            internalTexture._compression\r\n        );\r\n    const proxyPromise = UploadLevelsAsync(proxy, data).then(() => internalTexture);\r\n    internalTexture.onRebuildCallback = (_internalTexture) => {\r\n        return {\r\n            proxy: proxyPromise,\r\n            isReady: true,\r\n            isAsync: true,\r\n        };\r\n    };\r\n    internalTexture._source = InternalTextureSource.CubeRawRGBD;\r\n    internalTexture._bufferViewArrayArray = data;\r\n    internalTexture._lodGenerationScale = lodScale;\r\n    internalTexture._lodGenerationOffset = lodOffset;\r\n    internalTexture._sphericalPolynomial = sphericalPolynomial;\r\n\r\n    return UploadLevelsAsync(internalTexture, data).then(() => {\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    });\r\n}\r\n\r\n/**\r\n * Sets of helpers addressing the serialization and deserialization of environment texture\r\n * stored in a BabylonJS env file.\r\n * Those files are usually stored as .env files.\r\n */\r\nexport const EnvironmentTextureTools = {\r\n    /**\r\n     * Gets the environment info from an env file.\r\n     * @param data The array buffer containing the .env bytes.\r\n     * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\r\n     */\r\n    GetEnvInfo,\r\n\r\n    /**\r\n     * Creates an environment texture from a loaded cube texture.\r\n     * @param texture defines the cube texture to convert in env file\r\n     * @param options options for the conversion process\r\n     * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\r\n     * @param options.imageQuality the image quality of encoded WebP images.\r\n     * @returns a promise containing the environment data if successful.\r\n     */\r\n    CreateEnvTextureAsync,\r\n\r\n    /**\r\n     * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n     * @param data the image data\r\n     * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n     * @returns the views described by info providing access to the underlying buffer\r\n     */\r\n    CreateImageDataArrayBufferViews,\r\n\r\n    /**\r\n     * Uploads the texture info contained in the env file to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param data defines the data to load\r\n     * @param info defines the texture info retrieved through the GetEnvInfo method\r\n     * @returns a promise\r\n     */\r\n    UploadEnvLevelsAsync,\r\n\r\n    /**\r\n     * Uploads the levels of image data to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param imageData defines the array buffer views of image data [mipmap][face]\r\n     * @param imageType the mime type of the image data\r\n     * @returns a promise\r\n     */\r\n    UploadLevelsAsync,\r\n\r\n    /**\r\n     * Uploads spherical polynomials information to the texture.\r\n     * @param texture defines the texture we are trying to upload the information to\r\n     * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n     */\r\n    UploadEnvSpherical,\r\n};\r\n"]}