{"version":3,"file":"codeStringParsingTools.js","sourceRoot":"","sources":["../../../../dev/core/src/Misc/codeStringParsingTools.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Extracts the characters between two markers (for eg, between \"(\" and \")\"). The function handles nested markers as well as markers inside strings (delimited by \", ' or `) and comments\r\n * @param markerOpen opening marker\r\n * @param markerClose closing marker\r\n * @param block code block to parse\r\n * @param startIndex starting index in block where the extraction must start. The character at block[startIndex] should be the markerOpen character!\r\n * @returns index of the last character for the extraction (or -1 if the string is invalid - no matching closing marker found). The string to extract (without the markers) is the string between startIndex + 1 and the returned value (exclusive)\r\n */\r\nexport function ExtractBetweenMarkers(markerOpen: string, markerClose: string, block: string, startIndex: number): number {\r\n    let currPos = startIndex,\r\n        openMarkers = 0,\r\n        waitForChar = \"\";\r\n\r\n    while (currPos < block.length) {\r\n        const currChar = block.charAt(currPos);\r\n\r\n        if (!waitForChar) {\r\n            switch (currChar) {\r\n                case markerOpen:\r\n                    openMarkers++;\r\n                    break;\r\n                case markerClose:\r\n                    openMarkers--;\r\n                    break;\r\n                case '\"':\r\n                case \"'\":\r\n                case \"`\":\r\n                    waitForChar = currChar;\r\n                    break;\r\n                case \"/\":\r\n                    if (currPos + 1 < block.length) {\r\n                        const nextChar = block.charAt(currPos + 1);\r\n                        if (nextChar === \"/\") {\r\n                            waitForChar = \"\\n\";\r\n                        } else if (nextChar === \"*\") {\r\n                            waitForChar = \"*/\";\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        } else {\r\n            if (currChar === waitForChar) {\r\n                if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\r\n                } else {\r\n                    waitForChar = \"\";\r\n                }\r\n            } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\r\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\r\n                if (waitForChar === \"\") {\r\n                    currPos++;\r\n                }\r\n            }\r\n        }\r\n\r\n        currPos++;\r\n        if (openMarkers === 0) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return openMarkers === 0 ? currPos - 1 : -1;\r\n}\r\n\r\n/**\r\n * Parses a string and skip whitespaces\r\n * @param s string to parse\r\n * @param index index where to start parsing\r\n * @returns the index after all whitespaces have been skipped\r\n */\r\nexport function SkipWhitespaces(s: string, index: number): number {\r\n    while (index < s.length) {\r\n        const c = s[index];\r\n        if (c !== \" \" && c !== \"\\n\" && c !== \"\\r\" && c !== \"\\t\" && c !== \"\\u000a\" && c !== \"\\u00a0\") {\r\n            break;\r\n        }\r\n        index++;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * Checks if a character is an identifier character (meaning, if it is 0-9, A-Z, a-z or _)\r\n * @param c character to check\r\n * @returns true if the character is an identifier character\r\n */\r\nexport function IsIdentifierChar(c: string): boolean {\r\n    const v = c.charCodeAt(0);\r\n    return (\r\n        (v >= 48 && v <= 57) || // 0-9\r\n        (v >= 65 && v <= 90) || // A-Z\r\n        (v >= 97 && v <= 122) || // a-z\r\n        v == 95\r\n    ); // _\r\n}\r\n\r\n/**\r\n * Removes the comments of a code block\r\n * @param block code block to parse\r\n * @returns block with the comments removed\r\n */\r\nexport function RemoveComments(block: string): string {\r\n    let currPos = 0,\r\n        waitForChar = \"\",\r\n        inComments = false;\r\n    const s = [];\r\n\r\n    while (currPos < block.length) {\r\n        const currChar = block.charAt(currPos);\r\n\r\n        if (!waitForChar) {\r\n            switch (currChar) {\r\n                case '\"':\r\n                case \"'\":\r\n                case \"`\":\r\n                    waitForChar = currChar;\r\n                    break;\r\n                case \"/\":\r\n                    if (currPos + 1 < block.length) {\r\n                        const nextChar = block.charAt(currPos + 1);\r\n                        if (nextChar === \"/\") {\r\n                            waitForChar = \"\\n\";\r\n                            inComments = true;\r\n                        } else if (nextChar === \"*\") {\r\n                            waitForChar = \"*/\";\r\n                            inComments = true;\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n            if (!inComments) {\r\n                s.push(currChar);\r\n            }\r\n        } else {\r\n            if (currChar === waitForChar) {\r\n                if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\r\n                    s.push(currChar);\r\n                } else {\r\n                    waitForChar = \"\";\r\n                    inComments = false;\r\n                }\r\n            } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\r\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\r\n                if (waitForChar === \"\") {\r\n                    inComments = false;\r\n                    currPos++;\r\n                }\r\n            } else {\r\n                if (!inComments) {\r\n                    s.push(currChar);\r\n                }\r\n            }\r\n        }\r\n\r\n        currPos++;\r\n    }\r\n\r\n    return s.join(\"\");\r\n}\r\n\r\n/**\r\n * Finds the first occurrence of a character in a string going backward\r\n * @param s the string to parse\r\n * @param index starting index in the string\r\n * @param c the character to find\r\n * @param c2 an optional second character to find\r\n * @returns the index of the character if found, else -1\r\n */\r\nexport function FindBackward(s: string, index: number, c: string, c2?: string): number {\r\n    while (index >= 0 && s.charAt(index) !== c && (!c2 || s.charAt(index) !== c2)) {\r\n        index--;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * Escapes a string so that it is usable as a regular expression\r\n * @param s string to escape\r\n * @returns escaped string\r\n */\r\nexport function EscapeRegExp(s: string): string {\r\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\r\n}\r\n"]}