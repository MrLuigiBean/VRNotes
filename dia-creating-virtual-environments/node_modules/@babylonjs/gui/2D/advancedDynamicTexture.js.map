{"version":3,"file":"advancedDynamicTexture.js","sourceRoot":"","sources":["../../../../dev/gui/src/2D/advancedDynamicTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Vector2, Vector3, TmpVectors } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { PointerInfoPre, PointerInfo, PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"core/Events/pointerEvents\";\r\nimport { ClipboardEventTypes, ClipboardInfo } from \"core/Events/clipboardEvents\";\r\nimport type { KeyboardInfoPre } from \"core/Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"core/Events/keyboardEvents\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { DynamicTexture } from \"core/Materials/Textures/dynamicTexture\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Layer } from \"core/Layers/layer\";\r\nimport type { Engine } from \"core/Engines/engine\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport { Container } from \"./controls/container\";\r\nimport { Control } from \"./controls/control\";\r\nimport type { IFocusableControl } from \"./controls/focusableControl\";\r\nimport { Style } from \"./style\";\r\nimport { Measure } from \"./measure\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Viewport } from \"core/Maths/math.viewport\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { WebRequest } from \"core/Misc/webRequest\";\r\nimport type { IPointerEvent, IWheelEvent } from \"core/Events/deviceInputEvents\";\r\nimport { RandomGUID } from \"core/Misc/guid\";\r\nimport { GetClass } from \"core/Misc/typeStore\";\r\nimport { DecodeBase64ToBinary } from \"core/Misc/stringTools\";\r\n\r\nimport type { StandardMaterial } from \"core/Materials/standardMaterial\";\r\n\r\n/**\r\n * Class used to create texture to support 2D GUI elements\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui\r\n */\r\nexport class AdvancedDynamicTexture extends DynamicTexture {\r\n    /** Define the Uurl to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Indicates if some optimizations can be performed in GUI GPU management (the downside is additional memory/GPU texture memory used) */\r\n    public static AllowGPUOptimizations = true;\r\n\r\n    /** Snippet ID if the content was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /** Observable that fires when the GUI is ready */\r\n    public onGuiReadyObservable = new Observable<AdvancedDynamicTexture>();\r\n\r\n    private _isDirty = false;\r\n    private _renderObserver: Nullable<Observer<Camera>>;\r\n    private _resizeObserver: Nullable<Observer<Engine>>;\r\n    private _preKeyboardObserver: Nullable<Observer<KeyboardInfoPre>>;\r\n    private _prePointerObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>>;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _canvasPointerOutObserver: Nullable<Observer<PointerEvent>>;\r\n    private _canvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _controlAddedObserver: Nullable<Observer<Nullable<Control>>>;\r\n    private _controlRemovedObserver: Nullable<Observer<Nullable<Control>>>;\r\n    private _background: string;\r\n    /** @internal */\r\n    public _rootContainer = new Container(\"root\");\r\n    /** @internal */\r\n    public _lastPickedControl: Control;\r\n    /** @internal */\r\n    public _lastControlOver: { [pointerId: number]: Control } = {};\r\n    /** @internal */\r\n    public _lastControlDown: { [pointerId: number]: Control } = {};\r\n    /** @internal */\r\n    public _capturingControl: { [pointerId: number]: Control } = {};\r\n    /** @internal */\r\n    public _shouldBlockPointer: boolean;\r\n    /** @internal */\r\n    public _layerToDispose: Nullable<Layer>;\r\n    /** @internal */\r\n    public _linkedControls = new Array<Control>();\r\n    /** @internal */\r\n    public _isFullscreen = false;\r\n    private _fullscreenViewport = new Viewport(0, 0, 1, 1);\r\n    private _idealWidth = 0;\r\n    private _idealHeight = 0;\r\n    private _useSmallestIdeal: boolean = false;\r\n    private _renderAtIdealSize = false;\r\n    private _focusedControl: Nullable<IFocusableControl>;\r\n    private _blockNextFocusCheck = false;\r\n    private _renderScale = 1;\r\n    private _rootElement: Nullable<HTMLElement>;\r\n    private _cursorChanged = false;\r\n    private _defaultMousePointerId = 0;\r\n    private _rootChildrenHaveChanged: boolean = false;\r\n\r\n    /** @internal */\r\n    public _capturedPointerIds = new Set<number>();\r\n\r\n    /** @internal */\r\n    public _numLayoutCalls = 0;\r\n    /** Gets the number of layout calls made the last time the ADT has been rendered */\r\n    public get numLayoutCalls(): number {\r\n        return this._numLayoutCalls;\r\n    }\r\n\r\n    /** @internal */\r\n    public _numRenderCalls = 0;\r\n    /** Gets the number of render calls made the last time the ADT has been rendered */\r\n    public get numRenderCalls(): number {\r\n        return this._numRenderCalls;\r\n    }\r\n\r\n    /**\r\n     * Define type to string to ensure compatibility across browsers\r\n     * Safari doesn't support DataTransfer constructor\r\n     */\r\n    private _clipboardData: string = \"\";\r\n    /**\r\n     * Observable event triggered each time an clipboard event is received from the rendering canvas\r\n     */\r\n    public onClipboardObservable = new Observable<ClipboardInfo>();\r\n    /**\r\n     * Observable event triggered each time a pointer down is intercepted by a control\r\n     */\r\n    public onControlPickedObservable = new Observable<Control>();\r\n    /**\r\n     * Observable event triggered before layout is evaluated\r\n     */\r\n    public onBeginLayoutObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Observable event triggered after the layout was evaluated\r\n     */\r\n    public onEndLayoutObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Observable event triggered before the texture is rendered\r\n     */\r\n    public onBeginRenderObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Observable event triggered after the texture was rendered\r\n     */\r\n    public onEndRenderObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Gets or sets a boolean defining if alpha is stored as premultiplied\r\n     */\r\n    public premulAlpha = false;\r\n    /**\r\n     * Gets or sets a boolean indicating that the canvas must be reverted on Y when updating the texture\r\n     */\r\n    public applyYInversionOnUpdate = true;\r\n    /**\r\n     * Gets or sets a number used to scale rendering size (2 means that the texture will be twice bigger).\r\n     * Useful when you want more antialiasing\r\n     */\r\n    public get renderScale(): number {\r\n        return this._renderScale;\r\n    }\r\n    public set renderScale(value: number) {\r\n        if (value === this._renderScale) {\r\n            return;\r\n        }\r\n        this._renderScale = value;\r\n        this._onResize();\r\n    }\r\n    /** Gets or sets the background color */\r\n    public get background(): string {\r\n        return this._background;\r\n    }\r\n    public set background(value: string) {\r\n        if (this._background === value) {\r\n            return;\r\n        }\r\n        this._background = value;\r\n        this.markAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets the ideal width used to design controls.\r\n     * The GUI will then rescale everything accordingly\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     */\r\n    public get idealWidth(): number {\r\n        return this._idealWidth;\r\n    }\r\n    public set idealWidth(value: number) {\r\n        if (this._idealWidth === value) {\r\n            return;\r\n        }\r\n        this._idealWidth = value;\r\n        this.markAsDirty();\r\n        this._rootContainer._markAllAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets the ideal height used to design controls.\r\n     * The GUI will then rescale everything accordingly\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     */\r\n    public get idealHeight(): number {\r\n        return this._idealHeight;\r\n    }\r\n    public set idealHeight(value: number) {\r\n        if (this._idealHeight === value) {\r\n            return;\r\n        }\r\n        this._idealHeight = value;\r\n        this.markAsDirty();\r\n        this._rootContainer._markAllAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets a boolean indicating if the smallest ideal value must be used if idealWidth and idealHeight are both set\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     */\r\n    public get useSmallestIdeal(): boolean {\r\n        return this._useSmallestIdeal;\r\n    }\r\n    public set useSmallestIdeal(value: boolean) {\r\n        if (this._useSmallestIdeal === value) {\r\n            return;\r\n        }\r\n        this._useSmallestIdeal = value;\r\n        this.markAsDirty();\r\n        this._rootContainer._markAllAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets a boolean indicating if adaptive scaling must be used\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     */\r\n    public get renderAtIdealSize(): boolean {\r\n        return this._renderAtIdealSize;\r\n    }\r\n    public set renderAtIdealSize(value: boolean) {\r\n        if (this._renderAtIdealSize === value) {\r\n            return;\r\n        }\r\n        this._renderAtIdealSize = value;\r\n        this._onResize();\r\n    }\r\n\r\n    /**\r\n     * Gets the ratio used when in \"ideal mode\"\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     * */\r\n    public get idealRatio(): number {\r\n        let rwidth: number = 0;\r\n        let rheight: number = 0;\r\n\r\n        if (this._idealWidth) {\r\n            rwidth = this.getSize().width / this._idealWidth;\r\n        }\r\n\r\n        if (this._idealHeight) {\r\n            rheight = this.getSize().height / this._idealHeight;\r\n        }\r\n\r\n        if (this._useSmallestIdeal && this._idealWidth && this._idealHeight) {\r\n            return window.innerWidth < window.innerHeight ? rwidth : rheight;\r\n        }\r\n\r\n        if (this._idealWidth) {\r\n            // horizontal\r\n            return rwidth;\r\n        }\r\n\r\n        if (this._idealHeight) {\r\n            // vertical\r\n            return rheight;\r\n        }\r\n\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Gets the underlying layer used to render the texture when in fullscreen mode\r\n     */\r\n    public get layer(): Nullable<Layer> {\r\n        return this._layerToDispose;\r\n    }\r\n    /**\r\n     * Gets the root container control\r\n     */\r\n    public get rootContainer(): Container {\r\n        return this._rootContainer;\r\n    }\r\n    /**\r\n     * Returns an array containing the root container.\r\n     * This is mostly used to let the Inspector introspects the ADT\r\n     * @returns an array containing the rootContainer\r\n     */\r\n    public getChildren(): Array<Container> {\r\n        return [this._rootContainer];\r\n    }\r\n    /**\r\n     * Will return all controls that are inside this texture\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @returns all child controls\r\n     */\r\n    public getDescendants(directDescendantsOnly?: boolean, predicate?: (control: Control) => boolean): Control[] {\r\n        return this._rootContainer.getDescendants(directDescendantsOnly, predicate);\r\n    }\r\n\r\n    /**\r\n     * Will return all controls with the given type name\r\n     * @param typeName defines the type name to search for\r\n     * @returns an array of all controls found\r\n     */\r\n    public getControlsByType(typeName: string): Control[] {\r\n        return this._rootContainer.getDescendants(false, (control) => control.typeName === typeName);\r\n    }\r\n\r\n    /**\r\n     * Will return the first control with the given name\r\n     * @param name defines the name to search for\r\n     * @returns the first control found or null\r\n     */\r\n    public getControlByName(name: string): Nullable<Control> {\r\n        return this._getControlByKey(\"name\", name);\r\n    }\r\n\r\n    private _getControlByKey(key: string, value: any): Nullable<Control> {\r\n        return this._rootContainer.getDescendants().find((control) => control[key as keyof Control] === value) || null;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current focused control\r\n     */\r\n    public get focusedControl(): Nullable<IFocusableControl> {\r\n        return this._focusedControl;\r\n    }\r\n    public set focusedControl(control: Nullable<IFocusableControl>) {\r\n        if (this._focusedControl == control) {\r\n            return;\r\n        }\r\n        if (this._focusedControl) {\r\n            this._focusedControl.onBlur();\r\n        }\r\n        if (control) {\r\n            control.onFocus();\r\n        }\r\n        this._focusedControl = control;\r\n    }\r\n    /**\r\n     * Gets or sets a boolean indicating if the texture must be rendered in background or foreground when in fullscreen mode\r\n     */\r\n    public get isForeground(): boolean {\r\n        if (!this.layer) {\r\n            return true;\r\n        }\r\n        return !this.layer.isBackground;\r\n    }\r\n    public set isForeground(value: boolean) {\r\n        if (!this.layer) {\r\n            return;\r\n        }\r\n        if (this.layer.isBackground === !value) {\r\n            return;\r\n        }\r\n        this.layer.isBackground = !value;\r\n    }\r\n    /**\r\n     * Gets or set information about clipboardData\r\n     */\r\n    public get clipboardData(): string {\r\n        return this._clipboardData;\r\n    }\r\n    public set clipboardData(value: string) {\r\n        this._clipboardData = value;\r\n    }\r\n\r\n    /**\r\n     * If this is set, even when a control is pointer blocker, some events can still be passed through to the scene.\r\n     * Options from values are PointerEventTypes\r\n     * POINTERDOWN, POINTERUP, POINTERMOVE, POINTERWHEEL, POINTERPICK, POINTERTAP, POINTERDOUBLETAP\r\n     */\r\n    public skipBlockEvents = 0;\r\n\r\n    /**\r\n     * If set to true, every scene render will trigger a pointer event for the GUI\r\n     * if it is linked to a mesh or has controls linked to a mesh. This will allow\r\n     * you to catch the pointer moving around the GUI due to camera or mesh movements,\r\n     * but it has a performance cost.\r\n     */\r\n    public checkPointerEveryFrame = false;\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param scene defines the hosting scene\r\n     * @param generateMipMaps defines a boolean indicating if mipmaps must be generated (false by default)\r\n     * @param samplingMode defines the texture sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)\r\n     */\r\n    constructor(name: string, width = 0, height = 0, scene?: Nullable<Scene>, generateMipMaps = false, samplingMode = Texture.NEAREST_SAMPLINGMODE, invertY = true) {\r\n        super(name, { width: width, height: height }, scene, generateMipMaps, samplingMode, Constants.TEXTUREFORMAT_RGBA, invertY);\r\n        scene = this.getScene();\r\n        if (!scene || !this._texture) {\r\n            return;\r\n        }\r\n        this.applyYInversionOnUpdate = invertY;\r\n        this._rootElement = scene.getEngine().getInputElement();\r\n        this._renderObserver = scene.onBeforeCameraRenderObservable.add((camera: Camera) => this._checkUpdate(camera));\r\n\r\n        /** Whenever a control is added or removed to the root, we have to recheck the camera projection as it can have changed  */\r\n        this._controlAddedObserver = this._rootContainer.onControlAddedObservable.add((control) => {\r\n            if (control) {\r\n                this._rootChildrenHaveChanged = true;\r\n            }\r\n        });\r\n        this._controlRemovedObserver = this._rootContainer.onControlRemovedObservable.add((control) => {\r\n            if (control) {\r\n                this._rootChildrenHaveChanged = true;\r\n            }\r\n        });\r\n        this._preKeyboardObserver = scene.onPreKeyboardObservable.add((info) => {\r\n            if (!this._focusedControl) {\r\n                return;\r\n            }\r\n            if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                this._focusedControl.processKeyboard(info.event);\r\n            }\r\n            info.skipOnPointerObservable = true;\r\n        });\r\n        this._rootContainer._link(this);\r\n        this.hasAlpha = true;\r\n        if (!width || !height) {\r\n            this._resizeObserver = scene.getEngine().onResizeObservable.add(() => this._onResize());\r\n            this._onResize();\r\n        }\r\n        this._texture.isReady = true;\r\n    }\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"AdvancedDynamicTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"AdvancedDynamicTexture\";\r\n    }\r\n    /**\r\n     * Function used to execute a function on all controls\r\n     * @param func defines the function to execute\r\n     * @param container defines the container where controls belong. If null the root container will be used\r\n     */\r\n    public executeOnAllControls(func: (control: Control) => void, container?: Container) {\r\n        if (!container) {\r\n            container = this._rootContainer;\r\n        }\r\n        func(container);\r\n        for (const child of container.children) {\r\n            if ((<any>child).children) {\r\n                this.executeOnAllControls(func, <Container>child);\r\n                continue;\r\n            }\r\n            func(child);\r\n        }\r\n    }\r\n\r\n    private _useInvalidateRectOptimization = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the InvalidateRect optimization should be turned on\r\n     */\r\n    public get useInvalidateRectOptimization(): boolean {\r\n        return this._useInvalidateRectOptimization;\r\n    }\r\n\r\n    public set useInvalidateRectOptimization(value: boolean) {\r\n        this._useInvalidateRectOptimization = value;\r\n    }\r\n\r\n    // Invalidated rectangle which is the combination of all invalidated controls after they have been rotated into absolute position\r\n    private _invalidatedRectangle: Nullable<Measure> = null;\r\n    /**\r\n     * Invalidates a rectangle area on the gui texture\r\n     * @param invalidMinX left most position of the rectangle to invalidate in the texture\r\n     * @param invalidMinY top most position of the rectangle to invalidate in the texture\r\n     * @param invalidMaxX right most position of the rectangle to invalidate in the texture\r\n     * @param invalidMaxY bottom most position of the rectangle to invalidate in the texture\r\n     */\r\n    public invalidateRect(invalidMinX: number, invalidMinY: number, invalidMaxX: number, invalidMaxY: number) {\r\n        if (!this._useInvalidateRectOptimization) {\r\n            return;\r\n        }\r\n        if (!this._invalidatedRectangle) {\r\n            this._invalidatedRectangle = new Measure(invalidMinX, invalidMinY, invalidMaxX - invalidMinX + 1, invalidMaxY - invalidMinY + 1);\r\n        } else {\r\n            // Compute intersection\r\n            const maxX = Math.ceil(Math.max(this._invalidatedRectangle.left + this._invalidatedRectangle.width - 1, invalidMaxX));\r\n            const maxY = Math.ceil(Math.max(this._invalidatedRectangle.top + this._invalidatedRectangle.height - 1, invalidMaxY));\r\n            this._invalidatedRectangle.left = Math.floor(Math.min(this._invalidatedRectangle.left, invalidMinX));\r\n            this._invalidatedRectangle.top = Math.floor(Math.min(this._invalidatedRectangle.top, invalidMinY));\r\n            this._invalidatedRectangle.width = maxX - this._invalidatedRectangle.left + 1;\r\n            this._invalidatedRectangle.height = maxY - this._invalidatedRectangle.top + 1;\r\n        }\r\n    }\r\n    /**\r\n     * Marks the texture as dirty forcing a complete update\r\n     */\r\n    public markAsDirty() {\r\n        this._isDirty = true;\r\n    }\r\n    /**\r\n     * Helper function used to create a new style\r\n     * @returns a new style\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#styles\r\n     */\r\n    public createStyle(): Style {\r\n        return new Style(this);\r\n    }\r\n    /**\r\n     * Adds a new control to the root container\r\n     * @param control defines the control to add\r\n     * @returns the current texture\r\n     */\r\n    public addControl(control: Control): AdvancedDynamicTexture {\r\n        this._rootContainer.addControl(control);\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes a control from the root container\r\n     * @param control defines the control to remove\r\n     * @returns the current texture\r\n     */\r\n    public removeControl(control: Control): AdvancedDynamicTexture {\r\n        this._rootContainer.removeControl(control);\r\n        return this;\r\n    }\r\n    /**\r\n     * Moves overlapped controls towards a position where it is not overlapping anymore.\r\n     * Please note that this method alters linkOffsetXInPixels and linkOffsetYInPixels.\r\n     * @param overlapGroup the overlap group which will be processed or undefined to process all overlap groups\r\n     * @param deltaStep the step size (speed) to reach the target non overlapping position (default 0.1)\r\n     * @param repelFactor how much is the control repelled by other controls\r\n     */\r\n    public moveToNonOverlappedPosition(overlapGroup?: number | Control[], deltaStep = 1, repelFactor = 1) {\r\n        let controlsForGroup: Control[];\r\n        if (Array.isArray(overlapGroup)) {\r\n            controlsForGroup = overlapGroup;\r\n        } else {\r\n            const descendants = this.getDescendants(true);\r\n            // get only the controls with an overlapGroup property set\r\n            // if the overlapGroup parameter is set, filter the controls and get only the controls belonging to that overlapGroup\r\n            controlsForGroup = overlapGroup === undefined ? descendants.filter((c) => c.overlapGroup !== undefined) : descendants.filter((c) => c.overlapGroup === overlapGroup);\r\n        }\r\n\r\n        controlsForGroup.forEach((control1) => {\r\n            let velocity = Vector2.Zero();\r\n            const center = new Vector2(control1.centerX, control1.centerY);\r\n\r\n            controlsForGroup.forEach((control2) => {\r\n                if (control1 !== control2 && AdvancedDynamicTexture._Overlaps(control1, control2)) {\r\n                    // if the two controls overlaps get a direction vector from one control's center to another control's center\r\n                    const diff = center.subtract(new Vector2(control2.centerX, control2.centerY));\r\n                    const diffLength = diff.length();\r\n\r\n                    if (diffLength > 0) {\r\n                        // calculate the velocity\r\n                        velocity = velocity.add(diff.normalize().scale(repelFactor / diffLength));\r\n                    }\r\n                }\r\n            });\r\n\r\n            if (velocity.length() > 0) {\r\n                // move the control along the direction vector away from the overlapping control\r\n                velocity = velocity.normalize().scale(deltaStep * (control1.overlapDeltaMultiplier ?? 1));\r\n                control1.linkOffsetXInPixels += velocity.x;\r\n                control1.linkOffsetYInPixels += velocity.y;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._rootElement = null;\r\n        scene.onBeforeCameraRenderObservable.remove(this._renderObserver);\r\n        if (this._resizeObserver) {\r\n            scene.getEngine().onResizeObservable.remove(this._resizeObserver);\r\n        }\r\n        if (this._prePointerObserver) {\r\n            scene.onPrePointerObservable.remove(this._prePointerObserver);\r\n        }\r\n        if (this._sceneRenderObserver) {\r\n            scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n        }\r\n        if (this._pointerObserver) {\r\n            scene.onPointerObservable.remove(this._pointerObserver);\r\n        }\r\n        if (this._preKeyboardObserver) {\r\n            scene.onPreKeyboardObservable.remove(this._preKeyboardObserver);\r\n        }\r\n        if (this._canvasPointerOutObserver) {\r\n            scene.getEngine().onCanvasPointerOutObservable.remove(this._canvasPointerOutObserver);\r\n        }\r\n        if (this._canvasBlurObserver) {\r\n            scene.getEngine().onCanvasBlurObservable.remove(this._canvasBlurObserver);\r\n        }\r\n        if (this._controlAddedObserver) {\r\n            this._rootContainer.onControlAddedObservable.remove(this._controlAddedObserver);\r\n        }\r\n        if (this._controlRemovedObserver) {\r\n            this._rootContainer.onControlRemovedObservable.remove(this._controlRemovedObserver);\r\n        }\r\n        if (this._layerToDispose) {\r\n            this._layerToDispose.texture = null;\r\n            this._layerToDispose.dispose();\r\n            this._layerToDispose = null;\r\n        }\r\n        this._rootContainer.dispose();\r\n        this.onClipboardObservable.clear();\r\n        this.onControlPickedObservable.clear();\r\n        this.onBeginRenderObservable.clear();\r\n        this.onEndRenderObservable.clear();\r\n        this.onBeginLayoutObservable.clear();\r\n        this.onEndLayoutObservable.clear();\r\n        this.onGuiReadyObservable.clear();\r\n        super.dispose();\r\n    }\r\n    private _onResize(): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        // Check size\r\n        const engine = scene.getEngine();\r\n        const textureSize = this.getSize();\r\n        let renderWidth = engine.getRenderWidth() * this._renderScale;\r\n        let renderHeight = engine.getRenderHeight() * this._renderScale;\r\n\r\n        if (this._renderAtIdealSize) {\r\n            if (this._idealWidth) {\r\n                renderHeight = (renderHeight * this._idealWidth) / renderWidth;\r\n                renderWidth = this._idealWidth;\r\n            } else if (this._idealHeight) {\r\n                renderWidth = (renderWidth * this._idealHeight) / renderHeight;\r\n                renderHeight = this._idealHeight;\r\n            }\r\n        }\r\n        if (textureSize.width !== renderWidth || textureSize.height !== renderHeight) {\r\n            this.scaleTo(renderWidth, renderHeight);\r\n            this.markAsDirty();\r\n            if (this._idealWidth || this._idealHeight) {\r\n                this._rootContainer._markAllAsDirty();\r\n            }\r\n        }\r\n        this.invalidateRect(0, 0, textureSize.width - 1, textureSize.height - 1);\r\n    }\r\n    /** @internal */\r\n    public _getGlobalViewport(): Viewport {\r\n        const size = this.getSize();\r\n        const globalViewPort = this._fullscreenViewport.toGlobal(size.width, size.height);\r\n\r\n        const targetX = Math.round(globalViewPort.width * (1 / this.rootContainer.scaleX));\r\n        const targetY = Math.round(globalViewPort.height * (1 / this.rootContainer.scaleY));\r\n\r\n        globalViewPort.x += (globalViewPort.width - targetX) / 2;\r\n        globalViewPort.y += (globalViewPort.height - targetY) / 2;\r\n\r\n        globalViewPort.width = targetX;\r\n        globalViewPort.height = targetY;\r\n\r\n        return globalViewPort;\r\n    }\r\n    /**\r\n     * Get screen coordinates for a vector3\r\n     * @param position defines the position to project\r\n     * @param worldMatrix defines the world matrix to use\r\n     * @returns the projected position\r\n     */\r\n    public getProjectedPosition(position: Vector3, worldMatrix: Matrix): Vector2 {\r\n        const result = this.getProjectedPositionWithZ(position, worldMatrix);\r\n        return new Vector2(result.x, result.y);\r\n    }\r\n\r\n    /**\r\n     * Get screen coordinates for a vector3\r\n     * @param position defines the position to project\r\n     * @param worldMatrix defines the world matrix to use\r\n     * @returns the projected position with Z\r\n     */\r\n    public getProjectedPositionWithZ(position: Vector3, worldMatrix: Matrix): Vector3 {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return Vector3.Zero();\r\n        }\r\n        const globalViewport = this._getGlobalViewport();\r\n        const projectedPosition = Vector3.Project(position, worldMatrix, scene.getTransformMatrix(), globalViewport);\r\n        return new Vector3(projectedPosition.x, projectedPosition.y, projectedPosition.z);\r\n    }\r\n\r\n    private _checkUpdate(camera: Camera, skipUpdate?: boolean): void {\r\n        if (this._layerToDispose) {\r\n            if ((camera.layerMask & this._layerToDispose.layerMask) === 0) {\r\n                return;\r\n            }\r\n        }\r\n        if (this._isFullscreen && this._linkedControls.length) {\r\n            const scene = this.getScene();\r\n            if (!scene) {\r\n                return;\r\n            }\r\n            const globalViewport = this._getGlobalViewport();\r\n            for (const control of this._linkedControls) {\r\n                if (!control.isVisible) {\r\n                    continue;\r\n                }\r\n                const mesh = control._linkedMesh as AbstractMesh;\r\n                if (!mesh || mesh.isDisposed()) {\r\n                    Tools.SetImmediate(() => {\r\n                        control.linkWithMesh(null);\r\n                    });\r\n                    continue;\r\n                }\r\n                const position = mesh.getBoundingInfo ? mesh.getBoundingInfo().boundingSphere.center : (Vector3.ZeroReadOnly as Vector3);\r\n                const projectedPosition = Vector3.Project(position, mesh.getWorldMatrix(), scene.getTransformMatrix(), globalViewport);\r\n                if (projectedPosition.z < 0 || projectedPosition.z > 1) {\r\n                    control.notRenderable = true;\r\n                    continue;\r\n                }\r\n                control.notRenderable = false;\r\n                if (this.useInvalidateRectOptimization) {\r\n                    control.invalidateRect();\r\n                }\r\n\r\n                control._moveToProjectedPosition(projectedPosition);\r\n            }\r\n        }\r\n        if (!this._isDirty && !this._rootContainer.isDirty) {\r\n            return;\r\n        }\r\n        this._isDirty = false;\r\n        this._render(skipUpdate);\r\n        if (!skipUpdate) {\r\n            this.update(this.applyYInversionOnUpdate, this.premulAlpha, AdvancedDynamicTexture.AllowGPUOptimizations);\r\n        }\r\n    }\r\n\r\n    private _clearMeasure = new Measure(0, 0, 0, 0);\r\n\r\n    private _render(skipRender?: boolean): void {\r\n        const textureSize = this.getSize();\r\n        const renderWidth = textureSize.width;\r\n        const renderHeight = textureSize.height;\r\n\r\n        const context = this.getContext();\r\n        context.font = \"18px Arial\";\r\n        context.strokeStyle = \"white\";\r\n\r\n        if (this.onGuiReadyObservable.hasObservers()) {\r\n            this._checkGuiIsReady();\r\n        }\r\n\r\n        /** We have to recheck the camera projection in the case the root control's children have changed  */\r\n        if (this._rootChildrenHaveChanged) {\r\n            const camera = this.getScene()?.activeCamera;\r\n            if (camera) {\r\n                this._rootChildrenHaveChanged = false;\r\n                this._checkUpdate(camera, true);\r\n            }\r\n        }\r\n\r\n        // Layout\r\n        this.onBeginLayoutObservable.notifyObservers(this);\r\n        const measure = new Measure(0, 0, renderWidth, renderHeight);\r\n        this._numLayoutCalls = 0;\r\n        this._rootContainer._layout(measure, context);\r\n        this.onEndLayoutObservable.notifyObservers(this);\r\n        this._isDirty = false; // Restoring the dirty state that could have been set by controls during layout processing\r\n\r\n        if (skipRender) {\r\n            return;\r\n        }\r\n\r\n        // Clear\r\n        if (this._invalidatedRectangle) {\r\n            this._clearMeasure.copyFrom(this._invalidatedRectangle);\r\n        } else {\r\n            this._clearMeasure.copyFromFloats(0, 0, renderWidth, renderHeight);\r\n        }\r\n        context.clearRect(this._clearMeasure.left, this._clearMeasure.top, this._clearMeasure.width, this._clearMeasure.height);\r\n        if (this._background) {\r\n            context.save();\r\n            context.fillStyle = this._background;\r\n            context.fillRect(this._clearMeasure.left, this._clearMeasure.top, this._clearMeasure.width, this._clearMeasure.height);\r\n            context.restore();\r\n        }\r\n\r\n        // Render\r\n        this.onBeginRenderObservable.notifyObservers(this);\r\n        this._numRenderCalls = 0;\r\n        this._rootContainer._render(context, this._invalidatedRectangle);\r\n        this.onEndRenderObservable.notifyObservers(this);\r\n        this._invalidatedRectangle = null;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _changeCursor(cursor: string) {\r\n        if (this._rootElement) {\r\n            this._rootElement.style.cursor = cursor;\r\n            this._cursorChanged = true;\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _registerLastControlDown(control: Control, pointerId: number) {\r\n        this._lastControlDown[pointerId] = control;\r\n        this.onControlPickedObservable.notifyObservers(control);\r\n    }\r\n    private _doPicking(x: number, y: number, pi: Nullable<PointerInfoBase>, type: number, pointerId: number, buttonIndex: number, deltaX?: number, deltaY?: number): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        const engine = scene.getEngine();\r\n        const textureSize = this.getSize();\r\n        if (this._isFullscreen) {\r\n            const camera = scene.cameraToUseForPointers || scene.activeCamera;\r\n            if (!camera) {\r\n                return;\r\n            }\r\n            const viewport = camera.viewport;\r\n            x = x * (textureSize.width / (engine.getRenderWidth() * viewport.width));\r\n            y = y * (textureSize.height / (engine.getRenderHeight() * viewport.height));\r\n        }\r\n        if (this._capturingControl[pointerId]) {\r\n            if (this._capturingControl[pointerId].isPointerBlocker) {\r\n                this._shouldBlockPointer = true;\r\n            }\r\n            this._capturingControl[pointerId]._processObservables(type, x, y, pi, pointerId, buttonIndex);\r\n            return;\r\n        }\r\n\r\n        this._cursorChanged = false;\r\n        if (!this._rootContainer._processPicking(x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY)) {\r\n            if (!scene.doNotHandleCursors) {\r\n                this._changeCursor(\"\");\r\n            }\r\n            if (type === PointerEventTypes.POINTERMOVE) {\r\n                if (this._lastControlOver[pointerId]) {\r\n                    this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], pi);\r\n                    delete this._lastControlOver[pointerId];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!this._cursorChanged && !scene.doNotHandleCursors) {\r\n            this._changeCursor(\"\");\r\n        }\r\n        this._manageFocus();\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cleanControlAfterRemovalFromList(list: { [pointerId: number]: Control }, control: Control) {\r\n        for (const pointerId in list) {\r\n            if (!Object.prototype.hasOwnProperty.call(list, pointerId)) {\r\n                continue;\r\n            }\r\n            const lastControlOver = list[pointerId];\r\n            if (lastControlOver === control) {\r\n                delete list[pointerId];\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cleanControlAfterRemoval(control: Control) {\r\n        this._cleanControlAfterRemovalFromList(this._lastControlDown, control);\r\n        this._cleanControlAfterRemovalFromList(this._lastControlOver, control);\r\n    }\r\n\r\n    /**\r\n     * This function will run a pointer event on this ADT and will trigger any pointer events on any controls\r\n     * This will work on a fullscreen ADT only. For mesh based ADT, simulate pointer events using the scene directly.\r\n     * @param x pointer X on the canvas for the picking\r\n     * @param y pointer Y on the canvas for the picking\r\n     * @param pi optional pointer information\r\n     */\r\n    public pick(x: number, y: number, pi: Nullable<PointerInfoPre> = null) {\r\n        if (this._isFullscreen && this._scene) {\r\n            this._translateToPicking(this._scene, new Viewport(0, 0, 0, 0), pi, x, y);\r\n        }\r\n    }\r\n\r\n    private _translateToPicking(scene: Scene, tempViewport: Viewport, pi: Nullable<PointerInfoPre>, x: number = scene.pointerX, y: number = scene.pointerY) {\r\n        const camera = scene.cameraToUseForPointers || scene.activeCamera;\r\n        const engine = scene.getEngine();\r\n        const originalCameraToUseForPointers = scene.cameraToUseForPointers;\r\n\r\n        if (!camera) {\r\n            tempViewport.x = 0;\r\n            tempViewport.y = 0;\r\n            tempViewport.width = engine.getRenderWidth();\r\n            tempViewport.height = engine.getRenderHeight();\r\n        } else {\r\n            if (camera.rigCameras.length) {\r\n                // rig camera - we need to find the camera to use for this event\r\n                const rigViewport = new Viewport(0, 0, 1, 1);\r\n                camera.rigCameras.forEach((rigCamera) => {\r\n                    // generate the viewport of this camera\r\n                    rigCamera.viewport.toGlobalToRef(engine.getRenderWidth(), engine.getRenderHeight(), rigViewport);\r\n                    const transformedX = x / engine.getHardwareScalingLevel() - rigViewport.x;\r\n                    const transformedY = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - rigViewport.y - rigViewport.height);\r\n                    // check if the pointer is in the camera's viewport\r\n                    if (transformedX < 0 || transformedY < 0 || x > rigViewport.width || y > rigViewport.height) {\r\n                        // out of viewport - don't use this camera\r\n                        return;\r\n                    }\r\n                    // set the camera to use for pointers until this pointer loop is over\r\n                    scene.cameraToUseForPointers = rigCamera;\r\n                    // set the viewport\r\n                    tempViewport.x = rigViewport.x;\r\n                    tempViewport.y = rigViewport.y;\r\n                    tempViewport.width = rigViewport.width;\r\n                    tempViewport.height = rigViewport.height;\r\n                });\r\n            } else {\r\n                camera.viewport.toGlobalToRef(engine.getRenderWidth(), engine.getRenderHeight(), tempViewport);\r\n            }\r\n        }\r\n\r\n        const transformedX = x / engine.getHardwareScalingLevel() - tempViewport.x;\r\n        const transformedY = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - tempViewport.y - tempViewport.height);\r\n        this._shouldBlockPointer = false;\r\n        // Do picking modifies _shouldBlockPointer\r\n        if (pi) {\r\n            const pointerId = (pi.event as IPointerEvent).pointerId || this._defaultMousePointerId;\r\n            this._doPicking(transformedX, transformedY, pi, pi.type, pointerId, pi.event.button, (<IWheelEvent>pi.event).deltaX, (<IWheelEvent>pi.event).deltaY);\r\n            // Avoid overwriting a true skipOnPointerObservable to false\r\n            if ((this._shouldBlockPointer && !(pi.type & this.skipBlockEvents)) || this._capturingControl[pointerId]) {\r\n                pi.skipOnPointerObservable = true;\r\n            }\r\n        } else {\r\n            this._doPicking(transformedX, transformedY, null, PointerEventTypes.POINTERMOVE, this._defaultMousePointerId, 0);\r\n        }\r\n        // if overridden by a rig camera - reset back to the original value\r\n        scene.cameraToUseForPointers = originalCameraToUseForPointers;\r\n    }\r\n\r\n    /** Attach to all scene events required to support pointer events */\r\n    public attach(): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const tempViewport = new Viewport(0, 0, 0, 0);\r\n\r\n        this._prePointerObserver = scene.onPrePointerObservable.add((pi) => {\r\n            if (\r\n                scene.isPointerCaptured((<IPointerEvent>pi.event).pointerId) &&\r\n                pi.type === PointerEventTypes.POINTERUP &&\r\n                !this._capturedPointerIds.has((pi.event as IPointerEvent).pointerId)\r\n            ) {\r\n                return;\r\n            }\r\n            if (\r\n                pi.type !== PointerEventTypes.POINTERMOVE &&\r\n                pi.type !== PointerEventTypes.POINTERUP &&\r\n                pi.type !== PointerEventTypes.POINTERDOWN &&\r\n                pi.type !== PointerEventTypes.POINTERWHEEL\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (pi.type === PointerEventTypes.POINTERMOVE) {\r\n                // Avoid pointerMove events firing while the pointer is captured by the scene\r\n                if (scene.isPointerCaptured((<IPointerEvent>pi.event).pointerId)) {\r\n                    return;\r\n                }\r\n                if ((pi.event as IPointerEvent).pointerId) {\r\n                    this._defaultMousePointerId = (pi.event as IPointerEvent).pointerId; // This is required to make sure we have the correct pointer ID for wheel\r\n                }\r\n            }\r\n            this._translateToPicking(scene, tempViewport, pi);\r\n        });\r\n        this._attachPickingToSceneRender(scene, () => this._translateToPicking(scene, tempViewport, null), false);\r\n        this._attachToOnPointerOut(scene);\r\n        this._attachToOnBlur(scene);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _onClipboardCopy = (rawEvt: Event) => {\r\n        const evt = rawEvt as ClipboardEvent;\r\n        const ev = new ClipboardInfo(ClipboardEventTypes.COPY, evt);\r\n        this.onClipboardObservable.notifyObservers(ev);\r\n        evt.preventDefault();\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    private _onClipboardCut = (rawEvt: Event) => {\r\n        const evt = rawEvt as ClipboardEvent;\r\n        const ev = new ClipboardInfo(ClipboardEventTypes.CUT, evt);\r\n        this.onClipboardObservable.notifyObservers(ev);\r\n        evt.preventDefault();\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    private _onClipboardPaste = (rawEvt: Event) => {\r\n        const evt = rawEvt as ClipboardEvent;\r\n        const ev = new ClipboardInfo(ClipboardEventTypes.PASTE, evt);\r\n        this.onClipboardObservable.notifyObservers(ev);\r\n        evt.preventDefault();\r\n    };\r\n    /**\r\n     * Register the clipboard Events onto the canvas\r\n     */\r\n    public registerClipboardEvents(): void {\r\n        self.addEventListener(\"copy\", this._onClipboardCopy, false);\r\n        self.addEventListener(\"cut\", this._onClipboardCut, false);\r\n        self.addEventListener(\"paste\", this._onClipboardPaste, false);\r\n    }\r\n    /**\r\n     * Unregister the clipboard Events from the canvas\r\n     */\r\n    public unRegisterClipboardEvents(): void {\r\n        self.removeEventListener(\"copy\", this._onClipboardCopy);\r\n        self.removeEventListener(\"cut\", this._onClipboardCut);\r\n        self.removeEventListener(\"paste\", this._onClipboardPaste);\r\n    }\r\n\r\n    /**\r\n     * Transform uvs from mesh space to texture space, taking the texture into account\r\n     * @param uv the uvs in mesh space\r\n     * @returns the uvs in texture space\r\n     */\r\n    private _transformUvs(uv: Vector2): Vector2 {\r\n        const textureMatrix = this.getTextureMatrix();\r\n        let result;\r\n        if (textureMatrix.isIdentityAs3x2()) {\r\n            result = uv;\r\n        } else {\r\n            const homogeneousTextureMatrix = TmpVectors.Matrix[0];\r\n\r\n            textureMatrix.getRowToRef(0, TmpVectors.Vector4[0]);\r\n            textureMatrix.getRowToRef(1, TmpVectors.Vector4[1]);\r\n            textureMatrix.getRowToRef(2, TmpVectors.Vector4[2]);\r\n\r\n            const r0 = TmpVectors.Vector4[0];\r\n            const r1 = TmpVectors.Vector4[1];\r\n            const r2 = TmpVectors.Vector4[2];\r\n\r\n            homogeneousTextureMatrix.setRowFromFloats(0, r0.x, r0.y, 0, 0);\r\n            homogeneousTextureMatrix.setRowFromFloats(1, r1.x, r1.y, 0, 0);\r\n            homogeneousTextureMatrix.setRowFromFloats(2, 0, 0, 1, 0);\r\n            homogeneousTextureMatrix.setRowFromFloats(3, r2.x, r2.y, 0, 1);\r\n\r\n            result = TmpVectors.Vector2[0];\r\n            Vector2.TransformToRef(uv, homogeneousTextureMatrix, result);\r\n        }\r\n\r\n        // In wrap and mirror mode, the texture coordinate for coordinates more than 1 is the fractional part of the coordinate\r\n        if (this.wrapU === Texture.WRAP_ADDRESSMODE || this.wrapU === Texture.MIRROR_ADDRESSMODE) {\r\n            if (result.x > 1) {\r\n                let fX = result.x - Math.trunc(result.x);\r\n                // In mirror mode, the sign of the texture coordinate depends on the integer part -\r\n                // odd integers means it is mirrored from the original coordinate\r\n                if (this.wrapU === Texture.MIRROR_ADDRESSMODE && Math.trunc(result.x) % 2 === 1) {\r\n                    fX = 1 - fX;\r\n                }\r\n                result.x = fX;\r\n            }\r\n        }\r\n        if (this.wrapV === Texture.WRAP_ADDRESSMODE || this.wrapV === Texture.MIRROR_ADDRESSMODE) {\r\n            if (result.y > 1) {\r\n                let fY = result.y - Math.trunc(result.y);\r\n                if (this.wrapV === Texture.MIRROR_ADDRESSMODE && Math.trunc(result.x) % 2 === 1) {\r\n                    fY = 1 - fY;\r\n                }\r\n                result.y = fY;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Connect the texture to a hosting mesh to enable interactions\r\n     * @param mesh defines the mesh to attach to\r\n     * @param supportPointerMove defines a boolean indicating if pointer move events must be catched as well\r\n     */\r\n    public attachToMesh(mesh: AbstractMesh, supportPointerMove = true): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        if (this._pointerObserver) {\r\n            scene.onPointerObservable.remove(this._pointerObserver);\r\n        }\r\n\r\n        this._pointerObserver = scene.onPointerObservable.add((pi) => {\r\n            if (\r\n                pi.type !== PointerEventTypes.POINTERMOVE &&\r\n                pi.type !== PointerEventTypes.POINTERUP &&\r\n                pi.type !== PointerEventTypes.POINTERDOWN &&\r\n                pi.type !== PointerEventTypes.POINTERWHEEL\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (pi.type === PointerEventTypes.POINTERMOVE && (pi.event as IPointerEvent).pointerId) {\r\n                this._defaultMousePointerId = (pi.event as IPointerEvent).pointerId; // This is required to make sure we have the correct pointer ID for wheel\r\n            }\r\n\r\n            const pointerId = (pi.event as IPointerEvent).pointerId || this._defaultMousePointerId;\r\n            if (pi.pickInfo && pi.pickInfo.hit && pi.pickInfo.pickedMesh === mesh) {\r\n                let uv = pi.pickInfo.getTextureCoordinates();\r\n                if (uv) {\r\n                    uv = this._transformUvs(uv);\r\n                    const size = this.getSize();\r\n                    this._doPicking(\r\n                        uv.x * size.width,\r\n                        (this.applyYInversionOnUpdate ? 1.0 - uv.y : uv.y) * size.height,\r\n                        pi,\r\n                        pi.type,\r\n                        pointerId,\r\n                        pi.event.button,\r\n                        (<IWheelEvent>pi.event).deltaX,\r\n                        (<IWheelEvent>pi.event).deltaY\r\n                    );\r\n                }\r\n            } else if (pi.type === PointerEventTypes.POINTERUP) {\r\n                if (this._lastControlDown[pointerId]) {\r\n                    this._lastControlDown[pointerId]._forcePointerUp(pointerId);\r\n                }\r\n                delete this._lastControlDown[pointerId];\r\n                if (this.focusedControl) {\r\n                    const friendlyControls = this.focusedControl.keepsFocusWith();\r\n                    let canMoveFocus = true;\r\n                    if (friendlyControls) {\r\n                        for (const control of friendlyControls) {\r\n                            // Same host, no need to keep the focus\r\n                            if (this === control._host) {\r\n                                continue;\r\n                            }\r\n                            // Different hosts\r\n                            const otherHost = control._host;\r\n                            if (otherHost._lastControlOver[pointerId] && otherHost._lastControlOver[pointerId].isAscendant(control)) {\r\n                                canMoveFocus = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (canMoveFocus) {\r\n                        this.focusedControl = null;\r\n                    }\r\n                }\r\n            } else if (pi.type === PointerEventTypes.POINTERMOVE) {\r\n                if (this._lastControlOver[pointerId]) {\r\n                    this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], pi, true);\r\n                }\r\n                delete this._lastControlOver[pointerId];\r\n            }\r\n        });\r\n        mesh.enablePointerMoveEvents = supportPointerMove;\r\n        this._attachPickingToSceneRender(\r\n            scene,\r\n            () => {\r\n                const pointerId = this._defaultMousePointerId;\r\n                const pick = scene?.pick(scene.pointerX, scene.pointerY);\r\n                if (pick && pick.hit && pick.pickedMesh === mesh) {\r\n                    let uv = pick.getTextureCoordinates();\r\n                    if (uv) {\r\n                        uv = this._transformUvs(uv);\r\n                        const size = this.getSize();\r\n                        this._doPicking(uv.x * size.width, (this.applyYInversionOnUpdate ? 1.0 - uv.y : uv.y) * size.height, null, PointerEventTypes.POINTERMOVE, pointerId, 0);\r\n                    }\r\n                } else {\r\n                    if (this._lastControlOver[pointerId]) {\r\n                        this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], null, true);\r\n                    }\r\n                    delete this._lastControlOver[pointerId];\r\n                }\r\n            },\r\n            true\r\n        );\r\n        this._attachToOnPointerOut(scene);\r\n        this._attachToOnBlur(scene);\r\n    }\r\n    /**\r\n     * Move the focus to a specific control\r\n     * @param control defines the control which will receive the focus\r\n     */\r\n    public moveFocusToControl(control: IFocusableControl): void {\r\n        this.focusedControl = control;\r\n        this._lastPickedControl = <any>control;\r\n        this._blockNextFocusCheck = true;\r\n    }\r\n    private _manageFocus(): void {\r\n        if (this._blockNextFocusCheck) {\r\n            this._blockNextFocusCheck = false;\r\n            this._lastPickedControl = <any>this._focusedControl;\r\n            return;\r\n        }\r\n        // Focus management\r\n        if (this._focusedControl) {\r\n            if (this._focusedControl !== <any>this._lastPickedControl) {\r\n                if (this._lastPickedControl.isFocusInvisible) {\r\n                    return;\r\n                }\r\n                this.focusedControl = null;\r\n            }\r\n        }\r\n    }\r\n    private _attachPickingToSceneRender(scene: Scene, pickFunction: () => void, forcePicking: boolean) {\r\n        this._sceneRenderObserver = scene.onBeforeRenderObservable.add(() => {\r\n            if (!this.checkPointerEveryFrame) {\r\n                return;\r\n            }\r\n            if (this._linkedControls.length > 0 || forcePicking) {\r\n                pickFunction();\r\n            }\r\n        });\r\n    }\r\n    private _attachToOnPointerOut(scene: Scene): void {\r\n        this._canvasPointerOutObserver = scene.getEngine().onCanvasPointerOutObservable.add((pointerEvent) => {\r\n            if (this._lastControlOver[pointerEvent.pointerId]) {\r\n                this._lastControlOver[pointerEvent.pointerId]._onPointerOut(this._lastControlOver[pointerEvent.pointerId], null);\r\n            }\r\n            delete this._lastControlOver[pointerEvent.pointerId];\r\n            if (this._lastControlDown[pointerEvent.pointerId] && this._lastControlDown[pointerEvent.pointerId] !== this._capturingControl[pointerEvent.pointerId]) {\r\n                this._lastControlDown[pointerEvent.pointerId]._forcePointerUp(pointerEvent.pointerId);\r\n                delete this._lastControlDown[pointerEvent.pointerId];\r\n            }\r\n        });\r\n    }\r\n    private _attachToOnBlur(scene: Scene): void {\r\n        this._canvasBlurObserver = scene.getEngine().onCanvasBlurObservable.add(() => {\r\n            Object.entries(this._lastControlDown).forEach(([, value]) => {\r\n                value._onCanvasBlur();\r\n            });\r\n            this.focusedControl = null;\r\n            this._lastControlDown = {};\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Serializes the entire GUI system\r\n     * @returns an object with the JSON serialized data\r\n     */\r\n    public serializeContent(): any {\r\n        const size = this.getSize();\r\n        const serializationObject = {\r\n            root: {},\r\n            width: size.width,\r\n            height: size.height,\r\n        };\r\n\r\n        this._rootContainer.serialize(serializationObject.root);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a JSON object\r\n     * @param serializedObject define the JSON serialized object to restore from\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     */\r\n    public parseSerializedObject(serializedObject: any, scaleToSize?: boolean) {\r\n        this._rootContainer = Control.Parse(serializedObject.root, this) as Container;\r\n        if (scaleToSize) {\r\n            const width = serializedObject.width;\r\n            const height = serializedObject.height;\r\n            if (typeof width === \"number\" && typeof height === \"number\" && width >= 0 && height >= 0) {\r\n                this.scaleTo(width, height);\r\n            } else {\r\n                // scales the GUI to a default size if none was available in the serialized content\r\n                this.scaleTo(1920, 1080);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the ADT\r\n     * @param newName defines the name of the new ADT\r\n     * @returns the clone of the ADT\r\n     */\r\n    public clone(newName?: string): AdvancedDynamicTexture {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n        const size = this.getSize();\r\n        const data = this.serializeContent();\r\n        const clone = new AdvancedDynamicTexture(newName ?? \"Clone of \" + this.name, size.width, size.height, scene, !this.noMipmap, this.samplingMode);\r\n        clone.parseSerializedObject(data);\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a JSON object\r\n     * @param serializedObject define the JSON serialized object to restore from\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @deprecated Please use parseSerializedObject instead\r\n     */\r\n    public parseContent = this.parseSerializedObject;\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a snippet saved by the GUI editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @param appendToAdt if provided the snippet will be appended to the adt. Otherwise a fullscreen ADT will be created.\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public static async ParseFromSnippetAsync(snippetId: string, scaleToSize?: boolean, appendToAdt?: AdvancedDynamicTexture): Promise<AdvancedDynamicTexture> {\r\n        const adt = appendToAdt ?? AdvancedDynamicTexture.CreateFullscreenUI(\"ADT from snippet\");\r\n        if (snippetId === \"_BLANK\") {\r\n            return adt;\r\n        }\r\n\r\n        const serialized = await AdvancedDynamicTexture._LoadURLContentAsync(AdvancedDynamicTexture.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"), true);\r\n        adt.parseSerializedObject(serialized, scaleToSize);\r\n        return adt;\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a snippet saved by the GUI editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public parseFromSnippetAsync(snippetId: string, scaleToSize?: boolean): Promise<AdvancedDynamicTexture> {\r\n        return AdvancedDynamicTexture.ParseFromSnippetAsync(snippetId, scaleToSize, this);\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a url json\r\n     * @param url defines the url to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @param appendToAdt if provided the snippet will be appended to the adt. Otherwise a fullscreen ADT will be created.\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public static async ParseFromFileAsync(url: string, scaleToSize?: boolean, appendToAdt?: AdvancedDynamicTexture): Promise<AdvancedDynamicTexture> {\r\n        const adt = appendToAdt ?? AdvancedDynamicTexture.CreateFullscreenUI(\"ADT from URL\");\r\n        const serialized = await AdvancedDynamicTexture._LoadURLContentAsync(url);\r\n        adt.parseSerializedObject(serialized, scaleToSize);\r\n        return adt;\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a url json\r\n     * @param url defines the url to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public parseFromURLAsync(url: string, scaleToSize?: boolean): Promise<AdvancedDynamicTexture> {\r\n        return AdvancedDynamicTexture.ParseFromFileAsync(url, scaleToSize, this);\r\n    }\r\n\r\n    private static _LoadURLContentAsync(url: string, snippet: boolean = false): Promise<any> {\r\n        if (url === \"\") {\r\n            return Promise.reject(\"No URL provided\");\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        let gui;\r\n                        if (snippet) {\r\n                            const payload = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                            gui = payload.encodedGui ? new TextDecoder(\"utf-8\").decode(DecodeBase64ToBinary(payload.encodedGui)) : payload.gui;\r\n                        } else {\r\n                            gui = request.responseText;\r\n                        }\r\n                        const serializationObject = JSON.parse(gui);\r\n                        resolve(serializationObject);\r\n                    } else {\r\n                        reject(\"Unable to load\");\r\n                    }\r\n                }\r\n            });\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Compares two rectangle based controls for pixel overlap\r\n     * @param control1 The first control to compare\r\n     * @param control2 The second control to compare\r\n     * @returns true if overlaps, otherwise false\r\n     */\r\n    private static _Overlaps(control1: Control, control2: Control) {\r\n        return !(\r\n            control1.centerX > control2.centerX + control2.widthInPixels ||\r\n            control1.centerX + control1.widthInPixels < control2.centerX ||\r\n            control1.centerY + control1.heightInPixels < control2.centerY ||\r\n            control1.centerY > control2.centerY + control2.heightInPixels\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture in projected mode (ie. attached to a mesh)\r\n     * @param mesh defines the mesh which will receive the texture\r\n     * @param width defines the texture width (1024 by default)\r\n     * @param height defines the texture height (1024 by default)\r\n     * @param supportPointerMove defines a boolean indicating if the texture must capture move events (true by default)\r\n     * @param onlyAlphaTesting defines a boolean indicating that alpha blending will not be used (only alpha testing) (false by default)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)\r\n     * @param materialSetupCallback defines a custom way of creating and setting up the material on the mesh\r\n     * @returns a new AdvancedDynamicTexture\r\n     */\r\n    public static CreateForMesh(\r\n        mesh: AbstractMesh,\r\n        width = 1024,\r\n        height = 1024,\r\n        supportPointerMove = true,\r\n        onlyAlphaTesting = false,\r\n        invertY?: boolean,\r\n        materialSetupCallback: (mesh: AbstractMesh, uniqueId: string, texture: AdvancedDynamicTexture, onlyAlphaTesting: boolean) => void = this._CreateMaterial\r\n    ): AdvancedDynamicTexture {\r\n        // use a unique ID in name so serialization will work even if you create two ADTs for a single mesh\r\n        const uniqueId = RandomGUID();\r\n        const result = new AdvancedDynamicTexture(\r\n            `AdvancedDynamicTexture for ${mesh.name} [${uniqueId}]`,\r\n            width,\r\n            height,\r\n            mesh.getScene(),\r\n            true,\r\n            Texture.TRILINEAR_SAMPLINGMODE,\r\n            invertY\r\n        );\r\n\r\n        materialSetupCallback(mesh, uniqueId, result, onlyAlphaTesting);\r\n\r\n        result.attachToMesh(mesh, supportPointerMove);\r\n        return result;\r\n    }\r\n\r\n    private static _CreateMaterial(mesh: AbstractMesh, uniqueId: string, texture: AdvancedDynamicTexture, onlyAlphaTesting: boolean): void {\r\n        const internalClassType = GetClass(\"BABYLON.StandardMaterial\");\r\n        if (!internalClassType) {\r\n            throw \"StandardMaterial needs to be imported before as it contains a side-effect required by your code.\";\r\n        }\r\n\r\n        const material: StandardMaterial = new internalClassType(`AdvancedDynamicTextureMaterial for ${mesh.name} [${uniqueId}]`, mesh.getScene());\r\n        material.backFaceCulling = false;\r\n        material.diffuseColor = Color3.Black();\r\n        material.specularColor = Color3.Black();\r\n        if (onlyAlphaTesting) {\r\n            material.diffuseTexture = texture;\r\n            material.emissiveTexture = texture;\r\n            texture.hasAlpha = true;\r\n        } else {\r\n            material.emissiveTexture = texture;\r\n            material.opacityTexture = texture;\r\n        }\r\n        mesh.material = material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture in projected mode (ie. attached to a mesh) BUT do not create a new material for the mesh. You will be responsible for connecting the texture\r\n     * @param mesh defines the mesh which will receive the texture\r\n     * @param width defines the texture width (1024 by default)\r\n     * @param height defines the texture height (1024 by default)\r\n     * @param supportPointerMove defines a boolean indicating if the texture must capture move events (true by default)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)\r\n     * @returns a new AdvancedDynamicTexture\r\n     */\r\n    public static CreateForMeshTexture(mesh: AbstractMesh, width = 1024, height = 1024, supportPointerMove = true, invertY?: boolean): AdvancedDynamicTexture {\r\n        const result = new AdvancedDynamicTexture(mesh.name + \" AdvancedDynamicTexture\", width, height, mesh.getScene(), true, Texture.TRILINEAR_SAMPLINGMODE, invertY);\r\n        result.attachToMesh(mesh, supportPointerMove);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture in fullscreen mode.\r\n     * In this mode the texture will rely on a layer for its rendering.\r\n     * This allows it to be treated like any other layer.\r\n     * As such, if you have a multi camera setup, you can set the layerMask on the GUI as well.\r\n     * LayerMask is set through advancedTexture.layer.layerMask\r\n     * @param name defines name for the texture\r\n     * @param foreground defines a boolean indicating if the texture must be rendered in foreground (default is true)\r\n     * @param scene defines the hosting scene\r\n     * @param sampling defines the texture sampling mode (Texture.BILINEAR_SAMPLINGMODE by default)\r\n     * @param adaptiveScaling defines whether to automatically scale root to match hardwarescaling (false by default)\r\n     * @returns a new AdvancedDynamicTexture\r\n     */\r\n    public static CreateFullscreenUI(\r\n        name: string,\r\n        foreground: boolean = true,\r\n        scene: Nullable<Scene> = null,\r\n        sampling = Texture.BILINEAR_SAMPLINGMODE,\r\n        adaptiveScaling: boolean = false\r\n    ): AdvancedDynamicTexture {\r\n        const result = new AdvancedDynamicTexture(name, 0, 0, scene, false, sampling);\r\n        // Display\r\n        const resultScene = result.getScene();\r\n        const layer = new Layer(name + \"_layer\", null, resultScene, !foreground);\r\n        layer.texture = result;\r\n        result._layerToDispose = layer;\r\n        result._isFullscreen = true;\r\n\r\n        if (adaptiveScaling && resultScene) {\r\n            const newScale = 1 / resultScene.getEngine().getHardwareScalingLevel();\r\n            result._rootContainer.scaleX = newScale;\r\n            result._rootContainer.scaleY = newScale;\r\n        }\r\n\r\n        // Attach\r\n        result.attach();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public scale(ratio: number): void {\r\n        super.scale(ratio);\r\n        this.markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public scaleTo(width: number, height: number): void {\r\n        super.scaleTo(width, height);\r\n        this.markAsDirty();\r\n    }\r\n\r\n    private _checkGuiIsReady() {\r\n        if (this.guiIsReady()) {\r\n            this.onGuiReadyObservable.notifyObservers(this);\r\n\r\n            this.onGuiReadyObservable.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if all the GUI components are ready to render\r\n     */\r\n    public guiIsReady(): boolean {\r\n        return this._rootContainer.isReady();\r\n    }\r\n}\r\n"]}