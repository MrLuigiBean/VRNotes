{"version":3,"file":"gizmo.js","sourceRoot":"","sources":["../../../../dev/core/src/Gizmos/gizmo.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { Quaternion, Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport type { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport type { Node } from \"../node\";\r\nimport type { Bone } from \"../Bones/bone\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { LinesMesh } from \"../Meshes/linesMesh\";\r\nimport type { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\r\nimport type { ShadowLight } from \"../Lights/shadowLight\";\r\nimport { Light } from \"../Lights/light\";\r\n\r\n/**\r\n * Cache built by each axis. Used for managing state between all elements of gizmo for enhanced UI\r\n */\r\nexport interface GizmoAxisCache {\r\n    /** Mesh used to render the Gizmo */\r\n    gizmoMeshes: Mesh[];\r\n    /** Mesh used to detect user interaction with Gizmo */\r\n    colliderMeshes: Mesh[];\r\n    /** Material used to indicate color of gizmo mesh */\r\n    material: StandardMaterial;\r\n    /** Material used to indicate hover state of the Gizmo */\r\n    hoverMaterial: StandardMaterial;\r\n    /** Material used to indicate disabled state of the Gizmo */\r\n    disableMaterial: StandardMaterial;\r\n    /** Used to indicate Active state of the Gizmo */\r\n    active: boolean;\r\n    /** DragBehavior */\r\n    dragBehavior: PointerDragBehavior;\r\n}\r\n\r\n/**\r\n * Anchor options where the Gizmo can be positioned in relation to its anchored node\r\n */\r\nexport enum GizmoAnchorPoint {\r\n    /** The origin of the attached node */\r\n    Origin,\r\n    /** The pivot point of the attached node*/\r\n    Pivot,\r\n}\r\n\r\n/**\r\n * Coordinates mode: Local or World. Defines how axis is aligned: either on world axis or transform local axis\r\n */\r\nexport enum GizmoCoordinatesMode {\r\n    World,\r\n    Local,\r\n}\r\n\r\n/**\r\n * Interface for basic gizmo\r\n */\r\nexport interface IGizmo extends IDisposable {\r\n    /** True when the mouse pointer is hovered a gizmo mesh */\r\n    readonly isHovered: boolean;\r\n    /** The root mesh of the gizmo */\r\n    _rootMesh: Mesh;\r\n    /** Ratio for the scale of the gizmo */\r\n    scaleRatio: number;\r\n    /**\r\n     * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    attachedMesh: Nullable<AbstractMesh>;\r\n    /**\r\n     * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    attachedNode: Nullable<Node>;\r\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    updateGizmoRotationToMatchAttachedMesh: boolean;\r\n    /** The utility layer the gizmo will be added to */\r\n    gizmoLayer: UtilityLayerRenderer;\r\n    /**\r\n     * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    updateGizmoPositionToMatchAttachedMesh: boolean;\r\n    /**\r\n     * Defines where the gizmo will be positioned if `updateGizmoPositionToMatchAttachedMesh` is enabled.\r\n     * (Default: GizmoAnchorPoint.Origin)\r\n     */\r\n    anchorPoint: GizmoAnchorPoint;\r\n\r\n    /**\r\n     * Set the coordinate mode to use. By default it's local.\r\n     */\r\n    coordinatesMode: GizmoCoordinatesMode;\r\n\r\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\r\n    updateScale: boolean;\r\n    /**\r\n     * posture that the gizmo will be display\r\n     * When set null, default value will be used (Quaternion(0, 0, 0, 1))\r\n     */\r\n    customRotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * Disposes and replaces the current meshes in the gizmo with the specified mesh\r\n     * @param mesh The mesh to replace the default mesh of the gizmo\r\n     */\r\n    setCustomMesh(mesh: Mesh): void;\r\n}\r\n/**\r\n * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.\r\n */\r\nexport class Gizmo implements IGizmo {\r\n    /**\r\n     * The root mesh of the gizmo\r\n     */\r\n    public _rootMesh: Mesh;\r\n    protected _attachedMesh: Nullable<AbstractMesh> = null;\r\n    protected _attachedNode: Nullable<Node> = null;\r\n    protected _customRotationQuaternion: Nullable<Quaternion> = null;\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    protected _scaleRatio = 1;\r\n\r\n    /**\r\n     * boolean updated by pointermove when a gizmo mesh is hovered\r\n     */\r\n    protected _isHovered = false;\r\n\r\n    /**\r\n     * When enabled, any gizmo operation will perserve scaling sign. Default is off.\r\n     * Only valid for TransformNode derived classes (Mesh, AbstractMesh, ...)\r\n     */\r\n    public static PreserveScaling = false;\r\n\r\n    /**\r\n     * There are 2 ways to preserve scaling: using mesh scaling or absolute scaling. Depending of hierarchy, non uniform scaling and LH or RH coordinates. One is preferable than the other.\r\n     * If the scaling to be preserved is the local scaling, then set this value to false.\r\n     * Default is true which means scaling to be preserved is absolute one (with hierarchy applied)\r\n     */\r\n    public static UseAbsoluteScaling = true;\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    public set scaleRatio(value: number) {\r\n        this._scaleRatio = value;\r\n    }\r\n\r\n    public get scaleRatio() {\r\n        return this._scaleRatio;\r\n    }\r\n\r\n    /**\r\n     * True when the mouse pointer is hovered a gizmo mesh\r\n     */\r\n    public get isHovered() {\r\n        return this._isHovered;\r\n    }\r\n\r\n    /**\r\n     * If a custom mesh has been set (Default: false)\r\n     */\r\n    protected _customMeshSet = false;\r\n    /**\r\n     * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    public get attachedMesh() {\r\n        return this._attachedMesh;\r\n    }\r\n    public set attachedMesh(value) {\r\n        this._attachedMesh = value;\r\n        if (value) {\r\n            this._attachedNode = value;\r\n        }\r\n        this._rootMesh.setEnabled(value ? true : false);\r\n        this._attachedNodeChanged(value);\r\n    }\r\n    /**\r\n     * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    public get attachedNode() {\r\n        return this._attachedNode;\r\n    }\r\n    public set attachedNode(value) {\r\n        this._attachedNode = value;\r\n        this._attachedMesh = null;\r\n        this._rootMesh.setEnabled(value ? true : false);\r\n        this._attachedNodeChanged(value);\r\n    }\r\n\r\n    /**\r\n     * Disposes and replaces the current meshes in the gizmo with the specified mesh\r\n     * @param mesh The mesh to replace the default mesh of the gizmo\r\n     */\r\n    public setCustomMesh(mesh: Mesh) {\r\n        if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {\r\n            throw \"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)\";\r\n        }\r\n        this._rootMesh.getChildMeshes().forEach((c) => {\r\n            c.dispose();\r\n        });\r\n        mesh.parent = this._rootMesh;\r\n        this._customMeshSet = true;\r\n    }\r\n\r\n    protected _updateGizmoRotationToMatchAttachedMesh = true;\r\n    protected _updateGizmoPositionToMatchAttachedMesh = true;\r\n    protected _anchorPoint = GizmoAnchorPoint.Origin;\r\n    protected _updateScale = true;\r\n    protected _coordinatesMode = GizmoCoordinatesMode.Local;\r\n\r\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation\r\n     */\r\n    public set updateGizmoRotationToMatchAttachedMesh(value: boolean) {\r\n        this._updateGizmoRotationToMatchAttachedMesh = value;\r\n    }\r\n    public get updateGizmoRotationToMatchAttachedMesh() {\r\n        return this._updateGizmoRotationToMatchAttachedMesh;\r\n    }\r\n    /**\r\n     * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    public set updateGizmoPositionToMatchAttachedMesh(value: boolean) {\r\n        this._updateGizmoPositionToMatchAttachedMesh = value;\r\n    }\r\n    public get updateGizmoPositionToMatchAttachedMesh() {\r\n        return this._updateGizmoPositionToMatchAttachedMesh;\r\n    }\r\n\r\n    /**\r\n     * Defines where the gizmo will be positioned if `updateGizmoPositionToMatchAttachedMesh` is enabled.\r\n     * (Default: GizmoAnchorPoint.Origin)\r\n     */\r\n    public set anchorPoint(value: GizmoAnchorPoint) {\r\n        this._anchorPoint = value;\r\n    }\r\n    public get anchorPoint() {\r\n        return this._anchorPoint;\r\n    }\r\n\r\n    /**\r\n     * Set the coordinate system to use. By default it's local.\r\n     * But it's possible for a user to tweak so its local for translation and world for rotation.\r\n     * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`\r\n     */\r\n    public set coordinatesMode(coordinatesMode: GizmoCoordinatesMode) {\r\n        this._coordinatesMode = coordinatesMode;\r\n        const local = coordinatesMode == GizmoCoordinatesMode.Local;\r\n        this.updateGizmoRotationToMatchAttachedMesh = local;\r\n        this.updateGizmoPositionToMatchAttachedMesh = true;\r\n    }\r\n\r\n    public get coordinatesMode() {\r\n        return this._coordinatesMode;\r\n    }\r\n\r\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\r\n\r\n    public set updateScale(value: boolean) {\r\n        this._updateScale = value;\r\n    }\r\n    public get updateScale() {\r\n        return this._updateScale;\r\n    }\r\n    protected _interactionsEnabled = true;\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _attachedNodeChanged(value: Nullable<Node>) {}\r\n\r\n    protected _beforeRenderObserver: Nullable<Observer<Scene>>;\r\n    private _rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);\r\n\r\n    /**\r\n     * Creates a gizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     */\r\n    constructor(\r\n        /** The utility layer the gizmo will be added to */\r\n        public gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer\r\n    ) {\r\n        this._rootMesh = new Mesh(\"gizmoRootNode\", gizmoLayer.utilityLayerScene);\r\n        this._rootMesh.rotationQuaternion = Quaternion.Identity();\r\n\r\n        this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(() => {\r\n            this._update();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * posture that the gizmo will be display\r\n     * When set null, default value will be used (Quaternion(0, 0, 0, 1))\r\n     */\r\n    public get customRotationQuaternion(): Nullable<Quaternion> {\r\n        return this._customRotationQuaternion;\r\n    }\r\n\r\n    public set customRotationQuaternion(customRotationQuaternion: Nullable<Quaternion>) {\r\n        this._customRotationQuaternion = customRotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Updates the gizmo to match the attached mesh's position/rotation\r\n     */\r\n    protected _update() {\r\n        if (this.attachedNode) {\r\n            let effectiveNode = this.attachedNode;\r\n            if (this.attachedMesh) {\r\n                effectiveNode = this.attachedMesh || this.attachedNode;\r\n            }\r\n\r\n            // Position\r\n            if (this.updateGizmoPositionToMatchAttachedMesh) {\r\n                if (this.anchorPoint == GizmoAnchorPoint.Pivot && (<TransformNode>effectiveNode).getAbsolutePivotPoint) {\r\n                    const position = (<TransformNode>effectiveNode).getAbsolutePivotPoint();\r\n                    this._rootMesh.position.copyFrom(position);\r\n                } else {\r\n                    const row = effectiveNode.getWorldMatrix().getRow(3);\r\n                    const position = row ? row.toVector3() : new Vector3(0, 0, 0);\r\n                    this._rootMesh.position.copyFrom(position);\r\n                }\r\n            }\r\n\r\n            // Rotation\r\n            if (this.updateGizmoRotationToMatchAttachedMesh) {\r\n                const supportedNode =\r\n                    (<Mesh>effectiveNode)._isMesh ||\r\n                    effectiveNode.getClassName() === \"AbstractMesh\" ||\r\n                    effectiveNode.getClassName() === \"TransformNode\" ||\r\n                    effectiveNode.getClassName() === \"InstancedMesh\";\r\n                const transformNode = supportedNode ? (effectiveNode as TransformNode) : undefined;\r\n                effectiveNode.getWorldMatrix().decompose(undefined, this._rootMesh.rotationQuaternion!, undefined, Gizmo.PreserveScaling ? transformNode : undefined);\r\n                this._rootMesh.rotationQuaternion!.normalize();\r\n            } else {\r\n                if (this._customRotationQuaternion) {\r\n                    this._rootMesh.rotationQuaternion!.copyFrom(this._customRotationQuaternion);\r\n                } else {\r\n                    this._rootMesh.rotationQuaternion!.set(0, 0, 0, 1);\r\n                }\r\n            }\r\n\r\n            // Scale\r\n            if (this.updateScale) {\r\n                const activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera!;\r\n                const cameraPosition = activeCamera.globalPosition;\r\n                this._rootMesh.position.subtractToRef(cameraPosition, TmpVectors.Vector3[0]);\r\n                let scale = this.scaleRatio;\r\n                if (activeCamera.mode == Camera.ORTHOGRAPHIC_CAMERA) {\r\n                    if (activeCamera.orthoTop && activeCamera.orthoBottom) {\r\n                        const orthoHeight = activeCamera.orthoTop - activeCamera.orthoBottom;\r\n                        scale *= orthoHeight;\r\n                    }\r\n                } else {\r\n                    const camForward = activeCamera.getScene().useRightHandedSystem ? Vector3.RightHandedForwardReadOnly : Vector3.LeftHandedForwardReadOnly;\r\n                    const direction = activeCamera.getDirection(camForward);\r\n                    scale *= Vector3.Dot(TmpVectors.Vector3[0], direction);\r\n                }\r\n                this._rootMesh.scaling.setAll(scale);\r\n\r\n                // Account for handedness, similar to Matrix.decompose\r\n                if (effectiveNode._getWorldMatrixDeterminant() < 0 && !Gizmo.PreserveScaling) {\r\n                    this._rootMesh.scaling.y *= -1;\r\n                }\r\n            } else {\r\n                this._rootMesh.scaling.setAll(this.scaleRatio);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * if transform has a pivot and is not using PostMultiplyPivotMatrix, then the worldMatrix contains the pivot matrix (it's not cancelled at the end)\r\n     * so, when extracting the world matrix component, the translation (and other components) is containing the pivot translation.\r\n     * And the pivot is applied each frame. Removing it anyway here makes it applied only in computeWorldMatrix.\r\n     * @param transform local transform that needs to be transform by the pivot inverse matrix\r\n     * @param localMatrix local matrix that needs to be transform by the pivot inverse matrix\r\n     * @param result resulting matrix transformed by pivot inverse if the transform node is using pivot without using post Multiply Pivot Matrix\r\n     */\r\n    protected _handlePivotMatrixInverse(transform: TransformNode, localMatrix: Matrix, result: Matrix): void {\r\n        if (transform.isUsingPivotMatrix() && !transform.isUsingPostMultiplyPivotMatrix()) {\r\n            transform.getPivotMatrix().invertToRef(TmpVectors.Matrix[5]);\r\n            TmpVectors.Matrix[5].multiplyToRef(localMatrix, result);\r\n            return;\r\n        }\r\n        result.copyFrom(localMatrix);\r\n    }\r\n    /**\r\n     * computes the rotation/scaling/position of the transform once the Node world matrix has changed.\r\n     */\r\n    protected _matrixChanged() {\r\n        if (!this._attachedNode) {\r\n            return;\r\n        }\r\n\r\n        if ((<Camera>this._attachedNode)._isCamera) {\r\n            const camera = this._attachedNode as Camera;\r\n            let worldMatrix;\r\n            let worldMatrixUC;\r\n            if (camera.parent) {\r\n                const parentInv = TmpVectors.Matrix[1];\r\n                camera.parent._worldMatrix.invertToRef(parentInv);\r\n                this._attachedNode._worldMatrix.multiplyToRef(parentInv, TmpVectors.Matrix[0]);\r\n                worldMatrix = TmpVectors.Matrix[0];\r\n            } else {\r\n                worldMatrix = this._attachedNode._worldMatrix;\r\n            }\r\n\r\n            if (camera.getScene().useRightHandedSystem) {\r\n                // avoid desync with RH matrix computation. Otherwise, rotation of PI around Y axis happens each frame resulting in axis flipped because worldMatrix is computed as inverse of viewMatrix.\r\n                this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, TmpVectors.Matrix[1]);\r\n                worldMatrixUC = TmpVectors.Matrix[1];\r\n            } else {\r\n                worldMatrixUC = worldMatrix;\r\n            }\r\n\r\n            worldMatrixUC.decompose(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\r\n\r\n            const inheritsTargetCamera =\r\n                this._attachedNode.getClassName() === \"FreeCamera\" ||\r\n                this._attachedNode.getClassName() === \"FlyCamera\" ||\r\n                this._attachedNode.getClassName() === \"ArcFollowCamera\" ||\r\n                this._attachedNode.getClassName() === \"TargetCamera\" ||\r\n                this._attachedNode.getClassName() === \"TouchCamera\" ||\r\n                this._attachedNode.getClassName() === \"UniversalCamera\";\r\n\r\n            if (inheritsTargetCamera) {\r\n                const targetCamera = this._attachedNode as TargetCamera;\r\n                targetCamera.rotation = TmpVectors.Quaternion[0].toEulerAngles();\r\n\r\n                if (targetCamera.rotationQuaternion) {\r\n                    targetCamera.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);\r\n                    targetCamera.rotationQuaternion.normalize();\r\n                }\r\n            }\r\n\r\n            camera.position.copyFrom(TmpVectors.Vector3[0]);\r\n        } else if (\r\n            (<Mesh>this._attachedNode)._isMesh ||\r\n            this._attachedNode.getClassName() === \"AbstractMesh\" ||\r\n            this._attachedNode.getClassName() === \"TransformNode\" ||\r\n            this._attachedNode.getClassName() === \"InstancedMesh\"\r\n        ) {\r\n            const transform = this._attachedNode as TransformNode;\r\n            if (transform.parent) {\r\n                const parentInv = TmpVectors.Matrix[0];\r\n                const localMat = TmpVectors.Matrix[1];\r\n                transform.parent.getWorldMatrix().invertToRef(parentInv);\r\n                this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);\r\n                const matrixToDecompose = TmpVectors.Matrix[4];\r\n                this._handlePivotMatrixInverse(transform, localMat, matrixToDecompose);\r\n                matrixToDecompose.decompose(\r\n                    TmpVectors.Vector3[0],\r\n                    TmpVectors.Quaternion[0],\r\n                    transform.position,\r\n                    Gizmo.PreserveScaling ? transform : undefined,\r\n                    Gizmo.UseAbsoluteScaling\r\n                );\r\n                TmpVectors.Quaternion[0].normalize();\r\n                if (transform.isUsingPivotMatrix()) {\r\n                    // Calculate the local matrix without the translation.\r\n                    // Copied from TranslateNode.computeWorldMatrix\r\n                    const r = TmpVectors.Quaternion[1];\r\n                    Quaternion.RotationYawPitchRollToRef(transform.rotation.y, transform.rotation.x, transform.rotation.z, r);\r\n\r\n                    const scaleMatrix = TmpVectors.Matrix[2];\r\n                    Matrix.ScalingToRef(transform.scaling.x, transform.scaling.y, transform.scaling.z, scaleMatrix);\r\n\r\n                    const rotationMatrix = TmpVectors.Matrix[2];\r\n                    r.toRotationMatrix(rotationMatrix);\r\n\r\n                    const pivotMatrix = transform.getPivotMatrix();\r\n                    const invPivotMatrix = TmpVectors.Matrix[3];\r\n                    pivotMatrix.invertToRef(invPivotMatrix);\r\n\r\n                    pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);\r\n                    TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, TmpVectors.Matrix[5]);\r\n                    TmpVectors.Matrix[5].multiplyToRef(invPivotMatrix, TmpVectors.Matrix[6]);\r\n\r\n                    TmpVectors.Matrix[6].getTranslationToRef(TmpVectors.Vector3[1]);\r\n\r\n                    transform.position.subtractInPlace(TmpVectors.Vector3[1]);\r\n                }\r\n            } else {\r\n                const matrixToDecompose = TmpVectors.Matrix[4];\r\n                this._handlePivotMatrixInverse(transform, this._attachedNode._worldMatrix, matrixToDecompose);\r\n                matrixToDecompose.decompose(\r\n                    TmpVectors.Vector3[0],\r\n                    TmpVectors.Quaternion[0],\r\n                    transform.position,\r\n                    Gizmo.PreserveScaling ? transform : undefined,\r\n                    Gizmo.UseAbsoluteScaling\r\n                );\r\n            }\r\n            TmpVectors.Vector3[0].scaleInPlace(1.0 / transform.scalingDeterminant);\r\n            transform.scaling.copyFrom(TmpVectors.Vector3[0]);\r\n            if (!transform.billboardMode) {\r\n                if (transform.rotationQuaternion) {\r\n                    transform.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);\r\n                    transform.rotationQuaternion.normalize();\r\n                } else {\r\n                    transform.rotation = TmpVectors.Quaternion[0].toEulerAngles();\r\n                }\r\n            }\r\n        } else if (this._attachedNode.getClassName() === \"Bone\") {\r\n            const bone = this._attachedNode as Bone;\r\n            const parent = bone.getParent();\r\n\r\n            if (parent) {\r\n                const invParent = TmpVectors.Matrix[0];\r\n                const boneLocalMatrix = TmpVectors.Matrix[1];\r\n                parent.getFinalMatrix().invertToRef(invParent);\r\n                bone.getFinalMatrix().multiplyToRef(invParent, boneLocalMatrix);\r\n                const lmat = bone.getLocalMatrix();\r\n                lmat.copyFrom(boneLocalMatrix);\r\n            } else {\r\n                const lmat = bone.getLocalMatrix();\r\n                lmat.copyFrom(bone.getFinalMatrix());\r\n            }\r\n            bone.markAsDirty();\r\n        } else {\r\n            const light = this._attachedNode as ShadowLight;\r\n            if (light.getTypeID) {\r\n                const type = light.getTypeID();\r\n                if (type === Light.LIGHTTYPEID_DIRECTIONALLIGHT || type === Light.LIGHTTYPEID_SPOTLIGHT || type === Light.LIGHTTYPEID_POINTLIGHT) {\r\n                    const parent = light.parent;\r\n\r\n                    if (parent) {\r\n                        const invParent = TmpVectors.Matrix[0];\r\n                        const nodeLocalMatrix = TmpVectors.Matrix[1];\r\n                        parent.getWorldMatrix().invertToRef(invParent);\r\n                        light.getWorldMatrix().multiplyToRef(invParent, nodeLocalMatrix);\r\n                        nodeLocalMatrix.decompose(undefined, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\r\n                    } else {\r\n                        this._attachedNode._worldMatrix.decompose(undefined, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\r\n                    }\r\n                    // setter doesn't copy values. Need a new Vector3\r\n                    light.position = new Vector3(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z);\r\n                    if (light.direction) {\r\n                        light.direction = new Vector3(light.direction.x, light.direction.y, light.direction.z);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * refresh gizmo mesh material\r\n     * @param gizmoMeshes\r\n     * @param material material to apply\r\n     */\r\n    protected _setGizmoMeshMaterial(gizmoMeshes: Mesh[], material: StandardMaterial) {\r\n        if (gizmoMeshes) {\r\n            gizmoMeshes.forEach((m: Mesh) => {\r\n                m.material = material;\r\n                if ((<LinesMesh>m).color) {\r\n                    (<LinesMesh>m).color = material.diffuseColor;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\r\n     * @returns {Observer<PointerInfo>} pointerObserver\r\n     */\r\n    public static GizmoAxisPointerObserver(gizmoLayer: UtilityLayerRenderer, gizmoAxisCache: Map<Mesh, GizmoAxisCache>): Observer<PointerInfo> {\r\n        let dragging = false;\r\n\r\n        const pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (pointerInfo.pickInfo) {\r\n                // On Hover Logic\r\n                if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (dragging) {\r\n                        return;\r\n                    }\r\n                    gizmoAxisCache.forEach((cache) => {\r\n                        if (cache.colliderMeshes && cache.gizmoMeshes) {\r\n                            const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh as Mesh) != -1;\r\n                            const material = cache.dragBehavior.enabled ? (isHovered || cache.active ? cache.hoverMaterial : cache.material) : cache.disableMaterial;\r\n                            cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                                m.material = material;\r\n                                if ((m as LinesMesh).color) {\r\n                                    (m as LinesMesh).color = material.diffuseColor;\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n\r\n                // On Mouse Down\r\n                if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If user Clicked Gizmo\r\n                    if (gizmoAxisCache.has(pointerInfo.pickInfo.pickedMesh?.parent as Mesh)) {\r\n                        dragging = true;\r\n                        const statusMap = gizmoAxisCache.get(pointerInfo.pickInfo.pickedMesh?.parent as Mesh);\r\n                        statusMap!.active = true;\r\n                        gizmoAxisCache.forEach((cache) => {\r\n                            const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh as Mesh) != -1;\r\n                            const material = (isHovered || cache.active) && cache.dragBehavior.enabled ? cache.hoverMaterial : cache.disableMaterial;\r\n                            cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                                m.material = material;\r\n                                if ((m as LinesMesh).color) {\r\n                                    (m as LinesMesh).color = material.diffuseColor;\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // On Mouse Up\r\n                if (pointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                    gizmoAxisCache.forEach((cache) => {\r\n                        cache.active = false;\r\n                        dragging = false;\r\n                        cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                            m.material = cache.dragBehavior.enabled ? cache.material : cache.disableMaterial;\r\n                            if ((m as LinesMesh).color) {\r\n                                (m as LinesMesh).color = cache.material.diffuseColor;\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n        });\r\n\r\n        return pointerObserver!;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this._rootMesh.dispose();\r\n        if (this._beforeRenderObserver) {\r\n            this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\r\n        }\r\n    }\r\n}\r\n"]}