{"version":3,"file":"engine.computeShader.js","sourceRoot":"","sources":["../../../../../dev/core/src/Engines/Extensions/engine.computeShader.ts"],"names":[],"mappings":"AAIA,OAAO,EAAE,UAAU,EAAE,MAAM,0BAA0B,CAAC;AAgBtD,gBAAgB;AAChB,MAAM,CAAN,IAAY,kBAQX;AARD,WAAY,kBAAkB;IAC1B,iEAAW,CAAA;IACX,+EAAkB,CAAA;IAClB,6EAAiB,CAAA;IACjB,6EAAiB,CAAA;IACjB,6FAAyB,CAAA;IACzB,iEAAW,CAAA;IACX,iFAAmB,CAAA;AACvB,CAAC,EARW,kBAAkB,KAAlB,kBAAkB,QAQ7B;AAmFD,UAAU,CAAC,SAAS,CAAC,mBAAmB,GAAG,UAAU,QAAa,EAAE,OAAsC;IACtG,MAAM,IAAI,KAAK,CAAC,oEAAoE,CAAC,CAAC;AAC1F,CAAC,CAAC;AAEF,UAAU,CAAC,SAAS,CAAC,4BAA4B,GAAG;IAChD,MAAM,IAAI,KAAK,CAAC,6EAA6E,CAAC,CAAC;AACnG,CAAC,CAAC;AAEF,UAAU,CAAC,SAAS,CAAC,oBAAoB,GAAG;IACxC,OAAO,SAAS,CAAC;AACrB,CAAC,CAAC;AAEF,UAAU,CAAC,SAAS,CAAC,eAAe,GAAG,UACnC,MAAqB,EACrB,OAAwB,EACxB,QAA4B,EAC5B,CAAS,EACT,CAAU,EACV,CAAU,EACV,eAAuC;IAEvC,MAAM,IAAI,KAAK,CAAC,gEAAgE,CAAC,CAAC;AACtF,CAAC,CAAC;AAEF,UAAU,CAAC,SAAS,CAAC,yBAAyB,GAAG;IAC7C,OAAO,IAAI,CAAC;AAChB,CAAC,CAAC;AAEF,UAAU,CAAC,SAAS,CAAC,qBAAqB,GAAG,cAAmB,CAAC,CAAC;AAElE,UAAU,CAAC,SAAS,CAAC,8BAA8B,GAAG,UAClD,eAAwC,EACxC,iBAAyB,EACzB,oBAA4B,EAC5B,OAAyB,EACzB,UAAkB,IACb,CAAC,CAAC;AAEX,UAAU,CAAC,SAAS,CAAC,sBAAsB,GAAG,cAAmB,CAAC,CAAC;AAEnE,UAAU,CAAC,SAAS,CAAC,kCAAkC,GAAG,UAAU,eAAwC,EAAE,MAAkB;IAC5H,MAAM,EAAE,CAAC;AACb,CAAC,CAAC;AAEF,UAAU,CAAC,SAAS,CAAC,qBAAqB,GAAG,UAAU,MAAqB,IAAS,CAAC,CAAC;AAEvF,UAAU,CAAC,SAAS,CAAC,6BAA6B,GAAG,UAAU,eAAwC,IAAS,CAAC,CAAC","sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { ComputeEffect, IComputeEffectCreationOptions } from \"../../Compute/computeEffect\";\r\nimport type { IComputeContext } from \"../../Compute/IComputeContext\";\r\nimport type { IComputePipelineContext } from \"../../Compute/IComputePipelineContext\";\r\nimport { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebGPUPerfCounter } from \"../WebGPU/webgpuPerfCounter\";\r\n\r\n/**\r\n * Type used to locate a resource in a compute shader.\r\n * TODO: remove this when browsers support reflection for wgsl shaders\r\n */\r\nexport type ComputeBindingLocation = { group: number; binding: number };\r\n\r\n/**\r\n * Type used to lookup a resource and retrieve its binding location\r\n * TODO: remove this when browsers support reflection for wgsl shaders\r\n */\r\nexport type ComputeBindingMapping = { [key: string]: ComputeBindingLocation };\r\n\r\n/** @internal */\r\nexport enum ComputeBindingType {\r\n    Texture = 0,\r\n    StorageTexture = 1,\r\n    UniformBuffer = 2,\r\n    StorageBuffer = 3,\r\n    TextureWithoutSampler = 4,\r\n    Sampler = 5,\r\n    ExternalTexture = 6,\r\n}\r\n\r\n/** @internal */\r\nexport type ComputeBindingList = { [key: string]: { type: ComputeBindingType; object: any; indexInGroupEntries?: number } };\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a new compute effect\r\n         * @param baseName Name of the effect\r\n         * @param options Options used to create the effect\r\n         * @returns The new compute effect\r\n         */\r\n        createComputeEffect(baseName: any, options: IComputeEffectCreationOptions): ComputeEffect;\r\n\r\n        /**\r\n         * Creates a new compute pipeline context\r\n         * @returns the new pipeline\r\n         */\r\n        createComputePipelineContext(): IComputePipelineContext;\r\n\r\n        /**\r\n         * Creates a new compute context\r\n         * @returns the new context\r\n         */\r\n        createComputeContext(): IComputeContext | undefined;\r\n\r\n        /**\r\n         * Dispatches a compute shader\r\n         * @param effect The compute effect\r\n         * @param context The compute context\r\n         * @param bindings The list of resources to bind to the shader\r\n         * @param x The number of workgroups to execute on the X dimension\r\n         * @param y The number of workgroups to execute on the Y dimension\r\n         * @param z The number of workgroups to execute on the Z dimension\r\n         * @param bindingsMapping list of bindings mapping (key is property name, value is binding location)\r\n         * @param gpuPerfCounter GPU time computed for the compute shader will be assigned to this object\r\n         */\r\n        computeDispatch(\r\n            effect: ComputeEffect,\r\n            context: IComputeContext,\r\n            bindings: ComputeBindingList,\r\n            x: number,\r\n            y?: number,\r\n            z?: number,\r\n            bindingsMapping?: ComputeBindingMapping,\r\n            gpuPerfCounter?: WebGPUPerfCounter\r\n        ): void;\r\n\r\n        /**\r\n         * Gets a boolean indicating if all created compute effects are ready\r\n         * @returns true if all effects are ready\r\n         */\r\n        areAllComputeEffectsReady(): boolean;\r\n\r\n        /**\r\n         * Forces the engine to release all cached compute effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n         */\r\n        releaseComputeEffects(): void;\r\n\r\n        /** @internal */\r\n        _prepareComputePipelineContext(\r\n            pipelineContext: IComputePipelineContext,\r\n            computeSourceCode: string,\r\n            rawComputeSourceCode: string,\r\n            defines: Nullable<string>,\r\n            entryPoint: string\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _rebuildComputeEffects(): void;\r\n\r\n        /** @internal */\r\n        _executeWhenComputeStateIsCompiled(pipelineContext: IComputePipelineContext, action: () => void): void;\r\n\r\n        /** @internal */\r\n        _releaseComputeEffect(effect: ComputeEffect): void;\r\n\r\n        /** @internal */\r\n        _deleteComputePipelineContext(pipelineContext: IComputePipelineContext): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createComputeEffect = function (baseName: any, options: IComputeEffectCreationOptions): ComputeEffect {\r\n    throw new Error(\"createComputeEffect: This engine does not support compute shaders!\");\r\n};\r\n\r\nThinEngine.prototype.createComputePipelineContext = function (): IComputePipelineContext {\r\n    throw new Error(\"createComputePipelineContext: This engine does not support compute shaders!\");\r\n};\r\n\r\nThinEngine.prototype.createComputeContext = function (): IComputeContext | undefined {\r\n    return undefined;\r\n};\r\n\r\nThinEngine.prototype.computeDispatch = function (\r\n    effect: ComputeEffect,\r\n    context: IComputeContext,\r\n    bindings: ComputeBindingList,\r\n    x: number,\r\n    y?: number,\r\n    z?: number,\r\n    bindingsMapping?: ComputeBindingMapping\r\n): void {\r\n    throw new Error(\"computeDispatch: This engine does not support compute shaders!\");\r\n};\r\n\r\nThinEngine.prototype.areAllComputeEffectsReady = function (): boolean {\r\n    return true;\r\n};\r\n\r\nThinEngine.prototype.releaseComputeEffects = function (): void {};\r\n\r\nThinEngine.prototype._prepareComputePipelineContext = function (\r\n    pipelineContext: IComputePipelineContext,\r\n    computeSourceCode: string,\r\n    rawComputeSourceCode: string,\r\n    defines: Nullable<string>,\r\n    entryPoint: string\r\n): void {};\r\n\r\nThinEngine.prototype._rebuildComputeEffects = function (): void {};\r\n\r\nThinEngine.prototype._executeWhenComputeStateIsCompiled = function (pipelineContext: IComputePipelineContext, action: () => void): void {\r\n    action();\r\n};\r\n\r\nThinEngine.prototype._releaseComputeEffect = function (effect: ComputeEffect): void {};\r\n\r\nThinEngine.prototype._deleteComputePipelineContext = function (pipelineContext: IComputePipelineContext): void {};\r\n"]}