{"version":3,"file":"customProceduralTexture.js","sourceRoot":"","sources":["../../../../../../dev/core/src/Materials/Textures/Procedurals/customProceduralTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"../../../Misc/logger\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { Vector3, Vector2 } from \"../../../Maths/math.vector\";\r\nimport { Color4, Color3 } from \"../../../Maths/math.color\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport type { IProceduralTextureCreationOptions } from \"./proceduralTexture\";\r\nimport { ProceduralTexture } from \"./proceduralTexture\";\r\nimport { WebRequest } from \"../../../Misc/webRequest\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\n\r\n/**\r\n * Options to create a Custom Procedural Texture.\r\n */\r\nexport interface ICustomProceduralTextureCreationOptions extends IProceduralTextureCreationOptions {\r\n    /**\r\n     * Define a boolena indicating that there is no json config file to load\r\n     */\r\n    skipJson?: boolean;\r\n}\r\n\r\n/**\r\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n * Custom Procedural textures are the easiest way to create your own procedural in your application.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures#creating-custom-procedural-textures\r\n */\r\nexport class CustomProceduralTexture extends ProceduralTexture {\r\n    private _animate: boolean = true;\r\n    private _time: number = 0;\r\n    private _config: any;\r\n    private _texturePath: string;\r\n\r\n    /**\r\n     * Instantiates a new Custom Procedural Texture.\r\n     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n     * Custom Procedural textures are the easiest way to create your own procedural in your application.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures#creating-custom-procedural-textures\r\n     * @param name Define the name of the texture\r\n     * @param texturePath Define the folder path containing all the custom texture related files (config, shaders...)\r\n     * @param size Define the size of the texture to create\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\r\n     * @param generateMipMaps Define if the texture should creates mip maps or not\r\n     * @param skipJson Define a boolena indicating that there is no json config file to load\r\n     */\r\n    constructor(\r\n        name: string,\r\n        texturePath: string,\r\n        size: TextureSize,\r\n        scene: Scene,\r\n        fallbackTexture?: Texture | ICustomProceduralTextureCreationOptions,\r\n        generateMipMaps?: boolean,\r\n        skipJson?: boolean\r\n    ) {\r\n        super(name, size, null, scene, fallbackTexture, generateMipMaps);\r\n        this._texturePath = texturePath;\r\n\r\n        if (fallbackTexture && !(fallbackTexture instanceof Texture)) {\r\n            skipJson = !!fallbackTexture.skipJson;\r\n        }\r\n\r\n        if (!skipJson) {\r\n            //Try to load json\r\n            this._loadJson(texturePath);\r\n        } else {\r\n            this.setFragment(this._texturePath);\r\n        }\r\n        this.refreshRate = 1;\r\n    }\r\n\r\n    private _loadJson(jsonUrl: string): void {\r\n        const noConfigFile = () => {\r\n            try {\r\n                this.setFragment(this._texturePath);\r\n            } catch (ex) {\r\n                Logger.Log(\"No json or ShaderStore or DOM element found for CustomProceduralTexture\");\r\n            }\r\n        };\r\n\r\n        const configFileUrl = jsonUrl + \"/config.json\";\r\n        const xhr = new WebRequest();\r\n\r\n        xhr.open(\"GET\", configFileUrl);\r\n        xhr.addEventListener(\r\n            \"load\",\r\n            () => {\r\n                if (xhr.status === 200 || (xhr.responseText && xhr.responseText.length > 0)) {\r\n                    try {\r\n                        this._config = JSON.parse(xhr.response);\r\n\r\n                        this.updateShaderUniforms();\r\n                        this.updateTextures();\r\n                        this.setFragment(this._texturePath + \"/custom\");\r\n\r\n                        this._animate = this._config.animate;\r\n                        this.refreshRate = this._config.refreshrate;\r\n                    } catch (ex) {\r\n                        noConfigFile();\r\n                    }\r\n                } else {\r\n                    noConfigFile();\r\n                }\r\n            },\r\n            false\r\n        );\r\n\r\n        xhr.addEventListener(\r\n            \"error\",\r\n            () => {\r\n                noConfigFile();\r\n            },\r\n            false\r\n        );\r\n\r\n        try {\r\n            xhr.send();\r\n        } catch (ex) {\r\n            Logger.Error(\"CustomProceduralTexture: Error on XHR send request.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Is the texture ready to be used ? (rendered at least once)\r\n     * @returns true if ready, otherwise, false.\r\n     */\r\n    public isReady(): boolean {\r\n        if (!super.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        for (const name in this._textures) {\r\n            const texture = this._textures[name];\r\n\r\n            if (!texture.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Render the texture to its associated render target.\r\n     * @param useCameraPostProcess Define if camera post process should be applied to the texture\r\n     */\r\n    public render(useCameraPostProcess?: boolean): void {\r\n        const scene = this.getScene();\r\n        if (this._animate && scene) {\r\n            this._time += scene.getAnimationRatio() * 0.03;\r\n            this.updateShaderUniforms();\r\n        }\r\n\r\n        super.render(useCameraPostProcess);\r\n    }\r\n\r\n    /**\r\n     * Update the list of dependant textures samplers in the shader.\r\n     */\r\n    public updateTextures(): void {\r\n        for (let i = 0; i < this._config.sampler2Ds.length; i++) {\r\n            this.setTexture(this._config.sampler2Ds[i].sample2Dname, new Texture(this._texturePath + \"/\" + this._config.sampler2Ds[i].textureRelativeUrl, this.getScene()));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the uniform values of the procedural texture in the shader.\r\n     */\r\n    public updateShaderUniforms(): void {\r\n        if (this._config) {\r\n            for (let j = 0; j < this._config.uniforms.length; j++) {\r\n                const uniform = this._config.uniforms[j];\r\n\r\n                switch (uniform.type) {\r\n                    case \"float\":\r\n                        this.setFloat(uniform.name, uniform.value);\r\n                        break;\r\n                    case \"color3\":\r\n                        this.setColor3(uniform.name, new Color3(uniform.r, uniform.g, uniform.b));\r\n                        break;\r\n                    case \"color4\":\r\n                        this.setColor4(uniform.name, new Color4(uniform.r, uniform.g, uniform.b, uniform.a));\r\n                        break;\r\n                    case \"vector2\":\r\n                        this.setVector2(uniform.name, new Vector2(uniform.x, uniform.y));\r\n                        break;\r\n                    case \"vector3\":\r\n                        this.setVector3(uniform.name, new Vector3(uniform.x, uniform.y, uniform.z));\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setFloat(\"time\", this._time);\r\n    }\r\n\r\n    /**\r\n     * Define if the texture animates or not.\r\n     */\r\n    public get animate(): boolean {\r\n        return this._animate;\r\n    }\r\n\r\n    public set animate(value: boolean) {\r\n        this._animate = value;\r\n    }\r\n}\r\n"]}