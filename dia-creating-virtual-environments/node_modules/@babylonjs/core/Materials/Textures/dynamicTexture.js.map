{"version":3,"file":"dynamicTexture.js","sourceRoot":"","sources":["../../../../../dev/core/src/Materials/Textures/dynamicTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ISize } from \"../../Maths/math.size\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"../../Engines/ICanvas\";\r\n\r\n/**\r\n * A class extending Texture allowing drawing on a texture\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/dynamicTexture\r\n */\r\nexport class DynamicTexture extends Texture {\r\n    private _generateMipMaps: boolean;\r\n    private _canvas: ICanvas;\r\n    private _ownCanvas: boolean;\r\n    private _context: ICanvasRenderingContext;\r\n\r\n    /**\r\n     * Creates a DynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n     * @param scene defines the scene where you want the texture\r\n     * @param generateMipMaps defines the use of MinMaps or not (default is false)\r\n     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     */\r\n\r\n    constructor(\r\n        name: string,\r\n        options: any,\r\n        scene: Nullable<Scene> = null,\r\n        generateMipMaps: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        invertY?: boolean\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY, samplingMode, undefined, undefined, undefined, undefined, format);\r\n\r\n        this.name = name;\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        if (options.getContext) {\r\n            this._canvas = options;\r\n            this._ownCanvas = false;\r\n            this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n        } else {\r\n            this._canvas = engine.createCanvas(1, 1);\r\n            this._ownCanvas = true;\r\n\r\n            if (options.width || options.width === 0) {\r\n                this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n            } else {\r\n                this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);\r\n            }\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n\r\n        if (this._canvas.width !== textureSize.width) {\r\n            this._canvas.width = textureSize.width;\r\n        }\r\n        if (this._canvas.height !== textureSize.height) {\r\n            this._canvas.height = textureSize.height;\r\n        }\r\n        this._context = this._canvas.getContext(\"2d\");\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"DynamicTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"DynamicTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the current state of canRescale\r\n     */\r\n    public get canRescale(): boolean {\r\n        return true;\r\n    }\r\n\r\n    private _recreate(textureSize: ISize): void {\r\n        this._canvas.width = textureSize.width;\r\n        this._canvas.height = textureSize.height;\r\n\r\n        this.releaseInternalTexture();\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public scale(ratio: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width *= ratio;\r\n        textureSize.height *= ratio;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public scaleTo(width: number, height: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width = width;\r\n        textureSize.height = height;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Gets the context of the canvas used by the texture\r\n     * @returns the canvas context of the dynamic texture\r\n     */\r\n    public getContext(): ICanvasRenderingContext {\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * Clears the texture\r\n     * @param clearColor Defines the clear color to use\r\n     */\r\n    public clear(clearColor?: string): void {\r\n        const size = this.getSize();\r\n        if (clearColor) {\r\n            this._context.fillStyle = clearColor;\r\n        }\r\n        this._context.clearRect(0, 0, size.width, size.height);\r\n    }\r\n\r\n    /**\r\n     * Updates the texture\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\r\n     * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n     */\r\n    public update(invertY?: boolean, premulAlpha = false, allowGPUOptimization = false): void {\r\n        this._getEngine()!.updateDynamicTexture(\r\n            this._texture,\r\n            this._canvas,\r\n            invertY === undefined ? true : invertY,\r\n            premulAlpha,\r\n            this._format || undefined,\r\n            undefined,\r\n            allowGPUOptimization\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Draws text onto the texture\r\n     * @param text defines the text to be drawn\r\n     * @param x defines the placement of the text from the left\r\n     * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\r\n     * @param font defines the font to be used with font-style, font-size, font-name\r\n     * @param color defines the color used for the text\r\n     * @param fillColor defines the color for the canvas, use null to not overwrite canvas (this bleands with the background to replace, use the clear function)\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param update defines whether texture is immediately update (default is true)\r\n     */\r\n    public drawText(\r\n        text: string,\r\n        x: number | null | undefined,\r\n        y: number | null | undefined,\r\n        font: string,\r\n        color: string | null,\r\n        fillColor: string | null,\r\n        invertY?: boolean,\r\n        update = true\r\n    ) {\r\n        const size = this.getSize();\r\n        if (fillColor) {\r\n            this._context.fillStyle = fillColor;\r\n            this._context.fillRect(0, 0, size.width, size.height);\r\n        }\r\n\r\n        this._context.font = font;\r\n        if (x === null || x === undefined) {\r\n            const textSize = this._context.measureText(text);\r\n            x = (size.width - textSize.width) / 2;\r\n        }\r\n        if (y === null || y === undefined) {\r\n            const fontSize = parseInt(font.replace(/\\D/g, \"\"));\r\n            y = size.height / 2 + fontSize / 3.65;\r\n        }\r\n\r\n        this._context.fillStyle = color || \"\";\r\n        this._context.fillText(text, x, y);\r\n\r\n        if (update) {\r\n            this.update(invertY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the dynamic texture.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        if (this._ownCanvas) {\r\n            this._canvas?.remove();\r\n        }\r\n        (this._canvas as any) = null;\r\n        (this._context as any) = null;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture\r\n     * @returns the clone of the texture.\r\n     */\r\n    public clone(): DynamicTexture {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n        const newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // Dynamic Texture\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\r\n     * @returns a serialized dynamic texture object\r\n     */\r\n    public serialize(): any {\r\n        const scene = this.getScene();\r\n        if (scene && !scene.isReady()) {\r\n            Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n        if (DynamicTexture._IsCanvasElement(this._canvas)) {\r\n            serializationObject.base64String = this._canvas.toDataURL();\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private static _IsCanvasElement(canvas: HTMLCanvasElement | OffscreenCanvas | ICanvas): canvas is HTMLCanvasElement {\r\n        return (canvas as HTMLCanvasElement).toDataURL !== undefined;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this.update();\r\n    }\r\n}\r\n"]}