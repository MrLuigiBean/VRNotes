import type { ShadowLight } from "../Lights/shadowLight.js";
import type { UniformBuffer } from "../Materials/uniformBuffer.js";
import { Matrix } from "../Maths/math.vector.js";
import type { AbstractMesh } from "../Meshes/abstractMesh.js";
import type { Scene } from "../scene.js";
import { MaterialPluginBase } from "../Materials/materialPluginBase.js";
import type { Material } from "../Materials/material.js";
import type { StandardMaterial } from "../Materials/standardMaterial.js";
import { MaterialDefines } from "../Materials/materialDefines.js";
import { PBRBaseMaterial } from "../Materials/PBR/pbrBaseMaterial.js";
/**
 * Class used to generate the RSM (Reflective Shadow Map) textures for a given light.
 * The textures are: position (in world space), normal (in world space) and flux (light intensity)
 */
export declare class ReflectiveShadowMap {
    private _scene;
    private _light;
    private _lightTransformMatrix;
    private _mrt;
    private _textureDimensions;
    private _regularMatToMatWithPlugin;
    private _counters;
    private _enable;
    /**
     * Enables or disables the RSM generation.
     */
    get enable(): boolean;
    set enable(value: boolean);
    /**
     * Gets the position texture generated by the RSM process.
     */
    get positionWorldTexture(): import("..").Texture;
    /**
     * Gets the normal texture generated by the RSM process.
     */
    get normalWorldTexture(): import("..").Texture;
    /**
     * Gets the flux texture generated by the RSM process.
     */
    get fluxTexture(): import("..").Texture;
    /**
     * Gets the render list used to generate the RSM textures.
     */
    get renderList(): import("..").Nullable<AbstractMesh[]>;
    /**
     * Gets the light used to generate the RSM textures.
     */
    get light(): ShadowLight;
    /**
     * Gets or sets a boolean indicating if the light parameters should be recomputed even if the light parameters (position, direction) did not change.
     * You should not set this value to true, except for debugging purpose (if you want to see changes from the inspector, for eg).
     * Instead, you should call updateLightParameters() explicitely at the right time (once the light parameters changed).
     */
    forceUpdateLightParameters: boolean;
    /**
     * Creates a new RSM for the given light.
     * @param scene The scene
     * @param light The light to use to generate the RSM textures
     * @param textureDimensions The dimensions of the textures to generate. Default: \{ width: 512, height: 512 \}
     */
    constructor(scene: Scene, light: ShadowLight, textureDimensions?: {
        width: number;
        height: number;
    });
    /**
     * Sets the dimensions of the textures to generate.
     * @param dimensions The dimensions of the textures to generate.
     */
    setTextureDimensions(dimensions: {
        width: number;
        height: number;
    }): void;
    /**
     * Adds the given mesh to the render list used to generate the RSM textures.
     * @param mesh The mesh to add to the render list used to generate the RSM textures. If not provided, all scene meshes will be added to the render list.
     */
    addMesh(mesh?: AbstractMesh): void;
    /**
     * Recomputes the light transformation matrix. Call this method if you manually changed the light position / direction / etc. and you want to update the RSM textures accordingly.
     */
    updateLightParameters(): void;
    /**
     * Gets the light transformation matrix used to generate the RSM textures.
     */
    get lightTransformationMatrix(): Matrix;
    /**
     * Gets the GPU time spent to generate the RSM textures.
     */
    get countersGPU(): Array<{
        name: string;
        value: number;
    }>;
    /**
     * Disposes the RSM.
     */
    dispose(): void;
    protected _createMultiRenderTarget(): void;
    protected _customRenderTarget(add: boolean): void;
    protected _recomputeLightTransformationMatrix(): void;
    protected _addMeshToMRT(mesh: AbstractMesh): void;
    protected _disposeMultiRenderTarget(): void;
}
/**
 * @internal
 */
declare class MaterialRSMCreateDefines extends MaterialDefines {
    RSMCREATE: boolean;
    RSMCREATE_PROJTEXTURE: boolean;
    RSMCREATE_LIGHT_IS_SPOT: boolean;
}
/**
 * Plugin that implements the creation of the RSM textures
 */
export declare class RSMCreatePluginMaterial extends MaterialPluginBase {
    private _varAlbedoName;
    private _lightColor;
    private _hasProjectionTexture;
    /**
     * Defines the name of the plugin.
     */
    static readonly Name = "RSMCreate";
    /**
     * Defines the light that should be used to generate the RSM textures.
     */
    light: ShadowLight;
    private _isEnabled;
    /**
     * Defines if the plugin is enabled in the material.
     */
    isEnabled: boolean;
    protected _markAllSubMeshesAsTexturesDirty(): void;
    private _internalMarkAllSubMeshesAsTexturesDirty;
    /**
     * Create a new RSMCreatePluginMaterial
     * @param material Parent material of the plugin
     */
    constructor(material: Material | StandardMaterial | PBRBaseMaterial);
    prepareDefines(defines: MaterialRSMCreateDefines): void;
    getClassName(): string;
    getUniforms(): {
        ubo: {
            name: string;
            size: number;
            type: string;
        }[];
        fragment: string;
    };
    getSamplers(samplers: string[]): void;
    bindForSubMesh(uniformBuffer: UniformBuffer): void;
    getCustomCode(shaderType: string): {
        CUSTOM_FRAGMENT_BEGIN: string;
        CUSTOM_FRAGMENT_DEFINITIONS: string;
        CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: string;
    } | null;
}
export {};
