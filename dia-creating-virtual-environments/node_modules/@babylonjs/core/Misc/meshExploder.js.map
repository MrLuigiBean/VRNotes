{"version":3,"file":"meshExploder.js","sourceRoot":"","sources":["../../../../dev/core/src/Misc/meshExploder.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,OAAO,EAAE,MAAM,sBAAsB,CAAC;AAE/C;;GAEG;AACH,MAAM,OAAO,YAAY;IASrB;;;;OAIG;IACH,YAAY,MAAmB,EAAE,UAAiB;QAX1C,mBAAc,GAAmB,EAAE,CAAC;QACpC,qBAAgB,GAAmB,EAAE,CAAC;QACtC,qBAAgB,GAAG,IAAI,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QACxC,iBAAY,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC;QAC9B,oBAAe,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC;QAQrC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC;QAE9B,IAAI,UAAU,EAAE;YACZ,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC;SACjC;aAAM;YACH,IAAI,CAAC,cAAc,EAAE,CAAC;SACzB;QACD,IAAI,CAAC,WAAW,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;QAE1C,MAAM,eAAe,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC/D,IAAI,eAAe,IAAI,CAAC,EAAE;YACtB,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,eAAe,EAAE,CAAC,CAAC,CAAC;SAC3C;QACD,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,WAAW,CAAC,mBAAmB,EAAE,CAAC,KAAK,EAAE,CAAC;QACtE,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;YACtD,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;gBACrB,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;gBACjC,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC,KAAK,EAAE,CAAC;gBAChE,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC;gBAC9C,IAAI,IAAI,CAAC,eAAe,IAAI,IAAI,CAAC,WAAW,CAAC,eAAe,EAAE;oBAC1D,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;oBAC9B,IAAI,CAAC,eAAe,EAAE,CAAC,WAAW,CAAC,WAAW,CAAC,aAAa,CAAC,IAAI,CAAC,WAAW,CAAC,eAAe,EAAE,CAAC,WAAW,CAAC,WAAW,EAAE,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC,CAAC;iBAC1J;aACJ;SACJ;IACL,CAAC;IAEO,cAAc;QAClB,IAAI,aAAa,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC;QACnC,MAAM,YAAY,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC;QACpC,IAAI,gBAAgB,GAAG,MAAM,CAAC,SAAS,CAAC;QACxC,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;YACtD,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;gBACrB,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;gBACjC,MAAM,YAAY,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;gBAC5C,IAAI,YAAY,EAAE;oBACd,YAAY,CAAC,UAAU,CAAC,YAAY,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;iBACjE;aACJ;SACJ;QACD,aAAa,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QAC5D,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;YACtD,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;gBACrB,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;gBACjC,MAAM,YAAY,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;gBAC5C,IAAI,YAAY,EAAE;oBACd,MAAM,gBAAgB,GAAG,YAAY,CAAC,WAAW,CAAC,WAAW,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC,aAAa,EAAE,CAAC;oBACtG,IAAI,gBAAgB,GAAG,gBAAgB,EAAE;wBACrC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;wBACxB,gBAAgB,GAAG,gBAAgB,CAAC;qBACvC;iBACJ;aACJ;SACJ;IACL,CAAC;IAED;;;OAGG;IACI,YAAY;QACf,OAAO,cAAc,CAAC;IAC1B,CAAC;IAED;;;OAGG;IACI,SAAS;QACZ,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;QACvC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACpC,OAAO,SAAS,CAAC;IACrB,CAAC;IAED;;;OAGG;IACI,OAAO,CAAC,YAAoB,GAAG;QAClC,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;YACtD,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,EAAE;gBACnF,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC,UAAU,CAAC,SAAS,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;gBAC1E,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;gBAC9E,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,mBAAmB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;aAC9D;SACJ;QACD,IAAI,CAAC,WAAW,CAAC,mBAAmB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;IAC/D,CAAC;CACJ","sourcesContent":["import type { Mesh } from \"../Meshes/mesh\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\n\r\n/**\r\n * Class used to explode meshes (ie. to have a center and move them away from that center to better see the overall organization)\r\n */\r\nexport class MeshExploder {\r\n    private _centerMesh: Mesh;\r\n    private _meshes: Array<Mesh>;\r\n    private _meshesOrigins: Array<Vector3> = [];\r\n    private _toCenterVectors: Array<Vector3> = [];\r\n    private _scaledDirection = new Vector3(1, 1, 1);\r\n    private _newPosition = Vector3.Zero();\r\n    private _centerPosition = Vector3.Zero();\r\n\r\n    /**\r\n     * Explodes meshes from a center mesh.\r\n     * @param meshes The meshes to explode.\r\n     * @param centerMesh The mesh to be center of explosion.\r\n     */\r\n    constructor(meshes: Array<Mesh>, centerMesh?: Mesh) {\r\n        this._meshes = meshes.slice();\r\n\r\n        if (centerMesh) {\r\n            this._centerMesh = centerMesh;\r\n        } else {\r\n            this._setCenterMesh();\r\n        }\r\n        this._centerMesh.computeWorldMatrix(true);\r\n\r\n        const centerMeshIndex = this._meshes.indexOf(this._centerMesh);\r\n        if (centerMeshIndex >= 0) {\r\n            this._meshes.splice(centerMeshIndex, 1);\r\n        }\r\n        this._centerPosition = this._centerMesh.getAbsolutePosition().clone();\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index]) {\r\n                const mesh = this._meshes[index];\r\n                this._meshesOrigins[index] = mesh.getAbsolutePosition().clone();\r\n                this._toCenterVectors[index] = Vector3.Zero();\r\n                if (mesh.hasBoundingInfo && this._centerMesh.hasBoundingInfo) {\r\n                    mesh.computeWorldMatrix(true);\r\n                    mesh.getBoundingInfo().boundingBox.centerWorld.subtractToRef(this._centerMesh.getBoundingInfo().boundingBox.centerWorld, this._toCenterVectors[index]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setCenterMesh(): void {\r\n        let averageCenter = Vector3.Zero();\r\n        const totalCenters = Vector3.Zero();\r\n        let shortestToCenter = Number.MAX_VALUE;\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index]) {\r\n                const mesh = this._meshes[index];\r\n                const boundingInfo = mesh.getBoundingInfo();\r\n                if (boundingInfo) {\r\n                    totalCenters.addInPlace(boundingInfo.boundingBox.centerWorld);\r\n                }\r\n            }\r\n        }\r\n        averageCenter = totalCenters.scale(1 / this._meshes.length);\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index]) {\r\n                const mesh = this._meshes[index];\r\n                const boundingInfo = mesh.getBoundingInfo();\r\n                if (boundingInfo) {\r\n                    const distanceToCenter = boundingInfo.boundingBox.centerWorld.subtract(averageCenter).lengthSquared();\r\n                    if (distanceToCenter < shortestToCenter) {\r\n                        this._centerMesh = mesh;\r\n                        shortestToCenter = distanceToCenter;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get class name\r\n     * @returns \"MeshExploder\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"MeshExploder\";\r\n    }\r\n\r\n    /**\r\n     * \"Exploded meshes\"\r\n     * @returns Array of meshes with the centerMesh at index 0.\r\n     */\r\n    public getMeshes(): Array<Mesh> {\r\n        const meshArray = this._meshes.slice();\r\n        meshArray.unshift(this._centerMesh);\r\n        return meshArray;\r\n    }\r\n\r\n    /**\r\n     * Explodes meshes giving a specific direction\r\n     * @param direction Number to multiply distance of each mesh's origin from center. Use a negative number to implode, or zero to reset.\r\n     */\r\n    public explode(direction: number = 1.0): void {\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index] && this._meshesOrigins[index] && this._toCenterVectors[index]) {\r\n                this._toCenterVectors[index].scaleToRef(direction, this._scaledDirection);\r\n                this._meshesOrigins[index].addToRef(this._scaledDirection, this._newPosition);\r\n                this._meshes[index].setAbsolutePosition(this._newPosition);\r\n            }\r\n        }\r\n        this._centerMesh.setAbsolutePosition(this._centerPosition);\r\n    }\r\n}\r\n"]}