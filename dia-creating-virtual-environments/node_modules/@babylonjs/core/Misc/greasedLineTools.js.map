{"version":3,"file":"greasedLineTools.js","sourceRoot":"","sources":["../../../../dev/core/src/Misc/greasedLineTools.ts"],"names":[],"mappings":"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","sourcesContent":["import { Curve3 } from \"../Maths/math.path\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { IFontData } from \"../Meshes/Builders/textBuilder\";\r\nimport { CreateTextShapePaths } from \"../Meshes/Builders/textBuilder\";\r\nimport type { FloatArray, IndicesArray } from \"../types\";\r\nimport type { GreasedLinePoints } from \"../Meshes/GreasedLine/greasedLineBaseMesh\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { GreasedLineMaterialDefaults } from \"../Materials/GreasedLine/greasedLineMaterialDefaults\";\r\n\r\n/**\r\n * Tool functions for GreasedLine\r\n */\r\nexport class GreasedLineTools {\r\n    /**\r\n     * Converts GreasedLinePoints to number[][]\r\n     * @param points GreasedLinePoints\r\n     * @returns number[][] with x, y, z coordinates of the points, like [[x, y, z, x, y, z, ...], [x, y, z, ...]]\r\n     */\r\n    public static ConvertPoints(points: GreasedLinePoints): number[][] {\r\n        if (points.length && Array.isArray(points) && typeof points[0] === \"number\") {\r\n            return [<number[]>points];\r\n        } else if (points.length && Array.isArray(points[0]) && typeof points[0][0] === \"number\") {\r\n            return <number[][]>points;\r\n        } else if (points.length && !Array.isArray(points[0]) && points[0] instanceof Vector3) {\r\n            const positions: number[] = [];\r\n            for (let j = 0; j < points.length; j++) {\r\n                const p = points[j] as Vector3;\r\n                positions.push(p.x, p.y, p.z);\r\n            }\r\n            return [positions];\r\n        } else if (points.length > 0 && Array.isArray(points[0]) && points[0].length > 0 && points[0][0] instanceof Vector3) {\r\n            const positions: number[][] = [];\r\n            const vectorPoints = points as Vector3[][];\r\n            vectorPoints.forEach((p) => {\r\n                positions.push(p.flatMap((p2) => [p2.x, p2.y, p2.z]));\r\n            });\r\n            return positions;\r\n        } else if (points instanceof Float32Array) {\r\n            return [Array.from(points)];\r\n        } else if (points.length && points[0] instanceof Float32Array) {\r\n            const positions: number[][] = [];\r\n            points.forEach((p) => {\r\n                positions.push(Array.from(p as Float32Array));\r\n            });\r\n            return positions;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Omit zero length lines predicate for the MeshesToLines function\r\n     * @param p1 point1 position of the face\r\n     * @param p2 point2 position of the face\r\n     * @param p3 point3 position of the face\r\n     * @returns original points or null if any edge length is zero\r\n     */\r\n    public static OmitZeroLengthPredicate(p1: Vector3, p2: Vector3, p3: Vector3) {\r\n        const fileredPoints = [];\r\n        // edge1\r\n        if (p2.subtract(p1).lengthSquared() > 0) {\r\n            fileredPoints.push([p1, p2]);\r\n        }\r\n        // edge2\r\n        if (p3.subtract(p2).lengthSquared() > 0) {\r\n            fileredPoints.push([p2, p3]);\r\n        }\r\n        // edge3\r\n        if (p1.subtract(p3).lengthSquared() > 0) {\r\n            fileredPoints.push([p3, p1]);\r\n        }\r\n        return fileredPoints.length === 0 ? null : fileredPoints;\r\n    }\r\n\r\n    /**\r\n     * Omit duplicate lines predicate for the MeshesToLines function\r\n     * @param p1 point1 position of the face\r\n     * @param p2 point2 position of the face\r\n     * @param p3 point3 position of the face\r\n     * @param points array of points to search in\r\n     * @returns original points or null if any edge length is zero\r\n     */\r\n    public static OmitDuplicatesPredicate(p1: Vector3, p2: Vector3, p3: Vector3, points: Vector3[][]) {\r\n        const fileredPoints = [];\r\n        // edge1\r\n        if (!GreasedLineTools._SearchInPoints(p1, p2, points)) {\r\n            fileredPoints.push([p1, p2]);\r\n        }\r\n        // edge2\r\n        if (!GreasedLineTools._SearchInPoints(p2, p3, points)) {\r\n            fileredPoints.push([p2, p3]);\r\n        }\r\n        // edge3\r\n        if (!GreasedLineTools._SearchInPoints(p3, p1, points)) {\r\n            fileredPoints.push([p3, p1]);\r\n        }\r\n        return fileredPoints.length === 0 ? null : fileredPoints;\r\n    }\r\n\r\n    private static _SearchInPoints(p1: Vector3, p2: Vector3, points: Vector3[][]) {\r\n        for (const ps of points) {\r\n            for (let i = 0; i < ps.length; i++) {\r\n                if (ps[i]?.equals(p1)) {\r\n                    // find the first point\r\n                    // if it has a sibling of p2 the line already exists\r\n                    if (ps[i + 1]?.equals(p2) || ps[i - 1]?.equals(p2)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets mesh triangles as line positions\r\n     * @param meshes array of meshes\r\n     * @param predicate predicate function which decides whether to include the mesh triangle/face in the ouput\r\n     * @returns array of arrays of points\r\n     */\r\n    public static MeshesToLines(\r\n        meshes: AbstractMesh[],\r\n        predicate?: (\r\n            p1: Vector3,\r\n            p2: Vector3,\r\n            p3: Vector3,\r\n            points: Vector3[][],\r\n            indiceIndex: number,\r\n            vertexIndex: number,\r\n            mesh: AbstractMesh,\r\n            meshIndex: number,\r\n            vertices: FloatArray,\r\n            indices: IndicesArray\r\n        ) => Vector3[][]\r\n    ) {\r\n        const points: Vector3[][] = [];\r\n\r\n        meshes.forEach((m, meshIndex) => {\r\n            const vertices = m.getVerticesData(VertexBuffer.PositionKind);\r\n            const indices = m.getIndices();\r\n            if (vertices && indices) {\r\n                for (let i = 0, ii = 0; i < indices.length; i++) {\r\n                    const vi1 = indices[ii++] * 3;\r\n                    const vi2 = indices[ii++] * 3;\r\n                    const vi3 = indices[ii++] * 3;\r\n\r\n                    const p1 = new Vector3(vertices[vi1], vertices[vi1 + 1], vertices[vi1 + 2]);\r\n                    const p2 = new Vector3(vertices[vi2], vertices[vi2 + 1], vertices[vi2 + 2]);\r\n                    const p3 = new Vector3(vertices[vi3], vertices[vi3 + 1], vertices[vi3 + 2]);\r\n\r\n                    if (predicate) {\r\n                        const pointsFromPredicate = predicate(p1, p2, p3, points, i, vi1, m, meshIndex, vertices, indices);\r\n                        if (pointsFromPredicate) {\r\n                            for (const p of pointsFromPredicate) {\r\n                                points.push(p);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        points.push([p1, p2], [p2, p3], [p3, p1]);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Converts number coordinates to Vector3s\r\n     * @param points number array of x, y, z, x, y z, ... coordinates\r\n     * @returns Vector3 array\r\n     */\r\n    public static ToVector3Array(points: number[] | number[][]) {\r\n        if (Array.isArray(points[0])) {\r\n            const array: Vector3[][] = [];\r\n            const inputArray = points as number[][];\r\n            for (const subInputArray of inputArray) {\r\n                const subArray: Vector3[] = [];\r\n                for (let i = 0; i < subInputArray.length; i += 3) {\r\n                    subArray.push(new Vector3(subInputArray[i], subInputArray[i + 1], subInputArray[i + 2]));\r\n                }\r\n                array.push(subArray);\r\n            }\r\n            return array;\r\n        }\r\n\r\n        const inputArray = points as number[];\r\n        const array: Vector3[] = [];\r\n        for (let i = 0; i < inputArray.length; i += 3) {\r\n            array.push(new Vector3(inputArray[i], inputArray[i + 1], inputArray[i + 2]));\r\n        }\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * Gets a number array from a Vector3 array.\r\n     * You can you for example to convert your Vector3[] offsets to the required number[] for the offsets option.\r\n     * @param points Vector3 array\r\n     * @returns an array of x, y, z coordinates as numbers [x, y, z, x, y, z, x, y, z, ....]\r\n     */\r\n    public static ToNumberArray(points: Vector3[]) {\r\n        return points.flatMap((v) => [v.x, v.y, v.z]);\r\n    }\r\n\r\n    /**\r\n     * Calculates the sum of points of every line and the number of points in each line.\r\n     * This function is useful when you are drawing multiple lines in one mesh and you want\r\n     * to know the counts. For example for creating an offsets table.\r\n     * @param points point array\r\n     * @returns points count info\r\n     */\r\n    public static GetPointsCountInfo(points: number[][]): { total: number; counts: number[] } {\r\n        const counts = new Array(points.length);\r\n        let total = 0;\r\n        for (let n = points.length; n--; ) {\r\n            counts[n] = points[n].length / 3;\r\n            total += counts[n];\r\n        }\r\n        return { total, counts };\r\n    }\r\n\r\n    /**\r\n     * Gets the length of the line counting all it's segments length\r\n     * @param data array of line points\r\n     * @returns length of the line\r\n     */\r\n    public static GetLineLength(data: Vector3[] | number[]): number {\r\n        if (data.length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        let points: Vector3[];\r\n        if (typeof data[0] === \"number\") {\r\n            points = GreasedLineTools.ToVector3Array(<number[]>data) as Vector3[];\r\n        } else {\r\n            points = data as Vector3[];\r\n        }\r\n\r\n        const tmp = TmpVectors.Vector3[0];\r\n        let length = 0;\r\n        for (let index = 0; index < points.length - 1; index++) {\r\n            const point1 = points[index];\r\n            const point2 = points[index + 1];\r\n            length += point2.subtractToRef(point1, tmp).length();\r\n        }\r\n        return length;\r\n    }\r\n\r\n    /**\r\n     * Divides a segment into smaller segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param point1 first point of the line\r\n     * @param point2 second point of the line\r\n     * @param segmentCount number of segments we want to have in the divided line\r\n     * @returns\r\n     */\r\n    public static SegmentizeSegmentByCount(point1: Vector3, point2: Vector3, segmentCount: number): Vector3[] {\r\n        const dividedLinePoints: Vector3[] = [];\r\n        const diff = point2.subtract(point1);\r\n        const divisor = TmpVectors.Vector3[0];\r\n        divisor.setAll(segmentCount);\r\n        const segmentVector = TmpVectors.Vector3[1];\r\n        diff.divideToRef(divisor, segmentVector);\r\n\r\n        let nextPoint = point1.clone();\r\n        dividedLinePoints.push(nextPoint);\r\n        for (let index = 0; index < segmentCount; index++) {\r\n            nextPoint = nextPoint.clone();\r\n            dividedLinePoints.push(nextPoint.addInPlace(segmentVector));\r\n        }\r\n\r\n        return dividedLinePoints;\r\n    }\r\n\r\n    /**\r\n     * Divides a line into segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param what line points\r\n     * @param segmentLength length of each segment of the resulting line (distance between two line points)\r\n     * @returns line point\r\n     */\r\n    public static SegmentizeLineBySegmentLength(what: Vector3[] | number[] | { point1: Vector3; point2: Vector3; length: number }[], segmentLength: number): Vector3[] {\r\n        const subLines =\r\n            what[0] instanceof Vector3\r\n                ? GreasedLineTools.GetLineSegments(what as Vector3[])\r\n                : typeof what[0] === \"number\"\r\n                  ? GreasedLineTools.GetLineSegments(GreasedLineTools.ToVector3Array(what as number[]) as Vector3[])\r\n                  : (what as { point1: Vector3; point2: Vector3; length: number }[]);\r\n        const points: Vector3[] = [];\r\n        subLines.forEach((s) => {\r\n            if (s.length > segmentLength) {\r\n                const segments = GreasedLineTools.SegmentizeSegmentByCount(s.point1, s.point2, Math.ceil(s.length / segmentLength));\r\n                segments.forEach((seg) => {\r\n                    points.push(seg);\r\n                });\r\n            } else {\r\n                points.push(s.point1);\r\n                points.push(s.point2);\r\n            }\r\n        });\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Divides a line into segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param what line points\r\n     * @param segmentCount number of segments\r\n     * @returns line point\r\n     */\r\n    public static SegmentizeLineBySegmentCount(what: Vector3[] | number[], segmentCount: number): Vector3[] {\r\n        const points = <Vector3[]>(typeof what[0] === \"number\" ? GreasedLineTools.ToVector3Array(<number[]>what) : what);\r\n        const segmentLength = GreasedLineTools.GetLineLength(points) / segmentCount;\r\n        return GreasedLineTools.SegmentizeLineBySegmentLength(points, segmentLength);\r\n    }\r\n    /**\r\n     * Gets line segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param points line points\r\n     * @returns segments information of the line segment including starting point, ending point and the distance between them\r\n     */\r\n    public static GetLineSegments(points: Vector3[]): { point1: Vector3; point2: Vector3; length: number }[] {\r\n        const segments = [];\r\n        for (let index = 0; index < points.length - 1; index++) {\r\n            const point1 = points[index];\r\n            const point2 = points[index + 1];\r\n            const length = point2.subtract(point1).length();\r\n            segments.push({ point1, point2, length });\r\n        }\r\n\r\n        return segments;\r\n    }\r\n\r\n    /**\r\n     * Gets the minimum and the maximum length of a line segment in the line.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param points line points\r\n     * @returns\r\n     */\r\n    public static GetMinMaxSegmentLength(points: Vector3[]): { min: number; max: number } {\r\n        const subLines = GreasedLineTools.GetLineSegments(points);\r\n        const sorted = subLines.sort((s) => s.length);\r\n        return {\r\n            min: sorted[0].length,\r\n            max: sorted[sorted.length - 1].length,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Finds the last visible position in world space of the line according to the visibility parameter\r\n     * @param lineSegments segments of the line\r\n     * @param lineLength total length of the line\r\n     * @param visbility normalized value of visibility\r\n     * @param localSpace if true the result will be in local space (default is false)\r\n     * @returns world space coordinate of the last visible piece of the line\r\n     */\r\n    public static GetPositionOnLineByVisibility(lineSegments: { point1: Vector3; point2: Vector3; length: number }[], lineLength: number, visbility: number, localSpace = false) {\r\n        const lengthVisibilityRatio = lineLength * visbility;\r\n        let sumSegmentLengths = 0;\r\n        let segmentIndex = 0;\r\n\r\n        const lineSegmentsLength = lineSegments.length;\r\n        for (let i = 0; i < lineSegmentsLength; i++) {\r\n            if (lengthVisibilityRatio <= sumSegmentLengths + lineSegments[i].length) {\r\n                segmentIndex = i;\r\n                break;\r\n            }\r\n            sumSegmentLengths += lineSegments[i].length;\r\n        }\r\n\r\n        const s = (lengthVisibilityRatio - sumSegmentLengths) / lineSegments[segmentIndex].length;\r\n\r\n        lineSegments[segmentIndex].point2.subtractToRef(lineSegments[segmentIndex].point1, TmpVectors.Vector3[0]);\r\n        TmpVectors.Vector3[1] = TmpVectors.Vector3[0].multiplyByFloats(s, s, s);\r\n        if (!localSpace) {\r\n            TmpVectors.Vector3[1].addInPlace(lineSegments[segmentIndex].point1);\r\n        }\r\n\r\n        return TmpVectors.Vector3[1].clone();\r\n    }\r\n\r\n    /**\r\n     * Creates lines in a shape of circle/arc.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param radiusX radiusX of the circle\r\n     * @param segments number of segments in the circle\r\n     * @param z z coordinate of the points. Defaults to 0.\r\n     * @param radiusY radiusY of the circle - you can draw an oval if using different values\r\n     * @param segmentAngle angle offset of the segments. Defaults to Math.PI * 2 / segments. Change this value to draw a part of the circle.\r\n     * @returns line points\r\n     */\r\n    public static GetCircleLinePoints(radiusX: number, segments: number, z = 0, radiusY = radiusX, segmentAngle = (Math.PI * 2) / segments) {\r\n        const points: Vector3[] = [];\r\n        for (let i = 0; i <= segments; i++) {\r\n            points.push(new Vector3(Math.cos(i * segmentAngle) * radiusX, Math.sin(i * segmentAngle) * radiusY, z));\r\n        }\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Gets line points in a shape of a bezier curve\r\n     * @param p0 bezier point0\r\n     * @param p1 bezier point1\r\n     * @param p2 bezier point2\r\n     * @param segments number of segments in the curve\r\n     * @returns\r\n     */\r\n    public static GetBezierLinePoints(p0: Vector3, p1: Vector3, p2: Vector3, segments: number) {\r\n        return Curve3.CreateQuadraticBezier(p0, p1, p2, segments)\r\n            .getPoints()\r\n            .flatMap((v) => [v.x, v.y, v.z]);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param position position of the arrow cap (mainly you want to create a triangle, set widthUp and widthDown to the same value and omit widthStartUp and widthStartDown)\r\n     * @param direction direction which the arrow points to\r\n     * @param length length (size) of the arrow cap itself\r\n     * @param widthUp the arrow width above the line\r\n     * @param widthDown the arrow width belove the line\r\n     * @param widthStartUp the arrow width at the start of the arrow above the line. In most scenarios this is 0.\r\n     * @param widthStartDown the arrow width at the start of the arrow below the line. In most scenarios this is 0.\r\n     * @returns\r\n     */\r\n    public static GetArrowCap(position: Vector3, direction: Vector3, length: number, widthUp: number, widthDown: number, widthStartUp = 0, widthStartDown = 0) {\r\n        const points = [position.clone(), position.add(direction.multiplyByFloats(length, length, length))];\r\n        const widths = [widthUp, widthDown, widthStartUp, widthStartDown];\r\n\r\n        return {\r\n            points,\r\n            widths,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets 3D positions of points from a text and font\r\n     * @param text Text\r\n     * @param size Size of the font\r\n     * @param resolution Resolution of the font\r\n     * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\r\n     * @param z z coordinate\r\n     * @param includeInner include the inner parts of the font in the result. Default true. If false, only the outlines will be returned.\r\n     * @returns number[][] of 3D positions\r\n     */\r\n    public static GetPointsFromText(text: string, size: number, resolution: number, fontData: IFontData, z = 0, includeInner = true) {\r\n        const allPoints = [];\r\n        const shapePaths = CreateTextShapePaths(text, size, resolution, fontData);\r\n\r\n        for (const sp of shapePaths) {\r\n            for (const p of sp.paths) {\r\n                const points = [];\r\n                const points2d = p.getPoints();\r\n                for (const p2d of points2d) {\r\n                    points.push(p2d.x, p2d.y, z);\r\n                }\r\n                allPoints.push(points);\r\n            }\r\n\r\n            if (includeInner) {\r\n                for (const h of sp.holes) {\r\n                    const holes = [];\r\n                    const points2d = h.getPoints();\r\n                    for (const p2d of points2d) {\r\n                        holes.push(p2d.x, p2d.y, z);\r\n                    }\r\n                    allPoints.push(holes);\r\n                }\r\n            }\r\n        }\r\n\r\n        return allPoints;\r\n    }\r\n\r\n    /**\r\n     * Converts an array of Color3 to Uint8Array\r\n     * @param colors Arrray of Color3\r\n     * @returns Uin8Array of colors [r, g, b, a, r, g, b, a, ...]\r\n     */\r\n    public static Color3toRGBAUint8(colors: Color3[]) {\r\n        const colorTable: Uint8Array = new Uint8Array(colors.length * 4);\r\n        for (let i = 0, j = 0; i < colors.length; i++) {\r\n            colorTable[j++] = colors[i].r * 255;\r\n            colorTable[j++] = colors[i].g * 255;\r\n            colorTable[j++] = colors[i].b * 255;\r\n            colorTable[j++] = 255;\r\n        }\r\n\r\n        return colorTable;\r\n    }\r\n\r\n    /**\r\n     * Creates a RawTexture from an RGBA color array and sets it on the plugin material instance.\r\n     * @param name name of the texture\r\n     * @param colors Uint8Array of colors\r\n     * @param colorsSampling sampling mode of the created texture\r\n     * @param scene Scene\r\n     */\r\n    public static CreateColorsTexture(name: string, colors: Color3[], colorsSampling: number, scene: Scene) {\r\n        const colorsArray = GreasedLineTools.Color3toRGBAUint8(colors);\r\n        const colorsTexture = new RawTexture(colorsArray, colors.length, 1, Engine.TEXTUREFORMAT_RGBA, scene, false, true, colorsSampling);\r\n        colorsTexture.name = name;\r\n        return colorsTexture;\r\n    }\r\n\r\n    /**\r\n     * A minimum size texture for the colors sampler2D when there is no colors texture defined yet.\r\n     * For fast switching using the useColors property without the need to use defines.\r\n     * @param scene Scene\r\n     * @returns empty colors texture\r\n     */\r\n    public static PrepareEmptyColorsTexture(scene: Scene) {\r\n        if (!GreasedLineMaterialDefaults.EmptyColorsTexture) {\r\n            const colorsArray = new Uint8Array(4);\r\n            GreasedLineMaterialDefaults.EmptyColorsTexture = new RawTexture(colorsArray, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false, false, RawTexture.NEAREST_NEAREST);\r\n            GreasedLineMaterialDefaults.EmptyColorsTexture.name = \"grlEmptyColorsTexture\";\r\n        }\r\n\r\n        return GreasedLineMaterialDefaults.EmptyColorsTexture;\r\n    }\r\n\r\n    /**\r\n     * Diposes the shared empty colors texture\r\n     */\r\n    public static DisposeEmptyColorsTexture() {\r\n        GreasedLineMaterialDefaults.EmptyColorsTexture?.dispose();\r\n        GreasedLineMaterialDefaults.EmptyColorsTexture = null;\r\n    }\r\n\r\n    /**\r\n     * Converts boolean to number.\r\n     * @param bool the bool value\r\n     * @returns 1 if true, 0 if false.\r\n     */\r\n    public static BooleanToNumber(bool?: boolean) {\r\n        return bool ? 1 : 0;\r\n    }\r\n}\r\n"]}