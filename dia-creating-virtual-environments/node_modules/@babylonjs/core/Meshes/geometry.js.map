{"version":3,"file":"geometry.js","sourceRoot":"","sources":["../../../../dev/core/src/Meshes/geometry.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable, FloatArray, DataArray, IndicesArray } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { IGetSetVerticesData } from \"../Meshes/mesh.vertexData\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { Tags } from \"../Misc/tags\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { extractMinAndMax } from \"../Maths/math.functions\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { CompatibilityOptions } from \"../Compat/compatibilityOptions\";\r\n\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Buffer } from \"../Buffers/buffer\";\r\n\r\n/**\r\n * Class used to store geometry data (vertex buffers + index buffer)\r\n */\r\nexport class Geometry implements IGetSetVerticesData {\r\n    // Members\r\n    /**\r\n     * Gets or sets the ID of the geometry\r\n     */\r\n    public id: string;\r\n    /**\r\n     * Gets or sets the unique ID of the geometry\r\n     */\r\n    public uniqueId: number;\r\n    /**\r\n     * Gets the delay loading state of the geometry (none by default which means not delayed)\r\n     */\r\n    public delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n    /**\r\n     * Gets the file containing the data to load when running in delay load state\r\n     */\r\n    public delayLoadingFile: Nullable<string>;\r\n    /**\r\n     * Callback called when the geometry is updated\r\n     */\r\n    public onGeometryUpdated: (geometry: Geometry, kind?: string) => void;\r\n\r\n    // Private\r\n    private _scene: Scene;\r\n    private _engine: Engine;\r\n    private _meshes: Mesh[];\r\n    private _totalVertices = 0;\r\n    private _totalIndices?: number;\r\n    /** @internal */\r\n    public _loadedUniqueId: string;\r\n    /** @internal */\r\n    public _indices: IndicesArray;\r\n    /** @internal */\r\n    public _vertexBuffers: { [key: string]: VertexBuffer };\r\n    private _isDisposed = false;\r\n    private _extend: { minimum: Vector3; maximum: Vector3 };\r\n    private _boundingBias: Vector2;\r\n    /** @internal */\r\n    public _delayInfo: Array<string>;\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _indexBufferIsUpdatable = false;\r\n    /** @internal */\r\n    public _boundingInfo: Nullable<BoundingInfo>;\r\n    /** @internal */\r\n    public _delayLoadingFunction: Nullable<(any: any, geometry: Geometry) => void>;\r\n    /** @internal */\r\n    public _softwareSkinningFrameId: number;\r\n    private _vertexArrayObjects: { [key: string]: WebGLVertexArrayObject };\r\n    private _updatable: boolean;\r\n\r\n    // Cache\r\n    /** @internal */\r\n    public _positions: Nullable<Vector3[]>;\r\n    private _positionsCache: Vector3[] = [];\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /**\r\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n     */\r\n    public get boundingBias(): Vector2 {\r\n        return this._boundingBias;\r\n    }\r\n\r\n    /**\r\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n     */\r\n    public set boundingBias(value: Vector2) {\r\n        if (this._boundingBias) {\r\n            this._boundingBias.copyFrom(value);\r\n        } else {\r\n            this._boundingBias = value.clone();\r\n        }\r\n\r\n        this._updateBoundingInfo(true, null);\r\n    }\r\n\r\n    /**\r\n     * Static function used to attach a new empty geometry to a mesh\r\n     * @param mesh defines the mesh to attach the geometry to\r\n     * @returns the new Geometry\r\n     */\r\n    public static CreateGeometryForMesh(mesh: Mesh): Geometry {\r\n        const geometry = new Geometry(Geometry.RandomId(), mesh.getScene());\r\n\r\n        geometry.applyToMesh(mesh);\r\n\r\n        return geometry;\r\n    }\r\n\r\n    /** Get the list of meshes using this geometry */\r\n    public get meshes(): Mesh[] {\r\n        return this._meshes;\r\n    }\r\n\r\n    /**\r\n     * If set to true (false by default), the bounding info applied to the meshes sharing this geometry will be the bounding info defined at the class level\r\n     * and won't be computed based on the vertex positions (which is what we get when useBoundingInfoFromGeometry = false)\r\n     */\r\n    public useBoundingInfoFromGeometry = false;\r\n\r\n    /**\r\n     * Creates a new geometry\r\n     * @param id defines the unique ID\r\n     * @param scene defines the hosting scene\r\n     * @param vertexData defines the VertexData used to get geometry data\r\n     * @param updatable defines if geometry must be updatable (false by default)\r\n     * @param mesh defines the mesh that will be associated with the geometry\r\n     */\r\n    constructor(id: string, scene?: Scene, vertexData?: VertexData, updatable: boolean = false, mesh: Nullable<Mesh> = null) {\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n        this.id = id;\r\n        this.uniqueId = this._scene.getUniqueId();\r\n        this._engine = this._scene.getEngine();\r\n        this._meshes = [];\r\n        //Init vertex buffer cache\r\n        this._vertexBuffers = {};\r\n        this._indices = [];\r\n        this._updatable = updatable;\r\n\r\n        // vertexData\r\n        if (vertexData) {\r\n            this.setAllVerticesData(vertexData, updatable);\r\n        } else {\r\n            this._totalVertices = 0;\r\n        }\r\n\r\n        if (this._engine.getCaps().vertexArrayObject) {\r\n            this._vertexArrayObjects = {};\r\n        }\r\n\r\n        // applyToMesh\r\n        if (mesh) {\r\n            this.applyToMesh(mesh);\r\n            mesh.computeWorldMatrix(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current extend of the geometry\r\n     */\r\n    public get extend(): { minimum: Vector3; maximum: Vector3 } {\r\n        return this._extend;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     * @returns the hosting Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting engine\r\n     * @returns the hosting Engine\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Defines if the geometry is ready to use\r\n     * @returns true if the geometry is ready to be used\r\n     */\r\n    public isReady(): boolean {\r\n        return this.delayLoadState === Constants.DELAYLOADSTATE_LOADED || this.delayLoadState === Constants.DELAYLOADSTATE_NONE;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating that the geometry should not be serialized\r\n     */\r\n    public get doNotSerialize(): boolean {\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (!this._meshes[index].doNotSerialize) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (this._vertexArrayObjects) {\r\n            this._vertexArrayObjects = {};\r\n        }\r\n\r\n        // Index buffer\r\n        if (this._meshes.length !== 0 && this._indices) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable, \"Geometry_\" + this.id + \"_IndexBuffer\");\r\n        }\r\n\r\n        // Vertex buffers\r\n        const buffers = new Set<Buffer>();\r\n        for (const key in this._vertexBuffers) {\r\n            buffers.add(this._vertexBuffers[key].getWrapperBuffer());\r\n        }\r\n\r\n        buffers.forEach((buffer) => {\r\n            buffer._rebuild();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Affects all geometry data in one call\r\n     * @param vertexData defines the geometry data\r\n     * @param updatable defines if the geometry must be flagged as updatable (false as default)\r\n     */\r\n    public setAllVerticesData(vertexData: VertexData, updatable?: boolean): void {\r\n        vertexData.applyToGeometry(this, updatable);\r\n        this._notifyUpdate();\r\n    }\r\n\r\n    /**\r\n     * Set specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the vertex data to use\r\n     * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable: boolean = false, stride?: number): void {\r\n        if (updatable && Array.isArray(data)) {\r\n            // to avoid converting to Float32Array at each draw call in engine.updateDynamicVertexBuffer, we make the conversion a single time here\r\n            data = new Float32Array(data);\r\n        }\r\n        const buffer = new VertexBuffer(this._engine, data, kind, {\r\n            updatable,\r\n            postponeInternalCreation: this._meshes.length === 0,\r\n            stride,\r\n            label: \"Geometry_\" + this.id + \"_\" + kind,\r\n        });\r\n        this.setVerticesBuffer(buffer);\r\n    }\r\n\r\n    /**\r\n     * Removes a specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     */\r\n    public removeVerticesData(kind: string) {\r\n        if (this._vertexBuffers[kind]) {\r\n            this._vertexBuffers[kind].dispose();\r\n            delete this._vertexBuffers[kind];\r\n        }\r\n\r\n        if (this._vertexArrayObjects) {\r\n            this._disposeVertexArrayObjects();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data\r\n     * @param buffer defines the vertex buffer to use\r\n     * @param totalVertices defines the total number of vertices for position kind (could be null)\r\n     * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)\r\n     */\r\n    public setVerticesBuffer(buffer: VertexBuffer, totalVertices: Nullable<number> = null, disposeExistingBuffer = true): void {\r\n        const kind = buffer.getKind();\r\n        if (this._vertexBuffers[kind] && disposeExistingBuffer) {\r\n            this._vertexBuffers[kind].dispose();\r\n        }\r\n\r\n        if (buffer._buffer) {\r\n            buffer._buffer._increaseReferences();\r\n        }\r\n\r\n        this._vertexBuffers[kind] = buffer;\r\n        const meshes = this._meshes;\r\n        const numOfMeshes = meshes.length;\r\n\r\n        if (kind === VertexBuffer.PositionKind) {\r\n            this._totalVertices = totalVertices ?? buffer._maxVerticesCount;\r\n\r\n            this._updateExtend(buffer.getFloatData(this._totalVertices));\r\n            this._resetPointsArrayCache();\r\n\r\n            // this._extend can be empty if buffer.getFloatData(this._totalVertices) returned null\r\n            const minimum = (this._extend && this._extend.minimum) || new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n            const maximum = (this._extend && this._extend.maximum) || new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n\r\n            for (let index = 0; index < numOfMeshes; index++) {\r\n                const mesh = meshes[index];\r\n                mesh.buildBoundingInfo(minimum, maximum);\r\n                mesh._createGlobalSubMesh(mesh.isUnIndexed);\r\n                mesh.computeWorldMatrix(true);\r\n                mesh.synchronizeInstances();\r\n            }\r\n        }\r\n\r\n        this._notifyUpdate(kind);\r\n    }\r\n\r\n    /**\r\n     * Update a specific vertex buffer\r\n     * This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array\r\n     * It will do nothing if the buffer is not updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the data to use\r\n     * @param offset defines the offset in the target buffer where to store the data\r\n     * @param useBytes set to true if the offset is in bytes\r\n     */\r\n    public updateVerticesDataDirectly(kind: string, data: DataArray, offset: number, useBytes: boolean = false): void {\r\n        const vertexBuffer = this.getVertexBuffer(kind);\r\n\r\n        if (!vertexBuffer) {\r\n            return;\r\n        }\r\n\r\n        vertexBuffer.updateDirectly(data, offset, useBytes);\r\n        this._notifyUpdate(kind);\r\n    }\r\n\r\n    /**\r\n     * Update a specific vertex buffer\r\n     * This function will create a new buffer if the current one is not updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the data to use\r\n     * @param updateExtends defines if the geometry extends must be recomputed (false by default)\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends: boolean = false): void {\r\n        const vertexBuffer = this.getVertexBuffer(kind);\r\n\r\n        if (!vertexBuffer) {\r\n            return;\r\n        }\r\n\r\n        vertexBuffer.update(data);\r\n\r\n        if (kind === VertexBuffer.PositionKind) {\r\n            this._updateBoundingInfo(updateExtends, data);\r\n        }\r\n        this._notifyUpdate(kind);\r\n    }\r\n\r\n    private _updateBoundingInfo(updateExtends: boolean, data: Nullable<FloatArray>) {\r\n        if (updateExtends) {\r\n            this._updateExtend(data);\r\n        }\r\n\r\n        this._resetPointsArrayCache();\r\n\r\n        if (updateExtends) {\r\n            const meshes = this._meshes;\r\n            for (const mesh of meshes) {\r\n                if (mesh.hasBoundingInfo) {\r\n                    mesh.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum);\r\n                } else {\r\n                    mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\r\n                }\r\n\r\n                const subMeshes = mesh.subMeshes;\r\n                for (const subMesh of subMeshes) {\r\n                    subMesh.refreshBoundingInfo();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bind(\r\n        effect: Nullable<Effect>,\r\n        indexToBind?: Nullable<DataBuffer>,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> },\r\n        overrideVertexArrayObjects?: { [key: string]: WebGLVertexArrayObject }\r\n    ): void {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (indexToBind === undefined) {\r\n            indexToBind = this._indexBuffer;\r\n        }\r\n        const vbs = this.getVertexBuffers();\r\n\r\n        if (!vbs) {\r\n            return;\r\n        }\r\n\r\n        if (indexToBind != this._indexBuffer || (!this._vertexArrayObjects && !overrideVertexArrayObjects)) {\r\n            this._engine.bindBuffers(vbs, indexToBind, effect, overrideVertexBuffers);\r\n            return;\r\n        }\r\n\r\n        const vaos = overrideVertexArrayObjects ? overrideVertexArrayObjects : this._vertexArrayObjects;\r\n\r\n        // Using VAO\r\n        if (!vaos[effect.key]) {\r\n            vaos[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect, overrideVertexBuffers);\r\n        }\r\n\r\n        this._engine.bindVertexArrayObject(vaos[effect.key], indexToBind);\r\n    }\r\n\r\n    /**\r\n     * Gets total number of vertices\r\n     * @returns the total number of vertices\r\n     */\r\n    public getTotalVertices(): number {\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n\r\n        return this._totalVertices;\r\n    }\r\n\r\n    /**\r\n     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray> {\r\n        const vertexBuffer = this.getVertexBuffer(kind);\r\n        if (!vertexBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return vertexBuffer.getFloatData(this._totalVertices, forceCopy || (copyWhenShared && this._meshes.length !== 1));\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean defining if the vertex data for the requested `kind` is updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns true if the vertex buffer with the specified kind is updatable\r\n     */\r\n    public isVertexBufferUpdatable(kind: string): boolean {\r\n        const vb = this._vertexBuffers[kind];\r\n\r\n        if (!vb) {\r\n            return false;\r\n        }\r\n\r\n        return vb.isUpdatable();\r\n    }\r\n\r\n    /**\r\n     * Gets a specific vertex buffer\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns a VertexBuffer\r\n     */\r\n    public getVertexBuffer(kind: string): Nullable<VertexBuffer> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._vertexBuffers[kind];\r\n    }\r\n\r\n    /**\r\n     * Returns all vertex buffers\r\n     * @returns an object holding all vertex buffers indexed by kind\r\n     */\r\n    public getVertexBuffers(): Nullable<{ [key: string]: VertexBuffer }> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._vertexBuffers;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if specific vertex buffer is present\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns true if data is present\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        if (!this._vertexBuffers) {\r\n            if (this._delayInfo) {\r\n                return this._delayInfo.indexOf(kind) !== -1;\r\n            }\r\n            return false;\r\n        }\r\n        return this._vertexBuffers[kind] !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets a list of all attached data kinds (Position, normal, etc...)\r\n     * @returns a list of string containing all kinds\r\n     */\r\n    public getVerticesDataKinds(): string[] {\r\n        const result = [];\r\n        let kind;\r\n        if (!this._vertexBuffers && this._delayInfo) {\r\n            for (kind in this._delayInfo) {\r\n                result.push(kind);\r\n            }\r\n        } else {\r\n            for (kind in this._vertexBuffers) {\r\n                result.push(kind);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Update index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param offset defines the offset in the target buffer where to store the data\r\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\r\n     */\r\n    public updateIndices(indices: IndicesArray, offset?: number, gpuMemoryOnly = false): void {\r\n        if (!this._indexBuffer) {\r\n            return;\r\n        }\r\n\r\n        if (!this._indexBufferIsUpdatable) {\r\n            this.setIndices(indices, null, true);\r\n        } else {\r\n            const needToUpdateSubMeshes = indices.length !== this._indices.length;\r\n\r\n            if (!gpuMemoryOnly) {\r\n                this._indices = indices.slice();\r\n            }\r\n            this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);\r\n            if (needToUpdateSubMeshes) {\r\n                for (const mesh of this._meshes) {\r\n                    mesh._createGlobalSubMesh(true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the index buffer for this geometry.\r\n     * @param indexBuffer Defines the index buffer to use for this geometry\r\n     * @param totalVertices Defines the total number of vertices used by the buffer\r\n     * @param totalIndices Defines the total number of indices in the index buffer\r\n     */\r\n    public setIndexBuffer(indexBuffer: DataBuffer, totalVertices: number, totalIndices: number): void {\r\n        this._indices = [];\r\n        this._indexBufferIsUpdatable = false;\r\n        this._indexBuffer = indexBuffer;\r\n        this._totalVertices = totalVertices;\r\n        this._totalIndices = totalIndices;\r\n\r\n        indexBuffer.is32Bits ||= this._totalIndices > 65535;\r\n\r\n        for (const mesh of this._meshes) {\r\n            mesh._createGlobalSubMesh(true);\r\n            mesh.synchronizeInstances();\r\n        }\r\n\r\n        this._notifyUpdate();\r\n    }\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param totalVertices defines the total number of vertices (could be null)\r\n     * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null, updatable: boolean = false): void {\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n        }\r\n\r\n        this._indices = indices;\r\n        this._indexBufferIsUpdatable = updatable;\r\n        if (this._meshes.length !== 0 && this._indices) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable, \"Geometry_\" + this.id + \"_IndexBuffer\");\r\n        }\r\n\r\n        if (totalVertices != undefined) {\r\n            // including null and undefined\r\n            this._totalVertices = totalVertices;\r\n        }\r\n\r\n        for (const mesh of this._meshes) {\r\n            mesh._createGlobalSubMesh(true);\r\n            mesh.synchronizeInstances();\r\n        }\r\n\r\n        this._notifyUpdate();\r\n    }\r\n\r\n    /**\r\n     * Return the total number of indices\r\n     * @returns the total number of indices\r\n     */\r\n    public getTotalIndices(): number {\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n        return this._totalIndices !== undefined ? this._totalIndices : this._indices.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer array\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the index buffer array\r\n     */\r\n    public getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        const orig = this._indices;\r\n        if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {\r\n            return orig;\r\n        } else {\r\n            return orig.slice();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer\r\n     * @returns the index buffer\r\n     */\r\n    public getIndexBuffer(): Nullable<DataBuffer> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._indexBuffer;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseVertexArrayObject(effect: Nullable<Effect> = null) {\r\n        if (!effect || !this._vertexArrayObjects) {\r\n            return;\r\n        }\r\n\r\n        if (this._vertexArrayObjects[effect.key]) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);\r\n            delete this._vertexArrayObjects[effect.key];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release the associated resources for a specific mesh\r\n     * @param mesh defines the source mesh\r\n     * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it\r\n     */\r\n    public releaseForMesh(mesh: Mesh, shouldDispose?: boolean): void {\r\n        const meshes = this._meshes;\r\n        const index = meshes.indexOf(mesh);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        meshes.splice(index, 1);\r\n\r\n        if (this._vertexArrayObjects) {\r\n            mesh._invalidateInstanceVertexArrayObject();\r\n        }\r\n\r\n        mesh._geometry = null;\r\n\r\n        if (meshes.length === 0 && shouldDispose) {\r\n            this.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply current geometry to a given mesh\r\n     * @param mesh defines the mesh to apply geometry to\r\n     */\r\n    public applyToMesh(mesh: Mesh): void {\r\n        if (mesh._geometry === this) {\r\n            return;\r\n        }\r\n\r\n        const previousGeometry = mesh._geometry;\r\n        if (previousGeometry) {\r\n            previousGeometry.releaseForMesh(mesh);\r\n        }\r\n\r\n        if (this._vertexArrayObjects) {\r\n            mesh._invalidateInstanceVertexArrayObject();\r\n        }\r\n\r\n        const meshes = this._meshes;\r\n\r\n        // must be done before setting vertexBuffers because of mesh._createGlobalSubMesh()\r\n        mesh._geometry = this;\r\n        mesh._internalAbstractMeshDataInfo._positions = null;\r\n\r\n        this._scene.pushGeometry(this);\r\n\r\n        meshes.push(mesh);\r\n\r\n        if (this.isReady()) {\r\n            this._applyToMesh(mesh);\r\n        } else if (this._boundingInfo) {\r\n            mesh.setBoundingInfo(this._boundingInfo);\r\n        }\r\n    }\r\n\r\n    private _updateExtend(data: Nullable<FloatArray> = null) {\r\n        if (this.useBoundingInfoFromGeometry && this._boundingInfo) {\r\n            this._extend = {\r\n                minimum: this._boundingInfo.minimum.clone(),\r\n                maximum: this._boundingInfo.maximum.clone(),\r\n            };\r\n        } else {\r\n            if (!data) {\r\n                data = this.getVerticesData(VertexBuffer.PositionKind)!;\r\n                // This can happen if the buffer comes from a Hardware Buffer where\r\n                // The data have not been uploaded by Babylon. (ex: Compute Shaders and Storage Buffers)\r\n                if (!data) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);\r\n        }\r\n    }\r\n\r\n    private _applyToMesh(mesh: Mesh): void {\r\n        const numOfMeshes = this._meshes.length;\r\n\r\n        // vertexBuffers\r\n        for (const kind in this._vertexBuffers) {\r\n            if (numOfMeshes === 1) {\r\n                this._vertexBuffers[kind].create();\r\n            }\r\n\r\n            if (kind === VertexBuffer.PositionKind) {\r\n                if (!this._extend) {\r\n                    this._updateExtend();\r\n                }\r\n                mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\r\n\r\n                mesh._createGlobalSubMesh(mesh.isUnIndexed);\r\n\r\n                //bounding info was just created again, world matrix should be applied again.\r\n                mesh._updateBoundingInfo();\r\n            }\r\n        }\r\n\r\n        // indexBuffer\r\n        if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable, \"Geometry_\" + this.id + \"_IndexBuffer\");\r\n        }\r\n\r\n        // morphTargets\r\n        mesh._syncGeometryWithMorphTargetManager();\r\n\r\n        // instances\r\n        mesh.synchronizeInstances();\r\n    }\r\n\r\n    private _notifyUpdate(kind?: string) {\r\n        if (this.onGeometryUpdated) {\r\n            this.onGeometryUpdated(this, kind);\r\n        }\r\n\r\n        if (this._vertexArrayObjects) {\r\n            this._disposeVertexArrayObjects();\r\n        }\r\n\r\n        for (const mesh of this._meshes) {\r\n            mesh._markSubMeshesAsAttributesDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load the geometry if it was flagged as delay loaded\r\n     * @param scene defines the hosting scene\r\n     * @param onLoaded defines a callback called when the geometry is loaded\r\n     */\r\n    public load(scene: Scene, onLoaded?: () => void): void {\r\n        if (this.delayLoadState === Constants.DELAYLOADSTATE_LOADING) {\r\n            return;\r\n        }\r\n\r\n        if (this.isReady()) {\r\n            if (onLoaded) {\r\n                onLoaded();\r\n            }\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADING;\r\n\r\n        this._queueLoad(scene, onLoaded);\r\n    }\r\n\r\n    private _queueLoad(scene: Scene, onLoaded?: () => void): void {\r\n        if (!this.delayLoadingFile) {\r\n            return;\r\n        }\r\n\r\n        scene.addPendingData(this);\r\n        scene._loadFile(\r\n            this.delayLoadingFile,\r\n            (data) => {\r\n                if (!this._delayLoadingFunction) {\r\n                    return;\r\n                }\r\n\r\n                this._delayLoadingFunction(JSON.parse(data as string), this);\r\n\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n                this._delayInfo = [];\r\n\r\n                scene.removePendingData(this);\r\n\r\n                const meshes = this._meshes;\r\n                const numOfMeshes = meshes.length;\r\n                for (let index = 0; index < numOfMeshes; index++) {\r\n                    this._applyToMesh(meshes[index]);\r\n                }\r\n\r\n                if (onLoaded) {\r\n                    onLoaded();\r\n                }\r\n            },\r\n            undefined,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Invert the geometry to move from a right handed system to a left handed one.\r\n     */\r\n    public toLeftHanded(): void {\r\n        // Flip faces\r\n        const tIndices = this.getIndices(false);\r\n        if (tIndices != null && tIndices.length > 0) {\r\n            for (let i = 0; i < tIndices.length; i += 3) {\r\n                const tTemp = tIndices[i + 0];\r\n                tIndices[i + 0] = tIndices[i + 2];\r\n                tIndices[i + 2] = tTemp;\r\n            }\r\n            this.setIndices(tIndices);\r\n        }\r\n\r\n        // Negate position.z\r\n        const tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);\r\n        if (tPositions != null && tPositions.length > 0) {\r\n            for (let i = 0; i < tPositions.length; i += 3) {\r\n                tPositions[i + 2] = -tPositions[i + 2];\r\n            }\r\n            this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);\r\n        }\r\n\r\n        // Negate normal.z\r\n        const tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);\r\n        if (tNormals != null && tNormals.length > 0) {\r\n            for (let i = 0; i < tNormals.length; i += 3) {\r\n                tNormals[i + 2] = -tNormals[i + 2];\r\n            }\r\n            this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);\r\n        }\r\n    }\r\n\r\n    // Cache\r\n    /** @internal */\r\n    public _resetPointsArrayCache(): void {\r\n        this._positions = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _generatePointsArray(): boolean {\r\n        if (this._positions) {\r\n            return true;\r\n        }\r\n\r\n        const data = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!data || data.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        for (let index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {\r\n            this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);\r\n        }\r\n\r\n        for (let index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {\r\n            this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);\r\n        }\r\n\r\n        // just in case the number of positions was reduced, splice the array\r\n        this._positionsCache.length = data.length / 3;\r\n\r\n        this._positions = this._positionsCache;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the geometry is disposed\r\n     * @returns true if the geometry was disposed\r\n     */\r\n    public isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    private _disposeVertexArrayObjects(): void {\r\n        if (this._vertexArrayObjects) {\r\n            for (const kind in this._vertexArrayObjects) {\r\n                this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);\r\n            }\r\n            this._vertexArrayObjects = {}; // Will trigger a rebuild of the VAO if supported\r\n\r\n            const meshes = this._meshes;\r\n            const numOfMeshes = meshes.length;\r\n            for (let index = 0; index < numOfMeshes; index++) {\r\n                meshes[index]._invalidateInstanceVertexArrayObject();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Free all associated resources\r\n     */\r\n    public dispose(): void {\r\n        const meshes = this._meshes;\r\n        const numOfMeshes = meshes.length;\r\n        let index: number;\r\n        for (index = 0; index < numOfMeshes; index++) {\r\n            this.releaseForMesh(meshes[index]);\r\n        }\r\n        this._meshes.length = 0;\r\n\r\n        this._disposeVertexArrayObjects();\r\n\r\n        for (const kind in this._vertexBuffers) {\r\n            this._vertexBuffers[kind].dispose();\r\n        }\r\n        this._vertexBuffers = {};\r\n        this._totalVertices = 0;\r\n\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n        }\r\n        this._indexBuffer = null;\r\n        this._indices = [];\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n        this.delayLoadingFile = null;\r\n        this._delayLoadingFunction = null;\r\n        this._delayInfo = [];\r\n\r\n        this._boundingInfo = null;\r\n\r\n        this._scene.removeGeometry(this);\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.geometries.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.geometries.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * Clone the current geometry into a new geometry\r\n     * @param id defines the unique ID of the new geometry\r\n     * @returns a new geometry object\r\n     */\r\n    public copy(id: string): Geometry {\r\n        const vertexData = new VertexData();\r\n\r\n        vertexData.indices = [];\r\n\r\n        const indices = this.getIndices();\r\n        if (indices) {\r\n            for (let index = 0; index < indices.length; index++) {\r\n                (<number[]>vertexData.indices).push(indices[index]);\r\n            }\r\n        }\r\n\r\n        let updatable = false;\r\n        let stopChecking = false;\r\n        let kind;\r\n        for (kind in this._vertexBuffers) {\r\n            // using slice() to make a copy of the array and not just reference it\r\n            const data = this.getVerticesData(kind);\r\n\r\n            if (data) {\r\n                if (data instanceof Float32Array) {\r\n                    vertexData.set(new Float32Array(<Float32Array>data), kind);\r\n                } else {\r\n                    vertexData.set((<number[]>data).slice(0), kind);\r\n                }\r\n                if (!stopChecking) {\r\n                    const vb = this.getVertexBuffer(kind);\r\n\r\n                    if (vb) {\r\n                        updatable = vb.isUpdatable();\r\n                        stopChecking = !updatable;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const geometry = new Geometry(id, this._scene, vertexData, updatable);\r\n\r\n        geometry.delayLoadState = this.delayLoadState;\r\n        geometry.delayLoadingFile = this.delayLoadingFile;\r\n        geometry._delayLoadingFunction = this._delayLoadingFunction;\r\n\r\n        for (kind in this._delayInfo) {\r\n            geometry._delayInfo = geometry._delayInfo || [];\r\n            geometry._delayInfo.push(kind);\r\n        }\r\n\r\n        // Bounding info\r\n        geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\r\n\r\n        return geometry;\r\n    }\r\n\r\n    /**\r\n     * Serialize the current geometry info (and not the vertices data) into a JSON object\r\n     * @returns a JSON representation of the current geometry data (without the vertices data)\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.id = this.id;\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        serializationObject.updatable = this._updatable;\r\n\r\n        if (Tags && Tags.HasTags(this)) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _toNumberArray(origin: Nullable<Float32Array | IndicesArray>): number[] {\r\n        if (Array.isArray(origin)) {\r\n            return origin;\r\n        } else {\r\n            return Array.prototype.slice.call(origin);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release any memory retained by the cached data on the Geometry.\r\n     *\r\n     * Call this function to reduce memory footprint of the mesh.\r\n     * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\r\n     */\r\n    public clearCachedData(): void {\r\n        this._indices = [];\r\n        this._resetPointsArrayCache();\r\n\r\n        for (const vbName in this._vertexBuffers) {\r\n            if (!Object.prototype.hasOwnProperty.call(this._vertexBuffers, vbName)) {\r\n                continue;\r\n            }\r\n            this._vertexBuffers[vbName]._buffer._data = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize all vertices data into a JSON object\r\n     * @returns a JSON representation of the current geometry data\r\n     */\r\n    public serializeVerticeData(): any {\r\n        const serializationObject = this.serialize();\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            serializationObject.positions = this._toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\r\n                serializationObject.positions._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            serializationObject.normals = this._toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\r\n                serializationObject.normals._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            serializationObject.tangents = this._toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {\r\n                serializationObject.tangents._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            serializationObject.uvs = this._toNumberArray(this.getVerticesData(VertexBuffer.UVKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {\r\n                serializationObject.uvs._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            serializationObject.uvs2 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {\r\n                serializationObject.uvs2._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\r\n            serializationObject.uvs3 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {\r\n                serializationObject.uvs3._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\r\n            serializationObject.uvs4 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {\r\n                serializationObject.uvs4._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\r\n            serializationObject.uvs5 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {\r\n                serializationObject.uvs5._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\r\n            serializationObject.uvs6 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {\r\n                serializationObject.uvs6._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            serializationObject.colors = this._toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {\r\n                serializationObject.colors._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            serializationObject.matricesIndices = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));\r\n            serializationObject.matricesIndices._isExpanded = true;\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {\r\n                serializationObject.matricesIndices._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            serializationObject.matricesWeights = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {\r\n                serializationObject.matricesWeights._updatable = true;\r\n            }\r\n        }\r\n\r\n        serializationObject.indices = this._toNumberArray(this.getIndices());\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Extracts a clone of a mesh geometry\r\n     * @param mesh defines the source mesh\r\n     * @param id defines the unique ID of the new geometry object\r\n     * @returns the new geometry object\r\n     */\r\n    public static ExtractFromMesh(mesh: Mesh, id: string): Nullable<Geometry> {\r\n        const geometry = mesh._geometry;\r\n\r\n        if (!geometry) {\r\n            return null;\r\n        }\r\n\r\n        return geometry.copy(id);\r\n    }\r\n\r\n    /**\r\n     * You should now use Tools.RandomId(), this method is still here for legacy reasons.\r\n     * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\r\n     * Be aware Math.random() could cause collisions, but:\r\n     * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\r\n     * @returns a string containing a new GUID\r\n     */\r\n    public static RandomId(): string {\r\n        return Tools.RandomId();\r\n    }\r\n\r\n    private static _GetGeometryByLoadedUniqueId(uniqueId: string, scene: Scene) {\r\n        for (let index = 0; index < scene.geometries.length; index++) {\r\n            if (scene.geometries[index]._loadedUniqueId === uniqueId) {\r\n                return scene.geometries[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ImportGeometry(parsedGeometry: any, mesh: Mesh): void {\r\n        const scene = mesh.getScene();\r\n\r\n        // Geometry\r\n        const geometryUniqueId = parsedGeometry.geometryUniqueId;\r\n        const geometryId = parsedGeometry.geometryId;\r\n        if (geometryUniqueId || geometryId) {\r\n            const geometry = geometryUniqueId ? this._GetGeometryByLoadedUniqueId(geometryUniqueId, scene) : scene.getGeometryById(geometryId);\r\n            if (geometry) {\r\n                geometry.applyToMesh(mesh);\r\n            }\r\n        } else if (parsedGeometry instanceof ArrayBuffer) {\r\n            const binaryInfo = mesh._binaryInfo;\r\n\r\n            if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {\r\n                const positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);\r\n            }\r\n\r\n            if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {\r\n                const normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);\r\n            }\r\n\r\n            if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {\r\n                const tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);\r\n            }\r\n\r\n            if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {\r\n                const uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvsData.length; index += 2) {\r\n                        uvsData[index] = 1 - uvsData[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {\r\n                const uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs2Data.length; index += 2) {\r\n                        uvs2Data[index] = 1 - uvs2Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {\r\n                const uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs3Data.length; index += 2) {\r\n                        uvs3Data[index] = 1 - uvs3Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {\r\n                const uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs4Data.length; index += 2) {\r\n                        uvs4Data[index] = 1 - uvs4Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {\r\n                const uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs5Data.length; index += 2) {\r\n                        uvs5Data[index] = 1 - uvs5Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {\r\n                const uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs6Data.length; index += 2) {\r\n                        uvs6Data[index] = 1 - uvs6Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);\r\n            }\r\n\r\n            if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {\r\n                const colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);\r\n            }\r\n\r\n            if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {\r\n                const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);\r\n                const floatIndices = [];\r\n                for (let i = 0; i < matricesIndicesData.length; i++) {\r\n                    const index = matricesIndicesData[i];\r\n                    floatIndices.push(index & 0x000000ff);\r\n                    floatIndices.push((index & 0x0000ff00) >> 8);\r\n                    floatIndices.push((index & 0x00ff0000) >> 16);\r\n                    floatIndices.push((index >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);\r\n            }\r\n\r\n            if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {\r\n                const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);\r\n                const floatIndices = [];\r\n                for (let i = 0; i < matricesIndicesData.length; i++) {\r\n                    const index = matricesIndicesData[i];\r\n                    floatIndices.push(index & 0x000000ff);\r\n                    floatIndices.push((index & 0x0000ff00) >> 8);\r\n                    floatIndices.push((index & 0x00ff0000) >> 16);\r\n                    floatIndices.push((index >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);\r\n            }\r\n\r\n            if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {\r\n                const matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);\r\n            }\r\n\r\n            if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {\r\n                const indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);\r\n                mesh.setIndices(indicesData, null);\r\n            }\r\n\r\n            if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {\r\n                const subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);\r\n\r\n                mesh.subMeshes = [];\r\n                for (let i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {\r\n                    const materialIndex = subMeshesData[i * 5 + 0];\r\n                    const verticesStart = subMeshesData[i * 5 + 1];\r\n                    const verticesCount = subMeshesData[i * 5 + 2];\r\n                    const indexStart = subMeshesData[i * 5 + 3];\r\n                    const indexCount = subMeshesData[i * 5 + 4];\r\n\r\n                    SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, <AbstractMesh>mesh);\r\n                }\r\n            }\r\n        } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {\r\n            mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);\r\n\r\n            mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);\r\n\r\n            if (parsedGeometry.tangents) {\r\n                mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs) {\r\n                mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs2) {\r\n                mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs3) {\r\n                mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs4) {\r\n                mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs5) {\r\n                mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs6) {\r\n                mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.colors) {\r\n                mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.matricesIndices) {\r\n                if (!parsedGeometry.matricesIndices._isExpanded) {\r\n                    const floatIndices = [];\r\n\r\n                    for (let i = 0; i < parsedGeometry.matricesIndices.length; i++) {\r\n                        const matricesIndex = parsedGeometry.matricesIndices[i];\r\n\r\n                        floatIndices.push(matricesIndex & 0x000000ff);\r\n                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\r\n                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\r\n                        floatIndices.push((matricesIndex >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                    }\r\n\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);\r\n                } else {\r\n                    delete parsedGeometry.matricesIndices._isExpanded;\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);\r\n                }\r\n            }\r\n\r\n            if (parsedGeometry.matricesIndicesExtra) {\r\n                if (!parsedGeometry.matricesIndicesExtra._isExpanded) {\r\n                    const floatIndices = [];\r\n\r\n                    for (let i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {\r\n                        const matricesIndex = parsedGeometry.matricesIndicesExtra[i];\r\n\r\n                        floatIndices.push(matricesIndex & 0x000000ff);\r\n                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\r\n                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\r\n                        floatIndices.push((matricesIndex >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                    }\r\n\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);\r\n                } else {\r\n                    delete parsedGeometry.matricesIndices._isExpanded;\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);\r\n                }\r\n            }\r\n\r\n            if (parsedGeometry.matricesWeights) {\r\n                Geometry._CleanMatricesWeights(parsedGeometry, mesh);\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.matricesWeightsExtra) {\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);\r\n            }\r\n\r\n            mesh.setIndices(parsedGeometry.indices, null);\r\n        }\r\n\r\n        // SubMeshes\r\n        if (parsedGeometry.subMeshes) {\r\n            mesh.subMeshes = [];\r\n            for (let subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {\r\n                const parsedSubMesh = parsedGeometry.subMeshes[subIndex];\r\n\r\n                SubMesh.AddToMesh(\r\n                    parsedSubMesh.materialIndex,\r\n                    parsedSubMesh.verticesStart,\r\n                    parsedSubMesh.verticesCount,\r\n                    parsedSubMesh.indexStart,\r\n                    parsedSubMesh.indexCount,\r\n                    <AbstractMesh>mesh\r\n                );\r\n            }\r\n        }\r\n\r\n        // Flat shading\r\n        if (mesh._shouldGenerateFlatShading) {\r\n            mesh.convertToFlatShadedMesh();\r\n            mesh._shouldGenerateFlatShading = false;\r\n        }\r\n\r\n        // Update\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        scene.onMeshImportedObservable.notifyObservers(<AbstractMesh>mesh);\r\n    }\r\n\r\n    private static _CleanMatricesWeights(parsedGeometry: any, mesh: Mesh): void {\r\n        const epsilon: number = 1e-3;\r\n        if (!SceneLoaderFlags.CleanBoneMatrixWeights) {\r\n            return;\r\n        }\r\n        let noInfluenceBoneIndex = 0.0;\r\n        if (parsedGeometry.skeletonId > -1) {\r\n            const skeleton = mesh.getScene().getLastSkeletonById(parsedGeometry.skeletonId);\r\n\r\n            if (!skeleton) {\r\n                return;\r\n            }\r\n            noInfluenceBoneIndex = skeleton.bones.length;\r\n        } else {\r\n            return;\r\n        }\r\n        const matricesIndices = <FloatArray>mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\r\n        const matricesIndicesExtra = <FloatArray>mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\r\n        const matricesWeights = parsedGeometry.matricesWeights;\r\n        const matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;\r\n        const influencers = parsedGeometry.numBoneInfluencer;\r\n        const size = matricesWeights.length;\r\n\r\n        for (let i = 0; i < size; i += 4) {\r\n            let weight = 0.0;\r\n            let firstZeroWeight = -1;\r\n            for (let j = 0; j < 4; j++) {\r\n                const w = matricesWeights[i + j];\r\n                weight += w;\r\n                if (w < epsilon && firstZeroWeight < 0) {\r\n                    firstZeroWeight = j;\r\n                }\r\n            }\r\n            if (matricesWeightsExtra) {\r\n                for (let j = 0; j < 4; j++) {\r\n                    const w = matricesWeightsExtra[i + j];\r\n                    weight += w;\r\n                    if (w < epsilon && firstZeroWeight < 0) {\r\n                        firstZeroWeight = j + 4;\r\n                    }\r\n                }\r\n            }\r\n            if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {\r\n                firstZeroWeight = influencers - 1;\r\n            }\r\n            if (weight > epsilon) {\r\n                const mweight = 1.0 / weight;\r\n                for (let j = 0; j < 4; j++) {\r\n                    matricesWeights[i + j] *= mweight;\r\n                }\r\n                if (matricesWeightsExtra) {\r\n                    for (let j = 0; j < 4; j++) {\r\n                        matricesWeightsExtra[i + j] *= mweight;\r\n                    }\r\n                }\r\n            } else {\r\n                if (firstZeroWeight >= 4) {\r\n                    matricesWeightsExtra[i + firstZeroWeight - 4] = 1.0 - weight;\r\n                    matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;\r\n                } else {\r\n                    matricesWeights[i + firstZeroWeight] = 1.0 - weight;\r\n                    matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;\r\n                }\r\n            }\r\n        }\r\n\r\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);\r\n        if (parsedGeometry.matricesWeightsExtra) {\r\n            mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new geometry from persisted data (Using .babylon file format)\r\n     * @param parsedVertexData defines the persisted data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url to use to load assets (like delayed data)\r\n     * @returns the new geometry object\r\n     */\r\n    public static Parse(parsedVertexData: any, scene: Scene, rootUrl: string): Nullable<Geometry> {\r\n        const geometry = new Geometry(parsedVertexData.id, scene, undefined, parsedVertexData.updatable);\r\n        geometry._loadedUniqueId = parsedVertexData.uniqueId;\r\n\r\n        if (Tags) {\r\n            Tags.AddTagsTo(geometry, parsedVertexData.tags);\r\n        }\r\n\r\n        if (parsedVertexData.delayLoadingFile) {\r\n            geometry.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;\r\n            geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));\r\n\r\n            geometry._delayInfo = [];\r\n            if (parsedVertexData.hasUVs) {\r\n                geometry._delayInfo.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs2) {\r\n                geometry._delayInfo.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs3) {\r\n                geometry._delayInfo.push(VertexBuffer.UV3Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs4) {\r\n                geometry._delayInfo.push(VertexBuffer.UV4Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs5) {\r\n                geometry._delayInfo.push(VertexBuffer.UV5Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs6) {\r\n                geometry._delayInfo.push(VertexBuffer.UV6Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasColors) {\r\n                geometry._delayInfo.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasMatricesIndices) {\r\n                geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasMatricesWeights) {\r\n                geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);\r\n            }\r\n\r\n            geometry._delayLoadingFunction = VertexData.ImportVertexData;\r\n        } else {\r\n            VertexData.ImportVertexData(parsedVertexData, geometry);\r\n        }\r\n\r\n        scene.pushGeometry(geometry, true);\r\n\r\n        return geometry;\r\n    }\r\n}\r\n"]}