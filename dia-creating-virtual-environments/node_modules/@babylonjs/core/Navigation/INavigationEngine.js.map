{"version":3,"file":"INavigationEngine.js","sourceRoot":"","sources":["../../../../dev/core/src/Navigation/INavigationEngine.ts"],"names":[],"mappings":"","sourcesContent":["import type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { Vector3 } from \"../Maths/math\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * Navigation plugin interface to add navigation constrained by a navigation mesh\r\n */\r\nexport interface INavigationEnginePlugin {\r\n    /**\r\n     * plugin name\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Creates a navigation mesh\r\n     * @param meshes array of all the geometry used to compute the navigation mesh\r\n     * @param parameters bunch of parameters used to filter geometry\r\n     */\r\n    createNavMesh(meshes: Array<Mesh>, parameters: INavMeshParameters): void;\r\n\r\n    /**\r\n     * Create a navigation mesh debug mesh\r\n     * @param scene is where the mesh will be added\r\n     * @returns debug display mesh\r\n     */\r\n    createDebugNavMesh(scene: Scene): Mesh;\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, closest to the parameter position\r\n     * @param position world position\r\n     * @returns the closest point to position constrained by the navigation mesh\r\n     */\r\n    getClosestPoint(position: Vector3): Vector3;\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, closest to the parameter position\r\n     * @param position world position\r\n     * @param result output the closest point to position constrained by the navigation mesh\r\n     */\r\n    getClosestPointToRef(position: Vector3, result: Vector3): void;\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, within a particular radius\r\n     * @param position world position\r\n     * @param maxRadius the maximum distance to the constrained world position\r\n     * @returns the closest point to position constrained by the navigation mesh\r\n     */\r\n    getRandomPointAround(position: Vector3, maxRadius: number): Vector3;\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, within a particular radius\r\n     * @param position world position\r\n     * @param maxRadius the maximum distance to the constrained world position\r\n     * @param result output the closest point to position constrained by the navigation mesh\r\n     */\r\n    getRandomPointAroundToRef(position: Vector3, maxRadius: number, result: Vector3): void;\r\n\r\n    /**\r\n     * Compute the final position from a segment made of destination-position\r\n     * @param position world position\r\n     * @param destination world position\r\n     * @returns the resulting point along the navmesh\r\n     */\r\n    moveAlong(position: Vector3, destination: Vector3): Vector3;\r\n\r\n    /**\r\n     * Compute the final position from a segment made of destination-position\r\n     * @param position world position\r\n     * @param destination world position\r\n     * @param result output the resulting point along the navmesh\r\n     */\r\n    moveAlongToRef(position: Vector3, destination: Vector3, result: Vector3): void;\r\n\r\n    /**\r\n     * Compute a navigation path from start to end. Returns an empty array if no path can be computed.\r\n     * Path is straight.\r\n     * @param start world position\r\n     * @param end world position\r\n     * @returns array containing world position composing the path\r\n     */\r\n    computePath(start: Vector3, end: Vector3): Vector3[];\r\n\r\n    /**\r\n     * Compute a navigation path from start to end. Returns an empty array if no path can be computed.\r\n     * Path follows navigation mesh geometry.\r\n     * @param start world position\r\n     * @param end world position\r\n     * @returns array containing world position composing the path\r\n     */\r\n    computePathSmooth(start: Vector3, end: Vector3): Vector3[];\r\n\r\n    /**\r\n     * If this plugin is supported\r\n     * @returns true if plugin is supported\r\n     */\r\n    isSupported(): boolean;\r\n\r\n    /**\r\n     * Create a new Crowd so you can add agents\r\n     * @param maxAgents the maximum agent count in the crowd\r\n     * @param maxAgentRadius the maximum radius an agent can have\r\n     * @param scene to attach the crowd to\r\n     * @returns the crowd you can add agents to\r\n     */\r\n    createCrowd(maxAgents: number, maxAgentRadius: number, scene: Scene): ICrowd;\r\n\r\n    /**\r\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n     * The queries will try to find a solution within those bounds\r\n     * default is (1,1,1)\r\n     * @param extent x,y,z value that define the extent around the queries point of reference\r\n     */\r\n    setDefaultQueryExtent(extent: Vector3): void;\r\n\r\n    /**\r\n     * Get the Bounding box extent specified by setDefaultQueryExtent\r\n     * @returns the box extent values\r\n     */\r\n    getDefaultQueryExtent(): Vector3;\r\n\r\n    /**\r\n     * build the navmesh from a previously saved state using getNavmeshData\r\n     * @param data the Uint8Array returned by getNavmeshData\r\n     */\r\n    buildFromNavmeshData(data: Uint8Array): void;\r\n\r\n    /**\r\n     * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data\r\n     * @returns data the Uint8Array that can be saved and reused\r\n     */\r\n    getNavmeshData(): Uint8Array;\r\n\r\n    /**\r\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n     * @param result output the box extent values\r\n     */\r\n    getDefaultQueryExtentToRef(result: Vector3): void;\r\n\r\n    /**\r\n     * Set the time step of the navigation tick update.\r\n     * Default is 1/60.\r\n     * A value of 0 will disable fixed time update\r\n     * @param newTimeStep the new timestep to apply to this world.\r\n     */\r\n    setTimeStep(newTimeStep: number): void;\r\n\r\n    /**\r\n     * Get the time step of the navigation tick update.\r\n     * @returns the current time step\r\n     */\r\n    getTimeStep(): number;\r\n\r\n    /**\r\n     * If delta time in navigation tick update is greater than the time step\r\n     * a number of sub iterations are done. If more iterations are need to reach deltatime\r\n     * they will be discarded.\r\n     * A value of 0 will set to no maximum and update will use as many substeps as needed\r\n     * @param newStepCount the maximum number of iterations\r\n     */\r\n    setMaximumSubStepCount(newStepCount: number): void;\r\n\r\n    /**\r\n     * Get the maximum number of iterations per navigation tick update\r\n     * @returns the maximum number of iterations\r\n     */\r\n    getMaximumSubStepCount(): number;\r\n\r\n    /**\r\n     * Creates a cylinder obstacle and add it to the navigation\r\n     * @param position world position\r\n     * @param radius cylinder radius\r\n     * @param height cylinder height\r\n     * @returns the obstacle freshly created\r\n     */\r\n    addCylinderObstacle(position: Vector3, radius: number, height: number): IObstacle;\r\n\r\n    /**\r\n     * Creates an oriented box obstacle and add it to the navigation\r\n     * @param position world position\r\n     * @param extent box size\r\n     * @param angle angle in radians of the box orientation on Y axis\r\n     * @returns the obstacle freshly created\r\n     */\r\n    addBoxObstacle(position: Vector3, extent: Vector3, angle: number): IObstacle;\r\n\r\n    /**\r\n     * Removes an obstacle created by addCylinderObstacle or addBoxObstacle\r\n     * @param obstacle obstacle to remove from the navigation\r\n     */\r\n    removeObstacle(obstacle: IObstacle): void;\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    dispose(): void;\r\n}\r\n\r\n/**\r\n * Obstacle interface\r\n */\r\nexport interface IObstacle {}\r\n\r\n/**\r\n * Crowd Interface. A Crowd is a collection of moving agents constrained by a navigation mesh\r\n */\r\nexport interface ICrowd {\r\n    /**\r\n     * Add a new agent to the crowd with the specified parameter a corresponding transformNode.\r\n     * You can attach anything to that node. The node position is updated in the scene update tick.\r\n     * @param pos world position that will be constrained by the navigation mesh\r\n     * @param parameters agent parameters\r\n     * @param transform hooked to the agent that will be update by the scene\r\n     * @returns agent index\r\n     */\r\n    addAgent(pos: Vector3, parameters: IAgentParameters, transform: TransformNode): number;\r\n\r\n    /**\r\n     * Returns the agent position in world space\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space position\r\n     */\r\n    getAgentPosition(index: number): Vector3;\r\n\r\n    /**\r\n     * Gets the agent position result in world space\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space position\r\n     */\r\n    getAgentPositionToRef(index: number, result: Vector3): void;\r\n\r\n    /**\r\n     * Gets the agent velocity in world space\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space velocity\r\n     */\r\n    getAgentVelocity(index: number): Vector3;\r\n\r\n    /**\r\n     * Gets the agent velocity result in world space\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space velocity\r\n     */\r\n    getAgentVelocityToRef(index: number, result: Vector3): void;\r\n\r\n    /**\r\n     * Gets the agent next target point on the path\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space position\r\n     */\r\n    getAgentNextTargetPath(index: number): Vector3;\r\n\r\n    /**\r\n     * Gets the agent state\r\n     * @param index agent index returned by addAgent\r\n     * @returns agent state\r\n     */\r\n    getAgentState(index: number): number;\r\n\r\n    /**\r\n     * returns true if the agent in over an off mesh link connection\r\n     * @param index agent index returned by addAgent\r\n     * @returns true if over an off mesh link connection\r\n     */\r\n    overOffmeshConnection(index: number): boolean;\r\n\r\n    /**\r\n     * Gets the agent next target point on the path\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space position\r\n     */\r\n    getAgentNextTargetPathToRef(index: number, result: Vector3): void;\r\n\r\n    /**\r\n     * remove a particular agent previously created\r\n     * @param index agent index returned by addAgent\r\n     */\r\n    removeAgent(index: number): void;\r\n\r\n    /**\r\n     * get the list of all agents attached to this crowd\r\n     * @returns list of agent indices\r\n     */\r\n    getAgents(): number[];\r\n\r\n    /**\r\n     * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function\r\n     * @param deltaTime in seconds\r\n     */\r\n    update(deltaTime: number): void;\r\n\r\n    /**\r\n     * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh\r\n     * @param index agent index returned by addAgent\r\n     * @param destination targeted world position\r\n     */\r\n    agentGoto(index: number, destination: Vector3): void;\r\n\r\n    /**\r\n     * Teleport the agent to a new position\r\n     * @param index agent index returned by addAgent\r\n     * @param destination targeted world position\r\n     */\r\n    agentTeleport(index: number, destination: Vector3): void;\r\n\r\n    /**\r\n     * Update agent parameters\r\n     * @param index agent index returned by addAgent\r\n     * @param parameters agent parameters\r\n     */\r\n    updateAgentParameters(index: number, parameters: IAgentParameters): void;\r\n\r\n    /**\r\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n     * The queries will try to find a solution within those bounds\r\n     * default is (1,1,1)\r\n     * @param extent x,y,z value that define the extent around the queries point of reference\r\n     */\r\n    setDefaultQueryExtent(extent: Vector3): void;\r\n\r\n    /**\r\n     * Get the Bounding box extent specified by setDefaultQueryExtent\r\n     * @returns the box extent values\r\n     */\r\n    getDefaultQueryExtent(): Vector3;\r\n\r\n    /**\r\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n     * @param result output the box extent values\r\n     */\r\n    getDefaultQueryExtentToRef(result: Vector3): void;\r\n\r\n    /**\r\n     * Get the next corner points composing the path (max 4 points)\r\n     * @param index agent index returned by addAgent\r\n     * @returns array containing world position composing the path\r\n     */\r\n    getCorners(index: number): Vector3[];\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    dispose(): void;\r\n}\r\n\r\n/**\r\n * Configures an agent\r\n */\r\nexport interface IAgentParameters {\r\n    /**\r\n     *  Agent radius. [Limit: >= 0]\r\n     */\r\n    radius: number;\r\n\r\n    /**\r\n     * Agent height. [Limit: > 0]\r\n     */\r\n    height: number;\r\n\r\n    /**\r\n     *  Maximum allowed acceleration. [Limit: >= 0]\r\n     */\r\n    maxAcceleration: number;\r\n\r\n    /**\r\n     * Maximum allowed speed. [Limit: >= 0]\r\n     */\r\n    maxSpeed: number;\r\n\r\n    /**\r\n     * Defines how close a collision element must be before it is considered for steering behaviors. [Limits: > 0]\r\n     */\r\n    collisionQueryRange: number;\r\n\r\n    /**\r\n     * The path visibility optimization range. [Limit: > 0]\r\n     */\r\n    pathOptimizationRange: number;\r\n\r\n    /**\r\n     * How aggressive the agent manager should be at avoiding collisions with this agent. [Limit: >= 0]\r\n     */\r\n    separationWeight: number;\r\n\r\n    /**\r\n     * Observers will be notified when agent gets inside the virtual circle with this Radius around destination point.\r\n     * Default is agent radius\r\n     */\r\n    reachRadius?: number;\r\n}\r\n\r\n/**\r\n * Configures the navigation mesh creation\r\n */\r\nexport interface INavMeshParameters {\r\n    /**\r\n     * The xz-plane cell size to use for fields. [Limit: > 0] [Units: wu]\r\n     */\r\n    cs: number;\r\n\r\n    /**\r\n     * The y-axis cell size to use for fields. [Limit: > 0] [Units: wu]\r\n     */\r\n    ch: number;\r\n\r\n    /**\r\n     * The maximum slope that is considered walkable. [Limits: 0 <= value < 90] [Units: Degrees]\r\n     */\r\n    walkableSlopeAngle: number;\r\n\r\n    /**\r\n     * Minimum floor to 'ceiling' height that will still allow the floor area to\r\n     * be considered walkable. [Limit: >= 3] [Units: vx]\r\n     */\r\n    walkableHeight: number;\r\n\r\n    /**\r\n     * Maximum ledge height that is considered to still be traversable. [Limit: >=0] [Units: vx]\r\n     */\r\n    walkableClimb: number;\r\n\r\n    /**\r\n     * The distance to erode/shrink the walkable area of the heightfield away from\r\n     * obstructions.  [Limit: >=0] [Units: vx]\r\n     */\r\n    walkableRadius: number;\r\n\r\n    /**\r\n     * The maximum allowed length for contour edges along the border of the mesh. [Limit: >=0] [Units: vx]\r\n     */\r\n    maxEdgeLen: number;\r\n\r\n    /**\r\n     * The maximum distance a simplified contour's border edges should deviate\r\n     * the original raw contour. [Limit: >=0] [Units: vx]\r\n     */\r\n    maxSimplificationError: number;\r\n\r\n    /**\r\n     * The minimum number of cells allowed to form isolated island areas. [Limit: >=0] [Units: vx]\r\n     */\r\n    minRegionArea: number;\r\n\r\n    /**\r\n     * Any regions with a span count smaller than this value will, if possible,\r\n     * be merged with larger regions. [Limit: >=0] [Units: vx]\r\n     */\r\n    mergeRegionArea: number;\r\n\r\n    /**\r\n     * The maximum number of vertices allowed for polygons generated during the\r\n     * contour to polygon conversion process. [Limit: >= 3]\r\n     */\r\n    maxVertsPerPoly: number;\r\n\r\n    /**\r\n     * Sets the sampling distance to use when generating the detail mesh.\r\n     * (For height detail only.) [Limits: 0 or >= 0.9] [Units: wu]\r\n     */\r\n    detailSampleDist: number;\r\n\r\n    /**\r\n     * The maximum distance the detail mesh surface should deviate from heightfield\r\n     * data. (For height detail only.) [Limit: >=0] [Units: wu]\r\n     */\r\n    detailSampleMaxError: number;\r\n\r\n    /**\r\n     * If using obstacles, the navmesh must be subdivided internaly by tiles.\r\n     * This member defines the tile cube side length in world units.\r\n     * If no obstacles are needed, leave it undefined or 0.\r\n     */\r\n    tileSize?: number;\r\n\r\n    /**\r\n     * The size of the non-navigable border around the heightfield.\r\n     */\r\n    borderSize?: number;\r\n}\r\n"]}